# 0 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
# 856 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
# 1 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 1
# 49 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
       






# 1 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imconfig.h" 1
# 15 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imconfig.h"
       
# 57 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 2
# 65 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/float.h" 1 3 4
# 66 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4

# 40 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 99 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 67 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 68 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timesize.h" 1 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 6 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/gnu/stubs-lp64.h" 1 3 4
# 9 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 539 "/usr/include/string.h" 3 4
}
# 69 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 2
# 82 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 83 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 2
# 123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wclass-memaccess"








# 133 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImDrawChannel;
struct ImDrawCmd;
struct ImDrawData;
struct ImDrawList;
struct ImDrawListSharedData;
struct ImDrawListSplitter;
struct ImDrawVert;
struct ImFont;
struct ImFontAtlas;
struct ImFontBuilderIO;
struct ImFontConfig;
struct ImFontGlyph;
struct ImFontGlyphRangesBuilder;
struct ImColor;
struct ImGuiContext;
struct ImGuiIO;
struct ImGuiInputTextCallbackData;
struct ImGuiKeyData;
struct ImGuiListClipper;
struct ImGuiOnceUponAFrame;
struct ImGuiPayload;
struct ImGuiPlatformImeData;
struct ImGuiSizeCallbackData;
struct ImGuiStorage;
struct ImGuiStyle;
struct ImGuiTableSortSpecs;
struct ImGuiTableColumnSortSpecs;
struct ImGuiTextBuffer;
struct ImGuiTextFilter;
struct ImGuiViewport;






enum ImGuiKey : int;
typedef int ImGuiCol;
typedef int ImGuiCond;
typedef int ImGuiDataType;
typedef int ImGuiDir;
typedef int ImGuiMouseButton;
typedef int ImGuiMouseCursor;
typedef int ImGuiSortDirection;
typedef int ImGuiStyleVar;
typedef int ImGuiTableBgTarget;





typedef int ImDrawFlags;
typedef int ImDrawListFlags;
typedef int ImFontAtlasFlags;
typedef int ImGuiBackendFlags;
typedef int ImGuiButtonFlags;
typedef int ImGuiColorEditFlags;
typedef int ImGuiConfigFlags;
typedef int ImGuiComboFlags;
typedef int ImGuiDragDropFlags;
typedef int ImGuiFocusedFlags;
typedef int ImGuiHoveredFlags;
typedef int ImGuiInputTextFlags;
typedef int ImGuiKeyChord;
typedef int ImGuiPopupFlags;
typedef int ImGuiSelectableFlags;
typedef int ImGuiSliderFlags;
typedef int ImGuiTabBarFlags;
typedef int ImGuiTabItemFlags;
typedef int ImGuiTableFlags;
typedef int ImGuiTableColumnFlags;
typedef int ImGuiTableRowFlags;
typedef int ImGuiTreeNodeFlags;
typedef int ImGuiViewportFlags;
typedef int ImGuiWindowFlags;





typedef void* ImTextureID;






typedef unsigned short ImDrawIdx;



typedef unsigned int ImGuiID;
typedef signed char ImS8;
typedef unsigned char ImU8;
typedef signed short ImS16;
typedef unsigned short ImU16;
typedef signed int ImS32;
typedef unsigned int ImU32;
typedef signed long long ImS64;
typedef unsigned long long ImU64;



typedef unsigned short ImWchar16;
typedef unsigned int ImWchar32;



typedef ImWchar16 ImWchar;



typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData* data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);
typedef void* (*ImGuiMemAllocFunc)(size_t sz, void* user_data);
typedef void (*ImGuiMemFreeFunc)(void* ptr, void* user_data);




struct ImVec2
{
    float x, y;
    constexpr ImVec2() : x(0.0f), y(0.0f) { }
    constexpr ImVec2(float _x, float _y) : x(_x), y(_y) { }
    float operator[] (size_t idx) const { 
# 258 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                             (static_cast <bool> (
# 258 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                             idx <= 1
# 258 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                             ) ? void (0) : __assert_fail (
# 258 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                             "idx <= 1"
# 258 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 258, __extension__ __PRETTY_FUNCTION__))
# 258 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                ; return (&x)[idx]; }
    float& operator[] (size_t idx) { 
# 259 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                             (static_cast <bool> (
# 259 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                             idx <= 1
# 259 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                             ) ? void (0) : __assert_fail (
# 259 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                             "idx <= 1"
# 259 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 259, __extension__ __PRETTY_FUNCTION__))
# 259 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                ; return (&x)[idx]; }



};


struct ImVec4
{
    float x, y, z, w;
    constexpr ImVec4() : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
    constexpr ImVec4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) { }



};







namespace ImGui
{




    ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = 
# 288 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                          __null
# 288 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                              );
    void DestroyContext(ImGuiContext* ctx = 
# 289 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                              __null
# 289 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                  );
    ImGuiContext* GetCurrentContext();
    void SetCurrentContext(ImGuiContext* ctx);


    ImGuiIO& GetIO();
    ImGuiStyle& GetStyle();
    void NewFrame();
    void EndFrame();
    void Render();
    ImDrawData* GetDrawData();


    void ShowDemoWindow(bool* p_open = 
# 302 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                         __null
# 302 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             );
    void ShowMetricsWindow(bool* p_open = 
# 303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                            __null
# 303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                );
    void ShowDebugLogWindow(bool* p_open = 
# 304 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             __null
# 304 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                 );
    void ShowStackToolWindow(bool* p_open = 
# 305 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                              __null
# 305 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                  );
    void ShowAboutWindow(bool* p_open = 
# 306 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                          __null
# 306 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                              );
    void ShowStyleEditor(ImGuiStyle* ref = 
# 307 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             __null
# 307 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                 );
    bool ShowStyleSelector(const char* label);
    void ShowFontSelector(const char* label);
    void ShowUserGuide();
    const char* GetVersion();


    void StyleColorsDark(ImGuiStyle* dst = 
# 314 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             __null
# 314 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                 );
    void StyleColorsLight(ImGuiStyle* dst = 
# 315 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                              __null
# 315 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                  );
    void StyleColorsClassic(ImGuiStyle* dst = 
# 316 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                __null
# 316 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                    );
# 330 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    bool Begin(const char* name, bool* p_open = 
# 330 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                  __null
# 330 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                      , ImGuiWindowFlags flags = 0);
    void End();
# 341 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    bool BeginChild(const char* str_id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0);
    bool BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0);
    void EndChild();



    bool IsWindowAppearing();
    bool IsWindowCollapsed();
    bool IsWindowFocused(ImGuiFocusedFlags flags=0);
    bool IsWindowHovered(ImGuiHoveredFlags flags=0);
    ImDrawList* GetWindowDrawList();
    ImVec2 GetWindowPos();
    ImVec2 GetWindowSize();
    float GetWindowWidth();
    float GetWindowHeight();



    void SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0, 0));
    void SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);
    void SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = 
# 361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                            __null
# 361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                , void* custom_callback_data = 
# 361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                               __null
# 361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                   );
    void SetNextWindowContentSize(const ImVec2& size);
    void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);
    void SetNextWindowFocus();
    void SetNextWindowScroll(const ImVec2& scroll);
    void SetNextWindowBgAlpha(float alpha);
    void SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);
    void SetWindowFocus();
    void SetWindowFontScale(float scale);
    void SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);
    void SetWindowFocus(const char* name);




    ImVec2 GetContentRegionAvail();
    ImVec2 GetContentRegionMax();
    ImVec2 GetWindowContentRegionMin();
    ImVec2 GetWindowContentRegionMax();




    float GetScrollX();
    float GetScrollY();
    void SetScrollX(float scroll_x);
    void SetScrollY(float scroll_y);
    float GetScrollMaxX();
    float GetScrollMaxY();
    void SetScrollHereX(float center_x_ratio = 0.5f);
    void SetScrollHereY(float center_y_ratio = 0.5f);
    void SetScrollFromPosX(float local_x, float center_x_ratio = 0.5f);
    void SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);


    void PushFont(ImFont* font);
    void PopFont();
    void PushStyleColor(ImGuiCol idx, ImU32 col);
    void PushStyleColor(ImGuiCol idx, const ImVec4& col);
    void PopStyleColor(int count = 1);
    void PushStyleVar(ImGuiStyleVar idx, float val);
    void PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    void PopStyleVar(int count = 1);
    void PushAllowKeyboardFocus(bool allow_keyboard_focus);
    void PopAllowKeyboardFocus();
    void PushButtonRepeat(bool repeat);
    void PopButtonRepeat();


    void PushItemWidth(float item_width);
    void PopItemWidth();
    void SetNextItemWidth(float item_width);
    float CalcItemWidth();
    void PushTextWrapPos(float wrap_local_pos_x = 0.0f);
    void PopTextWrapPos();



    ImFont* GetFont();
    float GetFontSize();
    ImVec2 GetFontTexUvWhitePixel();
    ImU32 GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);
    ImU32 GetColorU32(const ImVec4& col);
    ImU32 GetColorU32(ImU32 col);
    const ImVec4& GetStyleColorVec4(ImGuiCol idx);
# 438 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    void Separator();
    void SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);
    void NewLine();
    void Spacing();
    void Dummy(const ImVec2& size);
    void Indent(float indent_w = 0.0f);
    void Unindent(float indent_w = 0.0f);
    void BeginGroup();
    void EndGroup();
    ImVec2 GetCursorPos();
    float GetCursorPosX();
    float GetCursorPosY();
    void SetCursorPos(const ImVec2& local_pos);
    void SetCursorPosX(float local_x);
    void SetCursorPosY(float local_y);
    ImVec2 GetCursorStartPos();
    ImVec2 GetCursorScreenPos();
    void SetCursorScreenPos(const ImVec2& pos);
    void AlignTextToFramePadding();
    float GetTextLineHeight();
    float GetTextLineHeightWithSpacing();
    float GetFrameHeight();
    float GetFrameHeightWithSpacing();
# 473 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    void PushID(const char* str_id);
    void PushID(const char* str_id_begin, const char* str_id_end);
    void PushID(const void* ptr_id);
    void PushID(int int_id);
    void PopID();
    ImGuiID GetID(const char* str_id);
    ImGuiID GetID(const char* str_id_begin, const char* str_id_end);
    ImGuiID GetID(const void* ptr_id);


    void TextUnformatted(const char* text, const char* text_end = 
# 483 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                    __null
# 483 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                        );
    void Text(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void TextColored(const ImVec4& col, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void TextColoredV(const ImVec4& col, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    void TextDisabled(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextDisabledV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void TextWrapped(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextWrappedV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void LabelText(const char* label, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void LabelTextV(const char* label, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    void BulletText(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void BulletTextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));




    bool Button(const char* label, const ImVec2& size = ImVec2(0, 0));
    bool SmallButton(const char* label);
    bool InvisibleButton(const char* str_id, const ImVec2& size, ImGuiButtonFlags flags = 0);
    bool ArrowButton(const char* str_id, ImGuiDir dir);
    bool Checkbox(const char* label, bool* v);
    bool CheckboxFlags(const char* label, int* flags, int flags_value);
    bool CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    bool RadioButton(const char* label, bool active);
    bool RadioButton(const char* label, int* v, int v_button);
    void ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1.17549435082228750796873653722224568e-38F, 0), const char* overlay = 
# 509 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                           __null
# 509 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                               );
    void Bullet();



    void Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1), const ImVec4& border_col = ImVec4(0, 0, 0, 0));
    bool ImageButton(const char* str_id, ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1));




    bool BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    void EndCombo();
    bool Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    bool Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);
    bool Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);
# 538 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    bool DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = 
# 542 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                                              __null
# 542 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                                                  , ImGuiSliderFlags flags = 0);
    bool DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = 
# 547 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                            __null
# 547 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                                , ImGuiSliderFlags flags = 0);
    bool DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed = 1.0f, const void* p_min = 
# 548 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                          __null
# 548 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                              , const void* p_max = 
# 548 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                    __null
# 548 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                        , const char* format = 
# 548 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                               __null
# 548 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                   , ImGuiSliderFlags flags = 0);
    bool DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed = 1.0f, const void* p_min = 
# 549 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                           __null
# 549 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                               , const void* p_max = 
# 549 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                     __null
# 549 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                         , const char* format = 
# 549 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                                __null
# 549 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                                    , ImGuiSliderFlags flags = 0);







    bool SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg", ImGuiSliderFlags flags = 0);
    bool SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = 
# 566 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                             __null
# 566 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                 , ImGuiSliderFlags flags = 0);
    bool SliderScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format = 
# 567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                              __null
# 567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                  , ImGuiSliderFlags flags = 0);
    bool VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = 
# 570 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                  __null
# 570 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                      , ImGuiSliderFlags flags = 0);




    bool InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                     __null
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                         , void* user_data = 
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                             __null
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                 );
    bool InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                 __null
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                     , void* user_data = 
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                                         __null
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                                             );
    bool InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                               __null
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                   , void* user_data = 
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                       __null
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                           );
    bool InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);
    bool InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);
    bool InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);
    bool InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);
    bool InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
    bool InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = 
# 587 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                      __null
# 587 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                          , const void* p_step_fast = 
# 587 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                      __null
# 587 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                          , const char* format = 
# 587 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                 __null
# 587 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                     , ImGuiInputTextFlags flags = 0);
    bool InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = 
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                       __null
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                           , const void* p_step_fast = 
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                       __null
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                           , const char* format = 
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                  __null
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                      , ImGuiInputTextFlags flags = 0);




    bool ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    bool ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    bool ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    bool ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = 
# 596 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                               __null
# 596 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                   );
    bool ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
    void SetColorEditOptions(ImGuiColorEditFlags flags);



    bool TreeNode(const char* label);
    bool TreeNode(const char* str_id, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    bool TreeNode(const void* ptr_id, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    bool TreeNodeV(const char* str_id, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    bool TreeNodeV(const void* ptr_id, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    bool TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    bool TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
    bool TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
    bool TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
    bool TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
    void TreePush(const char* str_id);
    void TreePush(const void* ptr_id);
    void TreePop();
    float GetTreeNodeToLabelSpacing();
    bool CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);
    bool CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags = 0);
    void SetNextItemOpen(bool is_open, ImGuiCond cond = 0);




    bool Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
    bool Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));







    bool BeginListBox(const char* label, const ImVec2& size = ImVec2(0, 0));
    void EndListBox();
    bool ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    bool ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);



    void PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = 
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                 __null
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                     , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    void PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = 
# 640 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                    __null
# 640 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                        , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0));
    void PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = 
# 641 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                     __null
# 641 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                         , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    void PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = 
# 642 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                        __null
# 642 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                            , float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0));



    void Value(const char* prefix, bool b);
    void Value(const char* prefix, int v);
    void Value(const char* prefix, unsigned int v);
    void Value(const char* prefix, float v, const char* float_format = 
# 649 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                         __null
# 649 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                             );






    bool BeginMenuBar();
    void EndMenuBar();
    bool BeginMainMenuBar();
    void EndMainMenuBar();
    bool BeginMenu(const char* label, bool enabled = true);
    void EndMenu();
    bool MenuItem(const char* label, const char* shortcut = 
# 662 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                              __null
# 662 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                  , bool selected = false, bool enabled = true);
    bool MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);



    void BeginTooltip();
    void EndTooltip();
    void SetTooltip(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void SetTooltipV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
# 684 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    bool BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);
    bool BeginPopupModal(const char* name, bool* p_open = 
# 685 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                            __null
# 685 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                , ImGuiWindowFlags flags = 0);
    void EndPopup();
# 696 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    void OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags = 0);
    void OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags = 0);
    void OpenPopupOnItemClick(const char* str_id = 
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                     __null
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                         , ImGuiPopupFlags popup_flags = 1);
    void CloseCurrentPopup();






    bool BeginPopupContextItem(const char* str_id = 
# 706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                      __null
# 706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                          , ImGuiPopupFlags popup_flags = 1);
    bool BeginPopupContextWindow(const char* str_id = 
# 707 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                        __null
# 707 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                            , ImGuiPopupFlags popup_flags = 1);
    bool BeginPopupContextVoid(const char* str_id = 
# 708 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                      __null
# 708 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                          , ImGuiPopupFlags popup_flags = 1);





    bool IsPopupOpen(const char* str_id, ImGuiPopupFlags flags = 0);
# 739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    bool BeginTable(const char* str_id, int column, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0.0f, 0.0f), float inner_width = 0.0f);
    void EndTable();
    void TableNextRow(ImGuiTableRowFlags row_flags = 0, float min_row_height = 0.0f);
    bool TableNextColumn();
    bool TableSetColumnIndex(int column_n);
# 753 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    void TableSetupColumn(const char* label, ImGuiTableColumnFlags flags = 0, float init_width_or_weight = 0.0f, ImGuiID user_id = 0);
    void TableSetupScrollFreeze(int cols, int rows);
    void TableHeadersRow();
    void TableHeader(const char* label);







    ImGuiTableSortSpecs* TableGetSortSpecs();
    int TableGetColumnCount();
    int TableGetColumnIndex();
    int TableGetRowIndex();
    const char* TableGetColumnName(int column_n = -1);
    ImGuiTableColumnFlags TableGetColumnFlags(int column_n = -1);
    void TableSetColumnEnabled(int column_n, bool v);
    void TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n = -1);



    void Columns(int count = 1, const char* id = 
# 775 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                   __null
# 775 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                       , bool border = true);
    void NextColumn();
    int GetColumnIndex();
    float GetColumnWidth(int column_index = -1);
    void SetColumnWidth(int column_index, float width);
    float GetColumnOffset(int column_index = -1);
    void SetColumnOffset(int column_index, float offset_x);
    int GetColumnsCount();


    bool BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);
    void EndTabBar();
    bool BeginTabItem(const char* label, bool* p_open = 
# 787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                          __null
# 787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                              , ImGuiTabItemFlags flags = 0);
    void EndTabItem();
    bool TabItemButton(const char* label, ImGuiTabItemFlags flags = 0);
    void SetTabItemClosed(const char* tab_or_docked_window_label);



    void LogToTTY(int auto_open_depth = -1);
    void LogToFile(int auto_open_depth = -1, const char* filename = 
# 795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                      __null
# 795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                          );
    void LogToClipboard(int auto_open_depth = -1);
    void LogFinish();
    void LogButtons();
    void LogText(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void LogTextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));






    bool BeginDragDropSource(ImGuiDragDropFlags flags = 0);
    bool SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);
    void EndDragDropSource();
    bool BeginDragDropTarget();
    const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);
    void EndDragDropTarget();
    const ImGuiPayload* GetDragDropPayload();





    void BeginDisabled(bool disabled = true);
    void EndDisabled();



    void PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    void PopClipRect();



    void SetItemDefaultFocus();
    void SetKeyboardFocusHere(int offset = 0);




    bool IsItemHovered(ImGuiHoveredFlags flags = 0);
    bool IsItemActive();
    bool IsItemFocused();
    bool IsItemClicked(ImGuiMouseButton mouse_button = 0);
    bool IsItemVisible();
    bool IsItemEdited();
    bool IsItemActivated();
    bool IsItemDeactivated();
    bool IsItemDeactivatedAfterEdit();
    bool IsItemToggledOpen();
    bool IsAnyItemHovered();
    bool IsAnyItemActive();
    bool IsAnyItemFocused();
    ImVec2 GetItemRectMin();
    ImVec2 GetItemRectMax();
    ImVec2 GetItemRectSize();
    void SetItemAllowOverlap();





    ImGuiViewport* GetMainViewport();


    ImDrawList* GetBackgroundDrawList();
    ImDrawList* GetForegroundDrawList();


    bool IsRectVisible(const ImVec2& size);
    bool IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);
    double GetTime();
    int GetFrameCount();
    ImDrawListSharedData* GetDrawListSharedData();
    const char* GetStyleColorName(ImGuiCol idx);
    void SetStateStorage(ImGuiStorage* storage);
    ImGuiStorage* GetStateStorage();
    bool BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0);
    void EndChildFrame();


    ImVec2 CalcTextSize(const char* text, const char* text_end = 
# 876 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                 __null
# 876 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                     , bool hide_text_after_double_hash = false, float wrap_width = -1.0f);


    ImVec4 ColorConvertU32ToFloat4(ImU32 in);
    ImU32 ColorConvertFloat4ToU32(const ImVec4& in);
    void ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    void ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);







    bool IsKeyDown(ImGuiKey key);
    bool IsKeyPressed(ImGuiKey key, bool repeat = true);
    bool IsKeyReleased(ImGuiKey key);
    int GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float rate);
    const char* GetKeyName(ImGuiKey key);
    void SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard);





    bool IsMouseDown(ImGuiMouseButton button);
    bool IsMouseClicked(ImGuiMouseButton button, bool repeat = false);
    bool IsMouseReleased(ImGuiMouseButton button);
    bool IsMouseDoubleClicked(ImGuiMouseButton button);
    int GetMouseClickedCount(ImGuiMouseButton button);
    bool IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);
    bool IsMousePosValid(const ImVec2* mouse_pos = 
# 907 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                     __null
# 907 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                         );
    bool IsAnyMouseDown();
    ImVec2 GetMousePos();
    ImVec2 GetMousePosOnOpeningCurrentPopup();
    bool IsMouseDragging(ImGuiMouseButton button, float lock_threshold = -1.0f);
    ImVec2 GetMouseDragDelta(ImGuiMouseButton button = 0, float lock_threshold = -1.0f);
    void ResetMouseDragDelta(ImGuiMouseButton button = 0);
    ImGuiMouseCursor GetMouseCursor();
    void SetMouseCursor(ImGuiMouseCursor cursor_type);
    void SetNextFrameWantCaptureMouse(bool want_capture_mouse);



    const char* GetClipboardText();
    void SetClipboardText(const char* text);





    void LoadIniSettingsFromDisk(const char* ini_filename);
    void LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0);
    void SaveIniSettingsToDisk(const char* ini_filename);
    const char* SaveIniSettingsToMemory(size_t* out_ini_size = 
# 930 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                          __null
# 930 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                              );


    void DebugTextEncoding(const char* text);
    bool DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx);





    void SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data = 
# 940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                             __null
# 940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                 );
    void GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data);
    void* MemAlloc(size_t size);
    void MemFree(void* ptr);

}







enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None = 0,
    ImGuiWindowFlags_NoTitleBar = 1 << 0,
    ImGuiWindowFlags_NoResize = 1 << 1,
    ImGuiWindowFlags_NoMove = 1 << 2,
    ImGuiWindowFlags_NoScrollbar = 1 << 3,
    ImGuiWindowFlags_NoScrollWithMouse = 1 << 4,
    ImGuiWindowFlags_NoCollapse = 1 << 5,
    ImGuiWindowFlags_AlwaysAutoResize = 1 << 6,
    ImGuiWindowFlags_NoBackground = 1 << 7,
    ImGuiWindowFlags_NoSavedSettings = 1 << 8,
    ImGuiWindowFlags_NoMouseInputs = 1 << 9,
    ImGuiWindowFlags_MenuBar = 1 << 10,
    ImGuiWindowFlags_HorizontalScrollbar = 1 << 11,
    ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12,
    ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13,
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,
    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,
    ImGuiWindowFlags_NoNavInputs = 1 << 18,
    ImGuiWindowFlags_NoNavFocus = 1 << 19,
    ImGuiWindowFlags_UnsavedDocument = 1 << 20,
    ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,


    ImGuiWindowFlags_NavFlattened = 1 << 23,
    ImGuiWindowFlags_ChildWindow = 1 << 24,
    ImGuiWindowFlags_Tooltip = 1 << 25,
    ImGuiWindowFlags_Popup = 1 << 26,
    ImGuiWindowFlags_Modal = 1 << 27,
    ImGuiWindowFlags_ChildMenu = 1 << 28,
};



enum ImGuiInputTextFlags_
{
    ImGuiInputTextFlags_None = 0,
    ImGuiInputTextFlags_CharsDecimal = 1 << 0,
    ImGuiInputTextFlags_CharsHexadecimal = 1 << 1,
    ImGuiInputTextFlags_CharsUppercase = 1 << 2,
    ImGuiInputTextFlags_CharsNoBlank = 1 << 3,
    ImGuiInputTextFlags_AutoSelectAll = 1 << 4,
    ImGuiInputTextFlags_EnterReturnsTrue = 1 << 5,
    ImGuiInputTextFlags_CallbackCompletion = 1 << 6,
    ImGuiInputTextFlags_CallbackHistory = 1 << 7,
    ImGuiInputTextFlags_CallbackAlways = 1 << 8,
    ImGuiInputTextFlags_CallbackCharFilter = 1 << 9,
    ImGuiInputTextFlags_AllowTabInput = 1 << 10,
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,
    ImGuiInputTextFlags_NoHorizontalScroll = 1 << 12,
    ImGuiInputTextFlags_AlwaysOverwrite = 1 << 13,
    ImGuiInputTextFlags_ReadOnly = 1 << 14,
    ImGuiInputTextFlags_Password = 1 << 15,
    ImGuiInputTextFlags_NoUndoRedo = 1 << 16,
    ImGuiInputTextFlags_CharsScientific = 1 << 17,
    ImGuiInputTextFlags_CallbackResize = 1 << 18,
    ImGuiInputTextFlags_CallbackEdit = 1 << 19,
    ImGuiInputTextFlags_EscapeClearsAll = 1 << 20,



    ImGuiInputTextFlags_AlwaysInsertMode = ImGuiInputTextFlags_AlwaysOverwrite

};


enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None = 0,
    ImGuiTreeNodeFlags_Selected = 1 << 0,
    ImGuiTreeNodeFlags_Framed = 1 << 1,
    ImGuiTreeNodeFlags_AllowItemOverlap = 1 << 2,
    ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3,
    ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4,
    ImGuiTreeNodeFlags_DefaultOpen = 1 << 5,
    ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6,
    ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7,
    ImGuiTreeNodeFlags_Leaf = 1 << 8,
    ImGuiTreeNodeFlags_Bullet = 1 << 9,
    ImGuiTreeNodeFlags_FramePadding = 1 << 10,
    ImGuiTreeNodeFlags_SpanAvailWidth = 1 << 11,
    ImGuiTreeNodeFlags_SpanFullWidth = 1 << 12,
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,

    ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog,
};
# 1052 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
enum ImGuiPopupFlags_
{
    ImGuiPopupFlags_None = 0,
    ImGuiPopupFlags_MouseButtonLeft = 0,
    ImGuiPopupFlags_MouseButtonRight = 1,
    ImGuiPopupFlags_MouseButtonMiddle = 2,
    ImGuiPopupFlags_MouseButtonMask_ = 0x1F,
    ImGuiPopupFlags_MouseButtonDefault_ = 1,
    ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 5,
    ImGuiPopupFlags_NoOpenOverItems = 1 << 6,
    ImGuiPopupFlags_AnyPopupId = 1 << 7,
    ImGuiPopupFlags_AnyPopupLevel = 1 << 8,
    ImGuiPopupFlags_AnyPopup = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel,
};


enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None = 0,
    ImGuiSelectableFlags_DontClosePopups = 1 << 0,
    ImGuiSelectableFlags_SpanAllColumns = 1 << 1,
    ImGuiSelectableFlags_AllowDoubleClick = 1 << 2,
    ImGuiSelectableFlags_Disabled = 1 << 3,
    ImGuiSelectableFlags_AllowItemOverlap = 1 << 4,
};


enum ImGuiComboFlags_
{
    ImGuiComboFlags_None = 0,
    ImGuiComboFlags_PopupAlignLeft = 1 << 0,
    ImGuiComboFlags_HeightSmall = 1 << 1,
    ImGuiComboFlags_HeightRegular = 1 << 2,
    ImGuiComboFlags_HeightLarge = 1 << 3,
    ImGuiComboFlags_HeightLargest = 1 << 4,
    ImGuiComboFlags_NoArrowButton = 1 << 5,
    ImGuiComboFlags_NoPreview = 1 << 6,
    ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest,
};


enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None = 0,
    ImGuiTabBarFlags_Reorderable = 1 << 0,
    ImGuiTabBarFlags_AutoSelectNewTabs = 1 << 1,
    ImGuiTabBarFlags_TabListPopupButton = 1 << 2,
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 1 << 3,
    ImGuiTabBarFlags_NoTabListScrollingButtons = 1 << 4,
    ImGuiTabBarFlags_NoTooltip = 1 << 5,
    ImGuiTabBarFlags_FittingPolicyResizeDown = 1 << 6,
    ImGuiTabBarFlags_FittingPolicyScroll = 1 << 7,
    ImGuiTabBarFlags_FittingPolicyMask_ = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_ = ImGuiTabBarFlags_FittingPolicyResizeDown,
};


enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None = 0,
    ImGuiTabItemFlags_UnsavedDocument = 1 << 0,
    ImGuiTabItemFlags_SetSelected = 1 << 1,
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2,
    ImGuiTabItemFlags_NoPushId = 1 << 3,
    ImGuiTabItemFlags_NoTooltip = 1 << 4,
    ImGuiTabItemFlags_NoReorder = 1 << 5,
    ImGuiTabItemFlags_Leading = 1 << 6,
    ImGuiTabItemFlags_Trailing = 1 << 7,
};
# 1144 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
enum ImGuiTableFlags_
{

    ImGuiTableFlags_None = 0,
    ImGuiTableFlags_Resizable = 1 << 0,
    ImGuiTableFlags_Reorderable = 1 << 1,
    ImGuiTableFlags_Hideable = 1 << 2,
    ImGuiTableFlags_Sortable = 1 << 3,
    ImGuiTableFlags_NoSavedSettings = 1 << 4,
    ImGuiTableFlags_ContextMenuInBody = 1 << 5,

    ImGuiTableFlags_RowBg = 1 << 6,
    ImGuiTableFlags_BordersInnerH = 1 << 7,
    ImGuiTableFlags_BordersOuterH = 1 << 8,
    ImGuiTableFlags_BordersInnerV = 1 << 9,
    ImGuiTableFlags_BordersOuterV = 1 << 10,
    ImGuiTableFlags_BordersH = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH,
    ImGuiTableFlags_BordersV = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV,
    ImGuiTableFlags_BordersInner = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH,
    ImGuiTableFlags_BordersOuter = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH,
    ImGuiTableFlags_Borders = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter,
    ImGuiTableFlags_NoBordersInBody = 1 << 11,
    ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12,

    ImGuiTableFlags_SizingFixedFit = 1 << 13,
    ImGuiTableFlags_SizingFixedSame = 2 << 13,
    ImGuiTableFlags_SizingStretchProp = 3 << 13,
    ImGuiTableFlags_SizingStretchSame = 4 << 13,

    ImGuiTableFlags_NoHostExtendX = 1 << 16,
    ImGuiTableFlags_NoHostExtendY = 1 << 17,
    ImGuiTableFlags_NoKeepColumnsVisible = 1 << 18,
    ImGuiTableFlags_PreciseWidths = 1 << 19,

    ImGuiTableFlags_NoClip = 1 << 20,

    ImGuiTableFlags_PadOuterX = 1 << 21,
    ImGuiTableFlags_NoPadOuterX = 1 << 22,
    ImGuiTableFlags_NoPadInnerX = 1 << 23,

    ImGuiTableFlags_ScrollX = 1 << 24,
    ImGuiTableFlags_ScrollY = 1 << 25,

    ImGuiTableFlags_SortMulti = 1 << 26,
    ImGuiTableFlags_SortTristate = 1 << 27,


    ImGuiTableFlags_SizingMask_ = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame,
};


enum ImGuiTableColumnFlags_
{

    ImGuiTableColumnFlags_None = 0,
    ImGuiTableColumnFlags_Disabled = 1 << 0,
    ImGuiTableColumnFlags_DefaultHide = 1 << 1,
    ImGuiTableColumnFlags_DefaultSort = 1 << 2,
    ImGuiTableColumnFlags_WidthStretch = 1 << 3,
    ImGuiTableColumnFlags_WidthFixed = 1 << 4,
    ImGuiTableColumnFlags_NoResize = 1 << 5,
    ImGuiTableColumnFlags_NoReorder = 1 << 6,
    ImGuiTableColumnFlags_NoHide = 1 << 7,
    ImGuiTableColumnFlags_NoClip = 1 << 8,
    ImGuiTableColumnFlags_NoSort = 1 << 9,
    ImGuiTableColumnFlags_NoSortAscending = 1 << 10,
    ImGuiTableColumnFlags_NoSortDescending = 1 << 11,
    ImGuiTableColumnFlags_NoHeaderLabel = 1 << 12,
    ImGuiTableColumnFlags_NoHeaderWidth = 1 << 13,
    ImGuiTableColumnFlags_PreferSortAscending = 1 << 14,
    ImGuiTableColumnFlags_PreferSortDescending = 1 << 15,
    ImGuiTableColumnFlags_IndentEnable = 1 << 16,
    ImGuiTableColumnFlags_IndentDisable = 1 << 17,


    ImGuiTableColumnFlags_IsEnabled = 1 << 24,
    ImGuiTableColumnFlags_IsVisible = 1 << 25,
    ImGuiTableColumnFlags_IsSorted = 1 << 26,
    ImGuiTableColumnFlags_IsHovered = 1 << 27,


    ImGuiTableColumnFlags_WidthMask_ = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,
    ImGuiTableColumnFlags_IndentMask_ = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,
    ImGuiTableColumnFlags_StatusMask_ = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,
    ImGuiTableColumnFlags_NoDirectResize_ = 1 << 30,
};


enum ImGuiTableRowFlags_
{
    ImGuiTableRowFlags_None = 0,
    ImGuiTableRowFlags_Headers = 1 << 0,
};
# 1247 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
enum ImGuiTableBgTarget_
{
    ImGuiTableBgTarget_None = 0,
    ImGuiTableBgTarget_RowBg0 = 1,
    ImGuiTableBgTarget_RowBg1 = 2,
    ImGuiTableBgTarget_CellBg = 3,
};


enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None = 0,
    ImGuiFocusedFlags_ChildWindows = 1 << 0,
    ImGuiFocusedFlags_RootWindow = 1 << 1,
    ImGuiFocusedFlags_AnyWindow = 1 << 2,
    ImGuiFocusedFlags_NoPopupHierarchy = 1 << 3,

    ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows,
};




enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None = 0,
    ImGuiHoveredFlags_ChildWindows = 1 << 0,
    ImGuiHoveredFlags_RootWindow = 1 << 1,
    ImGuiHoveredFlags_AnyWindow = 1 << 2,
    ImGuiHoveredFlags_NoPopupHierarchy = 1 << 3,

    ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 5,

    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 7,
    ImGuiHoveredFlags_AllowWhenOverlapped = 1 << 8,
    ImGuiHoveredFlags_AllowWhenDisabled = 1 << 9,
    ImGuiHoveredFlags_NoNavOverride = 1 << 10,
    ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows,


    ImGuiHoveredFlags_DelayNormal = 1 << 11,
    ImGuiHoveredFlags_DelayShort = 1 << 12,
    ImGuiHoveredFlags_NoSharedDelay = 1 << 13,
};


enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None = 0,

    ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0,
    ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1,
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2,
    ImGuiDragDropFlags_SourceAllowNullID = 1 << 3,
    ImGuiDragDropFlags_SourceExtern = 1 << 4,
    ImGuiDragDropFlags_SourceAutoExpirePayload = 1 << 5,

    ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10,
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11,
    ImGuiDragDropFlags_AcceptNoPreviewTooltip = 1 << 12,
    ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect,
};






enum ImGuiDataType_
{
    ImGuiDataType_S8,
    ImGuiDataType_U8,
    ImGuiDataType_S16,
    ImGuiDataType_U16,
    ImGuiDataType_S32,
    ImGuiDataType_U32,
    ImGuiDataType_S64,
    ImGuiDataType_U64,
    ImGuiDataType_Float,
    ImGuiDataType_Double,
    ImGuiDataType_COUNT
};


enum ImGuiDir_
{
    ImGuiDir_None = -1,
    ImGuiDir_Left = 0,
    ImGuiDir_Right = 1,
    ImGuiDir_Up = 2,
    ImGuiDir_Down = 3,
    ImGuiDir_COUNT
};


enum ImGuiSortDirection_
{
    ImGuiSortDirection_None = 0,
    ImGuiSortDirection_Ascending = 1,
    ImGuiSortDirection_Descending = 2
};




enum ImGuiKey : int
{

    ImGuiKey_None = 0,
    ImGuiKey_Tab = 512,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,
    ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,
    ImGuiKey_Menu,
    ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,
    ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,
    ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,
    ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,
    ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,
    ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,
    ImGuiKey_Apostrophe,
    ImGuiKey_Comma,
    ImGuiKey_Minus,
    ImGuiKey_Period,
    ImGuiKey_Slash,
    ImGuiKey_Semicolon,
    ImGuiKey_Equal,
    ImGuiKey_LeftBracket,
    ImGuiKey_Backslash,
    ImGuiKey_RightBracket,
    ImGuiKey_GraveAccent,
    ImGuiKey_CapsLock,
    ImGuiKey_ScrollLock,
    ImGuiKey_NumLock,
    ImGuiKey_PrintScreen,
    ImGuiKey_Pause,
    ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,
    ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,
    ImGuiKey_KeypadDecimal,
    ImGuiKey_KeypadDivide,
    ImGuiKey_KeypadMultiply,
    ImGuiKey_KeypadSubtract,
    ImGuiKey_KeypadAdd,
    ImGuiKey_KeypadEnter,
    ImGuiKey_KeypadEqual,



    ImGuiKey_GamepadStart,
    ImGuiKey_GamepadBack,
    ImGuiKey_GamepadFaceLeft,
    ImGuiKey_GamepadFaceRight,
    ImGuiKey_GamepadFaceUp,
    ImGuiKey_GamepadFaceDown,
    ImGuiKey_GamepadDpadLeft,
    ImGuiKey_GamepadDpadRight,
    ImGuiKey_GamepadDpadUp,
    ImGuiKey_GamepadDpadDown,
    ImGuiKey_GamepadL1,
    ImGuiKey_GamepadR1,
    ImGuiKey_GamepadL2,
    ImGuiKey_GamepadR2,
    ImGuiKey_GamepadL3,
    ImGuiKey_GamepadR3,
    ImGuiKey_GamepadLStickLeft,
    ImGuiKey_GamepadLStickRight,
    ImGuiKey_GamepadLStickUp,
    ImGuiKey_GamepadLStickDown,
    ImGuiKey_GamepadRStickLeft,
    ImGuiKey_GamepadRStickRight,
    ImGuiKey_GamepadRStickUp,
    ImGuiKey_GamepadRStickDown,



    ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,


    ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,
    ImGuiKey_COUNT,
# 1450 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    ImGuiMod_None = 0,
    ImGuiMod_Ctrl = 1 << 12,
    ImGuiMod_Shift = 1 << 13,
    ImGuiMod_Alt = 1 << 14,
    ImGuiMod_Super = 1 << 15,
    ImGuiMod_Mask_ = 0xF000,



    ImGuiMod_Shortcut = ImGuiMod_Ctrl,




    ImGuiKey_NamedKey_BEGIN = 512,
    ImGuiKey_NamedKey_END = ImGuiKey_COUNT,
    ImGuiKey_NamedKey_COUNT = ImGuiKey_NamedKey_END - ImGuiKey_NamedKey_BEGIN,




    ImGuiKey_KeysData_SIZE = ImGuiKey_COUNT,
    ImGuiKey_KeysData_OFFSET = 0,



    ImGuiKey_ModCtrl = ImGuiMod_Ctrl, ImGuiKey_ModShift = ImGuiMod_Shift, ImGuiKey_ModAlt = ImGuiMod_Alt, ImGuiKey_ModSuper = ImGuiMod_Super,
    ImGuiKey_KeyPadEnter = ImGuiKey_KeypadEnter,

};





enum ImGuiNavInput
{
    ImGuiNavInput_Activate, ImGuiNavInput_Cancel, ImGuiNavInput_Input, ImGuiNavInput_Menu, ImGuiNavInput_DpadLeft, ImGuiNavInput_DpadRight, ImGuiNavInput_DpadUp, ImGuiNavInput_DpadDown,
    ImGuiNavInput_LStickLeft, ImGuiNavInput_LStickRight, ImGuiNavInput_LStickUp, ImGuiNavInput_LStickDown, ImGuiNavInput_FocusPrev, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakSlow, ImGuiNavInput_TweakFast,
    ImGuiNavInput_COUNT,
};



enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None = 0,
    ImGuiConfigFlags_NavEnableKeyboard = 1 << 0,
    ImGuiConfigFlags_NavEnableGamepad = 1 << 1,
    ImGuiConfigFlags_NavEnableSetMousePos = 1 << 2,
    ImGuiConfigFlags_NavNoCaptureKeyboard = 1 << 3,
    ImGuiConfigFlags_NoMouse = 1 << 4,
    ImGuiConfigFlags_NoMouseCursorChange = 1 << 5,


    ImGuiConfigFlags_IsSRGB = 1 << 20,
    ImGuiConfigFlags_IsTouchScreen = 1 << 21,
};


enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None = 0,
    ImGuiBackendFlags_HasGamepad = 1 << 0,
    ImGuiBackendFlags_HasMouseCursors = 1 << 1,
    ImGuiBackendFlags_HasSetMousePos = 1 << 2,
    ImGuiBackendFlags_RendererHasVtxOffset = 1 << 3,
};


enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,
    ImGuiCol_ChildBg,
    ImGuiCol_PopupBg,
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_Tab,
    ImGuiCol_TabHovered,
    ImGuiCol_TabActive,
    ImGuiCol_TabUnfocused,
    ImGuiCol_TabUnfocusedActive,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TableHeaderBg,
    ImGuiCol_TableBorderStrong,
    ImGuiCol_TableBorderLight,
    ImGuiCol_TableRowBg,
    ImGuiCol_TableRowBgAlt,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavHighlight,
    ImGuiCol_NavWindowingHighlight,
    ImGuiCol_NavWindowingDimBg,
    ImGuiCol_ModalWindowDimBg,
    ImGuiCol_COUNT
};
# 1585 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
enum ImGuiStyleVar_
{

    ImGuiStyleVar_Alpha,
    ImGuiStyleVar_DisabledAlpha,
    ImGuiStyleVar_WindowPadding,
    ImGuiStyleVar_WindowRounding,
    ImGuiStyleVar_WindowBorderSize,
    ImGuiStyleVar_WindowMinSize,
    ImGuiStyleVar_WindowTitleAlign,
    ImGuiStyleVar_ChildRounding,
    ImGuiStyleVar_ChildBorderSize,
    ImGuiStyleVar_PopupRounding,
    ImGuiStyleVar_PopupBorderSize,
    ImGuiStyleVar_FramePadding,
    ImGuiStyleVar_FrameRounding,
    ImGuiStyleVar_FrameBorderSize,
    ImGuiStyleVar_ItemSpacing,
    ImGuiStyleVar_ItemInnerSpacing,
    ImGuiStyleVar_IndentSpacing,
    ImGuiStyleVar_CellPadding,
    ImGuiStyleVar_ScrollbarSize,
    ImGuiStyleVar_ScrollbarRounding,
    ImGuiStyleVar_GrabMinSize,
    ImGuiStyleVar_GrabRounding,
    ImGuiStyleVar_TabRounding,
    ImGuiStyleVar_ButtonTextAlign,
    ImGuiStyleVar_SelectableTextAlign,
    ImGuiStyleVar_COUNT
};


enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None = 0,
    ImGuiButtonFlags_MouseButtonLeft = 1 << 0,
    ImGuiButtonFlags_MouseButtonRight = 1 << 1,
    ImGuiButtonFlags_MouseButtonMiddle = 1 << 2,


    ImGuiButtonFlags_MouseButtonMask_ = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle,
    ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft,
};


enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None = 0,
    ImGuiColorEditFlags_NoAlpha = 1 << 1,
    ImGuiColorEditFlags_NoPicker = 1 << 2,
    ImGuiColorEditFlags_NoOptions = 1 << 3,
    ImGuiColorEditFlags_NoSmallPreview = 1 << 4,
    ImGuiColorEditFlags_NoInputs = 1 << 5,
    ImGuiColorEditFlags_NoTooltip = 1 << 6,
    ImGuiColorEditFlags_NoLabel = 1 << 7,
    ImGuiColorEditFlags_NoSidePreview = 1 << 8,
    ImGuiColorEditFlags_NoDragDrop = 1 << 9,
    ImGuiColorEditFlags_NoBorder = 1 << 10,


    ImGuiColorEditFlags_AlphaBar = 1 << 16,
    ImGuiColorEditFlags_AlphaPreview = 1 << 17,
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,
    ImGuiColorEditFlags_HDR = 1 << 19,
    ImGuiColorEditFlags_DisplayRGB = 1 << 20,
    ImGuiColorEditFlags_DisplayHSV = 1 << 21,
    ImGuiColorEditFlags_DisplayHex = 1 << 22,
    ImGuiColorEditFlags_Uint8 = 1 << 23,
    ImGuiColorEditFlags_Float = 1 << 24,
    ImGuiColorEditFlags_PickerHueBar = 1 << 25,
    ImGuiColorEditFlags_PickerHueWheel = 1 << 26,
    ImGuiColorEditFlags_InputRGB = 1 << 27,
    ImGuiColorEditFlags_InputHSV = 1 << 28,



    ImGuiColorEditFlags_DefaultOptions_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,


    ImGuiColorEditFlags_DisplayMask_ = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,
    ImGuiColorEditFlags_DataTypeMask_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags_PickerMask_ = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags_InputMask_ = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV,



};




enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None = 0,
    ImGuiSliderFlags_AlwaysClamp = 1 << 4,
    ImGuiSliderFlags_Logarithmic = 1 << 5,
    ImGuiSliderFlags_NoRoundToFormat = 1 << 6,
    ImGuiSliderFlags_NoInput = 1 << 7,
    ImGuiSliderFlags_InvalidMask_ = 0x7000000F,



    ImGuiSliderFlags_ClampOnInput = ImGuiSliderFlags_AlwaysClamp,

};



enum ImGuiMouseButton_
{
    ImGuiMouseButton_Left = 0,
    ImGuiMouseButton_Right = 1,
    ImGuiMouseButton_Middle = 2,
    ImGuiMouseButton_COUNT = 5
};



enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,
    ImGuiMouseCursor_ResizeAll,
    ImGuiMouseCursor_ResizeNS,
    ImGuiMouseCursor_ResizeEW,
    ImGuiMouseCursor_ResizeNESW,
    ImGuiMouseCursor_ResizeNWSE,
    ImGuiMouseCursor_Hand,
    ImGuiMouseCursor_NotAllowed,
    ImGuiMouseCursor_COUNT
};




enum ImGuiCond_
{
    ImGuiCond_None = 0,
    ImGuiCond_Always = 1 << 0,
    ImGuiCond_Once = 1 << 1,
    ImGuiCond_FirstUseEver = 1 << 2,
    ImGuiCond_Appearing = 1 << 3,
};
# 1740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImNewWrapper {};
inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
inline void operator delete(void*, ImNewWrapper, void*) {}




template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }
# 1760 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"

template<typename T>
struct ImVector
{
    int Size;
    int Capacity;
    T* Data;


    typedef T value_type;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;


    inline ImVector() { Size = Capacity = 0; Data = 
# 1774 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                         __null
# 1774 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                             ; }
    inline ImVector(const ImVector<T>& src) { Size = Capacity = 0; Data = 
# 1775 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                         __null
# 1775 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                             ; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src) { clear(); resize(src.Size); if (src.Data) memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
    inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

    inline void clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = 
# 1779 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                    __null
# 1779 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                        ; } }
    inline void clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }
    inline void clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }

    inline bool empty() const { return Size == 0; }
    inline int size() const { return Size; }
    inline int size_in_bytes() const { return Size * (int)sizeof(T); }
    inline int max_size() const { return 0x7FFFFFFF / (int)sizeof(T); }
    inline int capacity() const { return Capacity; }
    inline T& operator[](int i) { 
# 1788 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1788 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             i >= 0 && i < Size
# 1788 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1788 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "i >= 0 && i < Size"
# 1788 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1788, __extension__ __PRETTY_FUNCTION__))
# 1788 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                          ; return Data[i]; }
    inline const T& operator[](int i) const { 
# 1789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             i >= 0 && i < Size
# 1789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "i >= 0 && i < Size"
# 1789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1789, __extension__ __PRETTY_FUNCTION__))
# 1789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                          ; return Data[i]; }

    inline T* begin() { return Data; }
    inline const T* begin() const { return Data; }
    inline T* end() { return Data + Size; }
    inline const T* end() const { return Data + Size; }
    inline T& front() { 
# 1795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             Size > 0
# 1795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "Size > 0"
# 1795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1795, __extension__ __PRETTY_FUNCTION__))
# 1795 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                ; return Data[0]; }
    inline const T& front() const { 
# 1796 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1796 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             Size > 0
# 1796 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1796 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "Size > 0"
# 1796 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1796, __extension__ __PRETTY_FUNCTION__))
# 1796 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                ; return Data[0]; }
    inline T& back() { 
# 1797 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1797 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             Size > 0
# 1797 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1797 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "Size > 0"
# 1797 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1797, __extension__ __PRETTY_FUNCTION__))
# 1797 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                ; return Data[Size - 1]; }
    inline const T& back() const { 
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             Size > 0
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "Size > 0"
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1798, __extension__ __PRETTY_FUNCTION__))
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                ; return Data[Size - 1]; }
    inline void swap(ImVector<T>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void shrink(int new_size) { 
# 1804 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1804 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             new_size <= Size
# 1804 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1804 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "new_size <= Size"
# 1804 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1804, __extension__ __PRETTY_FUNCTION__))
# 1804 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                        ; Size = new_size; }
    inline void reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }
    inline void reserve_discard(int new_capacity) { if (new_capacity <= Capacity) return; if (Data) ImGui::MemFree(Data); Data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }


    inline void push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void pop_back() { 
# 1810 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1810 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             Size > 0
# 1810 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1810 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "Size > 0"
# 1810 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1810, __extension__ __PRETTY_FUNCTION__))
# 1810 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                ; Size--; }
    inline void push_front(const T& v) { if (Size == 0) push_back(v); else insert(Data, v); }
    inline T* erase(const T* it) { 
# 1812 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1812 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             it >= Data && it < Data + Size
# 1812 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1812 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "it >= Data && it < Data + Size"
# 1812 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1812, __extension__ __PRETTY_FUNCTION__))
# 1812 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                      ; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
    inline T* erase(const T* it, const T* it_last){ 
# 1813 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1813 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size
# 1813 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1813 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size"
# 1813 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1813, __extension__ __PRETTY_FUNCTION__))
# 1813 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                 ; const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
    inline T* erase_unsorted(const T* it) { 
# 1814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             it >= Data && it < Data + Size
# 1814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "it >= Data && it < Data + Size"
# 1814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1814, __extension__ __PRETTY_FUNCTION__))
# 1814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                      ; const ptrdiff_t off = it - Data; if (it < Data + Size - 1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
    inline T* insert(const T* it, const T& v) { 
# 1815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             it >= Data && it <= Data + Size
# 1815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "it >= Data && it <= Data + Size"
# 1815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1815, __extension__ __PRETTY_FUNCTION__))
# 1815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                       ; const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool contains(const T& v) const { const T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline T* find(const T& v) { T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline const T* find(const T& v) const { const T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline bool find_erase(const T& v) { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }
    inline bool find_erase_unsorted(const T& v) { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }
    inline int index_from_ptr(const T* it) const { 
# 1821 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             (static_cast <bool> (
# 1821 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             it >= Data && it < Data + Size
# 1821 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             ) ? void (0) : __assert_fail (
# 1821 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                             "it >= Data && it < Data + Size"
# 1821 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 1821, __extension__ __PRETTY_FUNCTION__))
# 1821 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                      ; const ptrdiff_t off = it - Data; return (int)off; }
};

# 1833 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiStyle
{
    float Alpha;
    float DisabledAlpha;
    ImVec2 WindowPadding;
    float WindowRounding;
    float WindowBorderSize;
    ImVec2 WindowMinSize;
    ImVec2 WindowTitleAlign;
    ImGuiDir WindowMenuButtonPosition;
    float ChildRounding;
    float ChildBorderSize;
    float PopupRounding;
    float PopupBorderSize;
    ImVec2 FramePadding;
    float FrameRounding;
    float FrameBorderSize;
    ImVec2 ItemSpacing;
    ImVec2 ItemInnerSpacing;
    ImVec2 CellPadding;
    ImVec2 TouchExtraPadding;
    float IndentSpacing;
    float ColumnsMinSpacing;
    float ScrollbarSize;
    float ScrollbarRounding;
    float GrabMinSize;
    float GrabRounding;
    float LogSliderDeadzone;
    float TabRounding;
    float TabBorderSize;
    float TabMinWidthForCloseButton;
    ImGuiDir ColorButtonPosition;
    ImVec2 ButtonTextAlign;
    ImVec2 SelectableTextAlign;
    ImVec2 DisplayWindowPadding;
    ImVec2 DisplaySafeAreaPadding;
    float MouseCursorScale;
    bool AntiAliasedLines;
    bool AntiAliasedLinesUseTex;
    bool AntiAliasedFill;
    float CurveTessellationTol;
    float CircleTessellationMaxError;
    ImVec4 Colors[ImGuiCol_COUNT];

    ImGuiStyle();
    void ScaleAllSizes(float scale_factor);
};
# 1890 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiKeyData
{
    bool Down;
    float DownDuration;
    float DownDurationPrev;
    float AnalogValue;
};

struct ImGuiIO
{




    ImGuiConfigFlags ConfigFlags;
    ImGuiBackendFlags BackendFlags;
    ImVec2 DisplaySize;
    float DeltaTime;
    float IniSavingRate;
    const char* IniFilename;
    const char* LogFilename;
    float MouseDoubleClickTime;
    float MouseDoubleClickMaxDist;
    float MouseDragThreshold;
    float KeyRepeatDelay;
    float KeyRepeatRate;
    float HoverDelayNormal;
    float HoverDelayShort;
    void* UserData;

    ImFontAtlas*Fonts;
    float FontGlobalScale;
    bool FontAllowUserScaling;
    ImFont* FontDefault;
    ImVec2 DisplayFramebufferScale;


    bool MouseDrawCursor;
    bool ConfigMacOSXBehaviors;
    bool ConfigInputTrickleEventQueue;
    bool ConfigInputTextCursorBlink;
    bool ConfigInputTextEnterKeepActive;
    bool ConfigDragClickToInputText;
    bool ConfigWindowsResizeFromEdges;
    bool ConfigWindowsMoveFromTitleBarOnly;
    float ConfigMemoryCompactTimer;







    const char* BackendPlatformName;
    const char* BackendRendererName;
    void* BackendPlatformUserData;
    void* BackendRendererUserData;
    void* BackendLanguageUserData;



    const char* (*GetClipboardTextFn)(void* user_data);
    void (*SetClipboardTextFn)(void* user_data, const char* text);
    void* ClipboardUserData;



    void (*SetPlatformImeDataFn)(ImGuiViewport* viewport, ImGuiPlatformImeData* data);

    void* ImeWindowHandle;
# 1969 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    void AddKeyEvent(ImGuiKey key, bool down);
    void AddKeyAnalogEvent(ImGuiKey key, bool down, float v);
    void AddMousePosEvent(float x, float y);
    void AddMouseButtonEvent(int button, bool down);
    void AddMouseWheelEvent(float wh_x, float wh_y);
    void AddFocusEvent(bool focused);
    void AddInputCharacter(unsigned int c);
    void AddInputCharacterUTF16(ImWchar16 c);
    void AddInputCharactersUTF8(const char* str);

    void SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index = -1);
    void SetAppAcceptingEvents(bool accepting_events);
    void ClearInputCharacters();
    void ClearInputKeys();







    bool WantCaptureMouse;
    bool WantCaptureKeyboard;
    bool WantTextInput;
    bool WantSetMousePos;
    bool WantSaveIniSettings;
    bool NavActive;
    bool NavVisible;
    float Framerate;
    int MetricsRenderVertices;
    int MetricsRenderIndices;
    int MetricsRenderWindows;
    int MetricsActiveWindows;
    int MetricsActiveAllocations;
    ImVec2 MouseDelta;





    int KeyMap[ImGuiKey_COUNT];
    bool KeysDown[ImGuiKey_COUNT];
    float NavInputs[ImGuiNavInput_COUNT];
# 2021 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    ImVec2 MousePos;
    bool MouseDown[5];
    float MouseWheel;
    float MouseWheelH;
    bool KeyCtrl;
    bool KeyShift;
    bool KeyAlt;
    bool KeySuper;


    ImGuiKeyChord KeyMods;
    ImGuiKeyData KeysData[ImGuiKey_KeysData_SIZE];
    bool WantCaptureMouseUnlessPopupClose;
    ImVec2 MousePosPrev;
    ImVec2 MouseClickedPos[5];
    double MouseClickedTime[5];
    bool MouseClicked[5];
    bool MouseDoubleClicked[5];
    ImU16 MouseClickedCount[5];
    ImU16 MouseClickedLastCount[5];
    bool MouseReleased[5];
    bool MouseDownOwned[5];
    bool MouseDownOwnedUnlessPopupClose[5];
    float MouseDownDuration[5];
    float MouseDownDurationPrev[5];
    float MouseDragMaxDistanceSqr[5];
    float PenPressure;
    bool AppFocusLost;
    bool AppAcceptingEvents;
    ImS8 BackendUsingLegacyKeyArrays;
    bool BackendUsingLegacyNavInputArray;
    ImWchar16 InputQueueSurrogate;
    ImVector<ImWchar> InputQueueCharacters;

    ImGuiIO();
};
# 2071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiInputTextCallbackData
{
    ImGuiInputTextFlags EventFlag;
    ImGuiInputTextFlags Flags;
    void* UserData;




    ImWchar EventChar;
    ImGuiKey EventKey;
    char* Buf;
    int BufTextLen;
    int BufSize;
    bool BufDirty;
    int CursorPos;
    int SelectionStart;
    int SelectionEnd;



    ImGuiInputTextCallbackData();
    void DeleteChars(int pos, int bytes_count);
    void InsertChars(int pos, const char* text, const char* text_end = 
# 2094 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                     __null
# 2094 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                         );
    void SelectAll() { SelectionStart = 0; SelectionEnd = BufTextLen; }
    void ClearSelection() { SelectionStart = SelectionEnd = BufTextLen; }
    bool HasSelection() const { return SelectionStart != SelectionEnd; }
};



struct ImGuiSizeCallbackData
{
    void* UserData;
    ImVec2 Pos;
    ImVec2 CurrentSize;
    ImVec2 DesiredSize;
};


struct ImGuiPayload
{

    void* Data;
    int DataSize;


    ImGuiID SourceId;
    ImGuiID SourceParentId;
    int DataFrameCount;
    char DataType[32 + 1];
    bool Preview;
    bool Delivery;

    ImGuiPayload() { Clear(); }
    void Clear() { SourceId = SourceParentId = 0; Data = 
# 2126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                           __null
# 2126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                               ; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const { return Preview; }
    bool IsDelivery() const { return Delivery; }
};


struct ImGuiTableColumnSortSpecs
{
    ImGuiID ColumnUserID;
    ImS16 ColumnIndex;
    ImS16 SortOrder;
    ImGuiSortDirection SortDirection : 8;

    ImGuiTableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }
};





struct ImGuiTableSortSpecs
{
    const ImGuiTableColumnSortSpecs* Specs;
    int SpecsCount;
    bool SpecsDirty;

    ImGuiTableSortSpecs() { memset(this, 0, sizeof(*this)); }
};
# 2170 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};


struct ImGuiTextFilter
{
    ImGuiTextFilter(const char* default_filter = "");
    bool Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);
    bool PassFilter(const char* text, const char* text_end = 
# 2182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                           __null
# 2182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                               ) const;
    void Build();
    void Clear() { InputBuf[0] = 0; Build(); }
    bool IsActive() const { return !Filters.empty(); }


    struct ImGuiTextRange
    {
        const char* b;
        const char* e;

        ImGuiTextRange() { b = e = 
# 2193 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                 __null
# 2193 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                     ; }
        ImGuiTextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        bool empty() const { return b == e; }
        void split(char separator, ImVector<ImGuiTextRange>* out) const;
    };
    char InputBuf[256];
    ImVector<ImGuiTextRange>Filters;
    int CountGrep;
};



struct ImGuiTextBuffer
{
    ImVector<char> Buf;
    static char EmptyString[1];

    ImGuiTextBuffer() { }
    inline char operator[](int i) const { 
# 2211 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                 (static_cast <bool> (
# 2211 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                 Buf.Data != 
# 2211 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                 __null) ? void (0) : __assert_fail (
# 2211 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                 "Buf.Data != __null"
# 2211 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                 , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 2211, __extension__ __PRETTY_FUNCTION__))
# 2211 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                            ; return Buf.Data[i]; }
    const char* begin() const { return Buf.Data ? &Buf.front() : EmptyString; }
    const char* end() const { return Buf.Data ? &Buf.back() : EmptyString; }
    int size() const { return Buf.Size ? Buf.Size - 1 : 0; }
    bool empty() const { return Buf.Size <= 1; }
    void clear() { Buf.clear(); }
    void reserve(int capacity) { Buf.reserve(capacity); }
    const char* c_str() const { return Buf.Data ? Buf.Data : EmptyString; }
    void append(const char* str, const char* str_end = 
# 2219 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                     __null
# 2219 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                         );
    void appendf(const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void appendfv(const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
};
# 2232 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiStorage
{

    struct ImGuiStoragePair
    {
        ImGuiID key;
        union { int val_i; float val_f; void* val_p; };
        ImGuiStoragePair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }
        ImGuiStoragePair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
        ImGuiStoragePair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
    };

    ImVector<ImGuiStoragePair> Data;




    void Clear() { Data.clear(); }
    int GetInt(ImGuiID key, int default_val = 0) const;
    void SetInt(ImGuiID key, int val);
    bool GetBool(ImGuiID key, bool default_val = false) const;
    void SetBool(ImGuiID key, bool val);
    float GetFloat(ImGuiID key, float default_val = 0.0f) const;
    void SetFloat(ImGuiID key, float val);
    void* GetVoidPtr(ImGuiID key) const;
    void SetVoidPtr(ImGuiID key, void* val);





    int* GetIntRef(ImGuiID key, int default_val = 0);
    bool* GetBoolRef(ImGuiID key, bool default_val = false);
    float* GetFloatRef(ImGuiID key, float default_val = 0.0f);
    void** GetVoidPtrRef(ImGuiID key, void* default_val = 
# 2266 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                      __null
# 2266 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                          );


    void SetAllInt(int val);


    void BuildSortByKey();
};
# 2295 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiListClipper
{
    int DisplayStart;
    int DisplayEnd;
    int ItemsCount;
    float ItemsHeight;
    float StartPosY;
    void* TempData;



    ImGuiListClipper();
    ~ImGuiListClipper();
    void Begin(int items_count, float items_height = -1.0f);
    void End();
    bool Step();


    void ForceDisplayRangeByIndices(int item_min, int item_max);


    inline ImGuiListClipper(int items_count, float items_height = -1.0f) { memset(this, 0, sizeof(*this)); ItemsCount = -1; Begin(items_count, items_height); }

};
# 2346 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImColor
{
    ImVec4 Value;

    constexpr ImColor() { }
    constexpr ImColor(float r, float g, float b, float a = 1.0f) : Value(r, g, b, a) { }
    constexpr ImColor(const ImVec4& col) : Value(col) {}
    ImColor(int r, int g, int b, int a = 255) { float sc = 1.0f / 255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
    ImColor(ImU32 rgba) { float sc = 1.0f / 255.0f; Value.x = (float)((rgba >> 0) & 0xFF) * sc; Value.y = (float)((rgba >> 8) & 0xFF) * sc; Value.z = (float)((rgba >> 16) & 0xFF) * sc; Value.w = (float)((rgba >> 24) & 0xFF) * sc; }
    inline operator ImU32() const { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const { return Value; }


    inline void SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f) { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }
};
# 2381 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);
# 2395 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImDrawCmd
{
    ImVec4 ClipRect;
    ImTextureID TextureId;
    unsigned int VtxOffset;
    unsigned int IdxOffset;
    unsigned int ElemCount;
    ImDrawCallback UserCallback;
    void* UserCallbackData;

    ImDrawCmd() { memset(this, 0, sizeof(*this)); }


    inline ImTextureID GetTexID() const { return TextureId; }
};



struct ImDrawVert
{
    ImVec2 pos;
    ImVec2 uv;
    ImU32 col;
};
# 2428 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImDrawCmdHeader
{
    ImVec4 ClipRect;
    ImTextureID TextureId;
    unsigned int VtxOffset;
};


struct ImDrawChannel
{
    ImVector<ImDrawCmd> _CmdBuffer;
    ImVector<ImDrawIdx> _IdxBuffer;
};




struct ImDrawListSplitter
{
    int _Current;
    int _Count;
    ImVector<ImDrawChannel> _Channels;

    inline ImDrawListSplitter() { memset(this, 0, sizeof(*this)); }
    inline ~ImDrawListSplitter() { ClearFreeMemory(); }
    inline void Clear() { _Current = 0; _Count = 1; }
    void ClearFreeMemory();
    void Split(ImDrawList* draw_list, int count);
    void Merge(ImDrawList* draw_list);
    void SetCurrentChannel(ImDrawList* draw_list, int channel_idx);
};



enum ImDrawFlags_
{
    ImDrawFlags_None = 0,
    ImDrawFlags_Closed = 1 << 0,
    ImDrawFlags_RoundCornersTopLeft = 1 << 4,
    ImDrawFlags_RoundCornersTopRight = 1 << 5,
    ImDrawFlags_RoundCornersBottomLeft = 1 << 6,
    ImDrawFlags_RoundCornersBottomRight = 1 << 7,
    ImDrawFlags_RoundCornersNone = 1 << 8,
    ImDrawFlags_RoundCornersTop = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,
    ImDrawFlags_RoundCornersBottom = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
    ImDrawFlags_RoundCornersLeft = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,
    ImDrawFlags_RoundCornersRight = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,
    ImDrawFlags_RoundCornersAll = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
    ImDrawFlags_RoundCornersDefault_ = ImDrawFlags_RoundCornersAll,
    ImDrawFlags_RoundCornersMask_ = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone,
};



enum ImDrawListFlags_
{
    ImDrawListFlags_None = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,
    ImDrawListFlags_AntiAliasedLinesUseTex = 1 << 1,
    ImDrawListFlags_AntiAliasedFill = 1 << 2,
    ImDrawListFlags_AllowVtxOffset = 1 << 3,
};
# 2500 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImDrawList
{

    ImVector<ImDrawCmd> CmdBuffer;
    ImVector<ImDrawIdx> IdxBuffer;
    ImVector<ImDrawVert> VtxBuffer;
    ImDrawListFlags Flags;


    unsigned int _VtxCurrentIdx;
    ImDrawListSharedData* _Data;
    const char* _OwnerName;
    ImDrawVert* _VtxWritePtr;
    ImDrawIdx* _IdxWritePtr;
    ImVector<ImVec4> _ClipRectStack;
    ImVector<ImTextureID> _TextureIdStack;
    ImVector<ImVec2> _Path;
    ImDrawCmdHeader _CmdHeader;
    ImDrawListSplitter _Splitter;
    float _FringeScale;


    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }

    ~ImDrawList() { _ClearFreeMemory(); }
    void PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect = false);
    void PushClipRectFullScreen();
    void PopClipRect();
    void PushTextureID(ImTextureID texture_id);
    void PopTextureID();
    inline ImVec2 GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2 GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
# 2540 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    void AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness = 1.0f);
    void AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0, float thickness = 1.0f);
    void AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0);
    void AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    void AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness = 1.0f);
    void AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col);
    void AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness = 1.0f);
    void AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col);
    void AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments = 0, float thickness = 1.0f);
    void AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments = 0);
    void AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
    void AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
    void AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = 
# 2552 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                        __null
# 2552 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                            );
    void AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = 
# 2553 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                             __null
# 2553 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                 , float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = 
# 2553 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                               __null
# 2553 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                                   );
    void AddPolyline(const ImVec2* points, int num_points, ImU32 col, ImDrawFlags flags, float thickness);
    void AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col);
    void AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0);
    void AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);





    void AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2(0, 0), const ImVec2& uv_max = ImVec2(1, 1), ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    void AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2(0, 0), const ImVec2& uv2 = ImVec2(1, 0), const ImVec2& uv3 = ImVec2(1, 1), const ImVec2& uv4 = ImVec2(0, 1), ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    void AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags = 0);



    inline void PathClear() { _Path.Size = 0; }
    inline void PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }
    inline void PathLineToMergeDuplicate(const ImVec2& pos) { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }
    inline void PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
    inline void PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
    void PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 0);
    void PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12);
    void PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);
    void PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    void PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawFlags flags = 0);


    void AddCallback(ImDrawCallback callback, void* callback_data);
    void AddDrawCmd();
    ImDrawList* CloneOutput() const;







    inline void ChannelsSplit(int count) { _Splitter.Split(this, count); }
    inline void ChannelsMerge() { _Splitter.Merge(this); }
    inline void ChannelsSetCurrent(int n) { _Splitter.SetCurrentChannel(this, n); }




    void PrimReserve(int idx_count, int vtx_count);
    void PrimUnreserve(int idx_count, int vtx_count);
    void PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);
    void PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    void PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline void PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline void PrimWriteIdx(ImDrawIdx idx) { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline void PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }


    inline void AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); }
    inline void PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); }



    void _ResetForNewFrame();
    void _ClearFreeMemory();
    void _PopUnusedDrawCmd();
    void _TryMergeDrawCmds();
    void _OnChangedClipRect();
    void _OnChangedTextureID();
    void _OnChangedVtxOffset();
    int _CalcCircleAutoSegmentCount(float radius) const;
    void _PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step);
    void _PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments);
};




struct ImDrawData
{
    bool Valid;
    int CmdListsCount;
    int TotalIdxCount;
    int TotalVtxCount;
    ImDrawList** CmdLists;
    ImVec2 DisplayPos;
    ImVec2 DisplaySize;
    ImVec2 FramebufferScale;


    ImDrawData() { Clear(); }
    void Clear() { memset(this, 0, sizeof(*this)); }
    void DeIndexAllBuffers();
    void ScaleClipRects(const ImVec2& fb_scale);
};





struct ImFontConfig
{
    void* FontData;
    int FontDataSize;
    bool FontDataOwnedByAtlas;
    int FontNo;
    float SizePixels;
    int OversampleH;
    int OversampleV;
    bool PixelSnapH;
    ImVec2 GlyphExtraSpacing;
    ImVec2 GlyphOffset;
    const ImWchar* GlyphRanges;
    float GlyphMinAdvanceX;
    float GlyphMaxAdvanceX;
    bool MergeMode;
    unsigned int FontBuilderFlags;
    float RasterizerMultiply;
    ImWchar EllipsisChar;


    char Name[40];
    ImFont* DstFont;

    ImFontConfig();
};



struct ImFontGlyph
{
    unsigned int Colored : 1;
    unsigned int Visible : 1;
    unsigned int Codepoint : 30;
    float AdvanceX;
    float X0, Y0, X1, Y1;
    float U0, V0, U1, V1;
};



struct ImFontGlyphRangesBuilder
{
    ImVector<ImU32> UsedChars;

    ImFontGlyphRangesBuilder() { Clear(); }
    inline void Clear() { int size_in_bytes = (0xFFFF + 1) / 8; UsedChars.resize(size_in_bytes / (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }
    inline bool GetBit(size_t n) const { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }
    inline void SetBit(size_t n) { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }
    inline void AddChar(ImWchar c) { SetBit(c); }
    void AddText(const char* text, const char* text_end = 
# 2700 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                    __null
# 2700 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                        );
    void AddRanges(const ImWchar* ranges);
    void BuildRanges(ImVector<ImWchar>* out_ranges);
};


struct ImFontAtlasCustomRect
{
    unsigned short Width, Height;
    unsigned short X, Y;
    unsigned int GlyphID;
    float GlyphAdvanceX;
    ImVec2 GlyphOffset;
    ImFont* Font;
    ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = 
# 2714 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                               __null
# 2714 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                   ; }
    bool IsPacked() const { return X != 0xFFFF; }
};


enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,
    ImFontAtlasFlags_NoMouseCursors = 1 << 1,
    ImFontAtlasFlags_NoBakedLines = 1 << 2,
};
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImFontAtlas
{
    ImFontAtlas();
    ~ImFontAtlas();
    ImFont* AddFont(const ImFontConfig* font_cfg);
    ImFont* AddFontDefault(const ImFontConfig* font_cfg = 
# 2749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                             __null
# 2749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                 );
    ImFont* AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = 
# 2750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                          __null
# 2750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                              , const ImWchar* glyph_ranges = 
# 2750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                              __null
# 2750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                  );
    ImFont* AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = 
# 2751 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                      __null
# 2751 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                          , const ImWchar* glyph_ranges = 
# 2751 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                          __null
# 2751 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                              );
    ImFont* AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = 
# 2752 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                            __null
# 2752 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                , const ImWchar* glyph_ranges = 
# 2752 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                                __null
# 2752 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                                    );
    ImFont* AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = 
# 2753 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                               __null
# 2753 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                   , const ImWchar* glyph_ranges = 
# 2753 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                                                   __null
# 2753 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                                                       );
    void ClearInputData();
    void ClearTexData();
    void ClearFonts();
    void Clear();






    bool Build();
    void GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = 
# 2765 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                          __null
# 2765 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                              );
    void GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = 
# 2766 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                          __null
# 2766 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                              );
    bool IsBuilt() const { return Fonts.Size > 0 && TexReady; }
    void SetTexID(ImTextureID id) { TexID = id; }
# 2777 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    const ImWchar* GetGlyphRangesDefault();
    const ImWchar* GetGlyphRangesGreek();
    const ImWchar* GetGlyphRangesKorean();
    const ImWchar* GetGlyphRangesJapanese();
    const ImWchar* GetGlyphRangesChineseFull();
    const ImWchar* GetGlyphRangesChineseSimplifiedCommon();
    const ImWchar* GetGlyphRangesCyrillic();
    const ImWchar* GetGlyphRangesThai();
    const ImWchar* GetGlyphRangesVietnamese();
# 2798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
    int AddCustomRectRegular(int width, int height);
    int AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0, 0));
    ImFontAtlasCustomRect* GetCustomRectByIndex(int index) { 
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                 (static_cast <bool> (
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                 index >= 0
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                 ) ? void (0) : __assert_fail (
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                 "index >= 0"
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                 , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h", 2800, __extension__ __PRETTY_FUNCTION__))
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                      ; return &CustomRects[index]; }


    void CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const;
    bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);





    ImFontAtlasFlags Flags;
    ImTextureID TexID;
    int TexDesiredWidth;
    int TexGlyphPadding;
    bool Locked;



    bool TexReady;
    bool TexPixelsUseColors;
    unsigned char* TexPixelsAlpha8;
    unsigned int* TexPixelsRGBA32;
    int TexWidth;
    int TexHeight;
    ImVec2 TexUvScale;
    ImVec2 TexUvWhitePixel;
    ImVector<ImFont*> Fonts;
    ImVector<ImFontAtlasCustomRect> CustomRects;
    ImVector<ImFontConfig> ConfigData;
    ImVec4 TexUvLines[(63) + 1];


    const ImFontBuilderIO* FontBuilderIO;
    unsigned int FontBuilderFlags;


    int PackIdMouseCursors;
    int PackIdLines;




};



struct ImFont
{

    ImVector<float> IndexAdvanceX;
    float FallbackAdvanceX;
    float FontSize;


    ImVector<ImWchar> IndexLookup;
    ImVector<ImFontGlyph> Glyphs;
    const ImFontGlyph* FallbackGlyph;


    ImFontAtlas* ContainerAtlas;
    const ImFontConfig* ConfigData;
    short ConfigDataCount;
    ImWchar FallbackChar;
    ImWchar EllipsisChar;
    ImWchar DotChar;
    bool DirtyLookupTables;
    float Scale;
    float Ascent, Descent;
    int MetricsTotalSurface;
    ImU8 Used4kPagesMap[(0xFFFF +1)/4096/8];


    ImFont();
    ~ImFont();
    const ImFontGlyph*FindGlyph(ImWchar c) const;
    const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    float GetCharAdvance(ImWchar c) const { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool IsLoaded() const { return ContainerAtlas != 
# 2877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                              __null
# 2877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                  ; }
    const char* GetDebugName() const { return ConfigData ? ConfigData->Name : "<unknown>"; }



    ImVec2 CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = 
# 2882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                           __null
# 2882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                               , const char** remaining = 
# 2882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h" 3 4
                                                                                                                                                                          __null
# 2882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
                                                                                                                                                                              ) const;
    const char* CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    void RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const;
    void RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;


    void BuildLookupTable();
    void ClearOutputData();
    void GrowIndex(int new_size);
    void AddGlyph(const ImFontConfig* src_cfg, ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    void AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true);
    void SetGlyphVisible(ImWchar c, bool visible);
    bool IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
};






enum ImGuiViewportFlags_
{
    ImGuiViewportFlags_None = 0,
    ImGuiViewportFlags_IsPlatformWindow = 1 << 0,
    ImGuiViewportFlags_IsPlatformMonitor = 1 << 1,
    ImGuiViewportFlags_OwnedByApp = 1 << 2,
};
# 2917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
struct ImGuiViewport
{
    ImGuiViewportFlags Flags;
    ImVec2 Pos;
    ImVec2 Size;
    ImVec2 WorkPos;
    ImVec2 WorkSize;


    void* PlatformHandleRaw;

    ImGuiViewport() { memset(this, 0, sizeof(*this)); }


    ImVec2 GetCenter() const { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }
    ImVec2 GetWorkCenter() const { return ImVec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f); }
};






struct ImGuiPlatformImeData
{
    bool WantVisible;
    ImVec2 InputPos;
    float InputLineHeight;

    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
};







namespace ImGui
{

    ImGuiKey GetKeyIndex(ImGuiKey key);



}


namespace ImGui
{

    bool ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1));

    static inline void CaptureKeyboardFromApp(bool want_capture_keyboard = true) { SetNextFrameWantCaptureKeyboard(want_capture_keyboard); }
    static inline void CaptureMouseFromApp(bool want_capture_mouse = true) { SetNextFrameWantCaptureMouse(want_capture_mouse); }

    void CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);

    static inline float GetWindowContentRegionWidth() { return GetWindowContentRegionMax().x - GetWindowContentRegionMin().x; }

    bool ListBoxHeader(const char* label, int items_count, int height_in_items = -1);
    static inline bool ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0, 0)) { return BeginListBox(label, size); }
    static inline void ListBoxFooter() { EndListBox(); }
# 3026 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
}


typedef ImDrawFlags ImDrawCornerFlags;
enum ImDrawCornerFlags_
{
    ImDrawCornerFlags_None = ImDrawFlags_RoundCornersNone,
    ImDrawCornerFlags_TopLeft = ImDrawFlags_RoundCornersTopLeft,
    ImDrawCornerFlags_TopRight = ImDrawFlags_RoundCornersTopRight,
    ImDrawCornerFlags_BotLeft = ImDrawFlags_RoundCornersBottomLeft,
    ImDrawCornerFlags_BotRight = ImDrawFlags_RoundCornersBottomRight,
    ImDrawCornerFlags_All = ImDrawFlags_RoundCornersAll,
    ImDrawCornerFlags_Top = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,
    ImDrawCornerFlags_Bot = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,
    ImDrawCornerFlags_Left = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,
    ImDrawCornerFlags_Right = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,
};



typedef ImGuiKeyChord ImGuiModFlags;
enum ImGuiModFlags_ { ImGuiModFlags_None = 0, ImGuiModFlags_Ctrl = ImGuiMod_Ctrl, ImGuiModFlags_Shift = ImGuiMod_Shift, ImGuiModFlags_Alt = ImGuiMod_Alt, ImGuiModFlags_Super = ImGuiMod_Super };
# 3066 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui.h"
#pragma GCC diagnostic pop
# 857 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 2





# 1 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 1
# 42 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
       
# 53 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4


# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/aarch64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;



extern char *tmpnam (char[20]) noexcept (true) ;




extern char *tmpnam_r (char __s[20]) noexcept (true) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);





# 1 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 2 3 4
# 80 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
typedef long double _Float128;
# 95 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 96 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf")

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) ;






extern char *ctermid (char *__s) noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4
}
# 54 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 2
# 1 "/usr/include/c++/11/stdlib.h" 1 3
# 36 "/usr/include/c++/11/stdlib.h" 3
# 1 "/usr/include/c++/11/cstdlib" 1 3
# 39 "/usr/include/c++/11/cstdlib" 3
       
# 40 "/usr/include/c++/11/cstdlib" 3

# 1 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 1 3
# 278 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 300 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 586 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 3
# 1 "/usr/include/aarch64-linux-gnu/c++/11/bits/os_defines.h" 1 3
# 587 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 2 3


# 1 "/usr/include/aarch64-linux-gnu/c++/11/bits/cpu_defines.h" 1 3
# 590 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 2 3
# 777 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 3
# 1 "/usr/include/c++/11/pstl/pstl_config.h" 1 3
# 778 "/usr/include/aarch64-linux-gnu/c++/11/bits/c++config.h" 2 3
# 42 "/usr/include/c++/11/cstdlib" 2 3
# 75 "/usr/include/c++/11/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/aarch64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 275 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/aarch64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/aarch64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/aarch64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 145 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/aarch64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/aarch64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/aarch64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 45 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;
# 58 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
  int __kind;




  int __spins;
  __pthread_list_t __list;
# 74 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  int __cur_writer;
  int __shared;
  unsigned long int __pad1;
  unsigned long int __pad2;
  unsigned int __flags;
};
# 90 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[8];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[8];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[64];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[48];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[8];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4


}
# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 617 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 727 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 769 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/11/cstdlib" 2 3

# 1 "/usr/include/c++/11/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/11/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/11/bits/std_abs.h" 3
# 46 "/usr/include/c++/11/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/11/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 107 "/usr/include/c++/11/bits/std_abs.h" 3

}
}
# 78 "/usr/include/c++/11/cstdlib" 2 3
# 121 "/usr/include/c++/11/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/11/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/11/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/11/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 55 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 2
# 1 "/usr/include/c++/11/math.h" 1 3
# 36 "/usr/include/c++/11/math.h" 3
# 1 "/usr/include/c++/11/cmath" 1 3
# 39 "/usr/include/c++/11/cmath" 3
       
# 40 "/usr/include/c++/11/cmath" 3


# 1 "/usr/include/c++/11/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 270 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 287 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 423 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 532 "/usr/include/c++/11/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/11/cmath" 2 3
# 1 "/usr/include/c++/11/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/11/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/11/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };


  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));


  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/usr/include/c++/11/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/aarch64-linux-gnu/bits/math-vector.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 484 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);




 extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


 extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);




 extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


 extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




 extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


 extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




 extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 198 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 220 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





 extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
 extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 252 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 485 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/aarch64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32sqrtf128 (_Float128 __x) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 728 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 768 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64sqrtf128 (_Float128 __x) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 798 "/usr/include/math.h" 2 3 4
# 817 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 818 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1054 "/usr/include/math.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/iscanonical.h" 1 3 4
# 1055 "/usr/include/math.h" 2 3 4
# 1066 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}





}
# 1097 "/usr/include/math.h" 3 4
extern "C++" {
# 1128 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1363 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};
# 1406 "/usr/include/math.h" 3 4
template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/11/cmath" 2 3
# 77 "/usr/include/c++/11/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/11/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/include/c++/11/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/include/c++/11/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1852 "/usr/include/c++/11/cmath" 3
  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }
# 1931 "/usr/include/c++/11/cmath" 3

}


# 1 "/usr/include/c++/11/bits/specfun.h" 1 3
# 33 "/usr/include/c++/11/bits/specfun.h" 3
#pragma GCC visibility push(default)
# 45 "/usr/include/c++/11/bits/specfun.h" 3
# 1 "/usr/include/c++/11/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/11/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/11/bits/functexcept.h" 1 3
# 40 "/usr/include/c++/11/bits/functexcept.h" 3
# 1 "/usr/include/c++/11/bits/exception_defines.h" 1 3
# 41 "/usr/include/c++/11/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/11/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/11/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/11/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/11/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/11/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 135 "/usr/include/c++/11/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 155 "/usr/include/c++/11/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 113) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 33);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 236 "/usr/include/c++/11/ext/numeric_traits.h" 3

}
# 64 "/usr/include/c++/11/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/11/bits/stl_pair.h" 1 3
# 59 "/usr/include/c++/11/bits/stl_pair.h" 3
# 1 "/usr/include/c++/11/bits/move.h" 1 3
# 38 "/usr/include/c++/11/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/usr/include/c++/11/type_traits" 1 3
# 32 "/usr/include/c++/11/type_traits" 3
       
# 33 "/usr/include/c++/11/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    class reference_wrapper;
# 64 "/usr/include/c++/11/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  using true_type = integral_constant<bool, true>;


  using false_type = integral_constant<bool, false>;



  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;






  template<bool __v>
    using bool_constant = integral_constant<bool, __v>;




  template<bool, typename, typename>
    struct conditional;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;




  template<typename... _Bn>
    struct conjunction
    : __and_<_Bn...>
    { };

  template<typename... _Bn>
    struct disjunction
    : __or_<_Bn...>
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };



  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };





  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 310 "/usr/include/c++/11/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 391 "/usr/include/c++/11/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 421 "/usr/include/c++/11/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };



  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 637 "/usr/include/c++/11/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 656 "/usr/include/c++/11/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };




  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };





  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };
# 842 "/usr/include/c++/11/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };



  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __bool_constant<__is_nothrow_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };



  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };



  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same(_Tp, _Up)>



    { };
# 1420 "/usr/include/c++/11/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1518 "/usr/include/c++/11/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1742 "/usr/include/c++/11/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1818 "/usr/include/c++/11/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;




  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1898 "/usr/include/c++/11/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1946 "/usr/include/c++/11/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };

  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2082 "/usr/include/c++/11/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2121 "/usr/include/c++/11/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;





  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };



  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };




  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;




  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2261 "/usr/include/c++/11/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;






  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;





  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2655 "/usr/include/c++/11/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };







  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 2882 "/usr/include/c++/11/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop






  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Result, typename _Ret, typename = void>
    struct __is_nt_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_nt_invocable_impl<_Result, _Ret,
      __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>,
     __is_nothrow_convertible<typename _Result::type, _Ret>>
    { };



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3093 "/usr/include/c++/11/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_array_v = is_array<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v =
    is_lvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v =
    is_rvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    is_member_object_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    is_member_function_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_enum_v = is_enum<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_union_v = is_union<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_class_v = is_class<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_reference_v = is_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_const_v = is_const<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_volatile_v = is_volatile<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivial_v = is_trivial<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v =
    is_trivially_copyable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <typename _Tp>
 
  inline constexpr bool is_pod_v = is_pod<_Tp>::value;
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;
#pragma GCC diagnostic pop
 template <typename _Tp>
  inline constexpr bool is_empty_v = is_empty<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_abstract_v = is_abstract<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_final_v = is_final<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v =
    is_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_default_constructible_v =
    is_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v =
    is_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_constructible_v =
    is_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v =
    is_trivially_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v =
    is_trivially_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v =
    is_trivially_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v =
    is_trivially_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v =
    is_trivially_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v =
    is_trivially_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v =
    is_trivially_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v =
    is_nothrow_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v =
    is_nothrow_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v =
    is_nothrow_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v =
    is_nothrow_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v =
    is_nothrow_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v =
    is_nothrow_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v =
    is_nothrow_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v =
    has_virtual_destructor<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t rank_v = rank<_Tp>::value;
template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;

template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);




template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;





  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;





  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };


  template<typename _Tp>
    inline constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
# 3597 "/usr/include/c++/11/type_traits" 3

}
# 58 "/usr/include/c++/11/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/11/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 121 "/usr/include/c++/11/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 142 "/usr/include/c++/11/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 186 "/usr/include/c++/11/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/include/c++/11/bits/stl_pair.h" 2 3
# 69 "/usr/include/c++/11/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/11/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/usr/include/c++/11/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/usr/include/c++/11/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/usr/include/c++/11/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;



  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/usr/include/c++/11/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/usr/include/c++/11/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 564 "/usr/include/c++/11/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/usr/include/c++/11/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/11/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
# 74 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 125 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 209 "/usr/include/c++/11/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/usr/include/c++/11/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/11/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/11/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/11/bits/concept_check.h" 3
# 65 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/11/debug/assertions.h" 1 3
# 66 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (__builtin_is_constant_evaluated() && !bool(__n >= 0)) __builtin_unreachable(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/usr/include/c++/11/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/11/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/11/bits/stl_iterator.h" 1 3
# 67 "/usr/include/c++/11/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/11/bits/ptr_traits.h" 1 3
# 42 "/usr/include/c++/11/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;

  template<typename _Ptr>
    struct __ptr_traits_elem_1
    { };

  template<template<typename, typename...> class _SomePointer, typename _Tp,
    typename... _Args>
    struct __ptr_traits_elem_1<_SomePointer<_Tp, _Args...>>
    {
      using element_type = _Tp;
      using pointer = _SomePointer<_Tp, _Args...>;

      static pointer
      pointer_to(__make_not_void<element_type>& __e)
      { return pointer::pointer_to(__e); }
    };

  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __ptr_traits_elem_1<_Ptr>
    { };

  template<typename _Ptr>
    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>
    {
      using element_type = typename _Ptr::element_type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_elem<_Ptr>
    {
    private:
      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 214 "/usr/include/c++/11/bits/ptr_traits.h" 3

}
# 68 "/usr/include/c++/11/bits/stl_iterator.h" 2 3
# 87 "/usr/include/c++/11/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 126 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;
# 145 "/usr/include/c++/11/bits/stl_iterator.h" 3
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;

      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
# 176 "/usr/include/c++/11/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator() : current() { }




      explicit constexpr
      reverse_iterator(iterator_type __x) : current(__x) { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>



 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.current) { }


      template<typename _Iter>




 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 {
   current = __x.current;
   return *this;
 }





      constexpr iterator_type
      base() const
      { return current; }
# 240 "/usr/include/c++/11/bits/stl_iterator.h" 3
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      constexpr pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
# 394 "/usr/include/c++/11/bits/stl_iterator.h" 3
    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 417 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }




  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() <= __y.base(); }
# 558 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 599 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 630 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 670 "/usr/include/c++/11/bits/stl_iterator.h" 3
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



     
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 717 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 733 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 773 "/usr/include/c++/11/bits/stl_iterator.h" 3
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



     
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 820 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 840 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {







      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;


    public:

      typedef _Container container_type;
# 872 "/usr/include/c++/11/bits/stl_iterator.h" 3
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 908 "/usr/include/c++/11/bits/stl_iterator.h" 3
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



     
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 964 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Container>
    inline insert_iterator<_Container>
    inserter(_Container& __x, typename _Container::iterator __i)
    { return insert_iterator<_Container>(__x, __i); }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 986 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
       
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1118 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


   
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1308 "/usr/include/c++/11/bits/stl_iterator.h" 3
  namespace __detail
  {
# 1324 "/usr/include/c++/11/bits/stl_iterator.h" 3
  }
# 1335 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator



    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;

      using __base_ref = typename __traits_type::reference;


      template<typename _Iter2>
 friend class move_iterator;
# 1359 "/usr/include/c++/11/bits/stl_iterator.h" 3
    public:
      using iterator_type = _Iterator;
# 1370 "/usr/include/c++/11/bits/stl_iterator.h" 3
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>



 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>




 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }


      constexpr iterator_type
      base() const
      { return _M_current; }
# 1424 "/usr/include/c++/11/bits/stl_iterator.h" 3
      constexpr reference
      operator*() const



      { return static_cast<reference>(*_M_current); }


      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      constexpr reference
      operator[](difference_type __n) const



      { return std::move(_M_current[__n]); }
# 1529 "/usr/include/c++/11/bits/stl_iterator.h" 3
    };

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
# 1548 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }
# 1599 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
# 2342 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
   
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2374 "/usr/include/c++/11/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<
    typename iterator_traits<_InputIterator>::value_type::first_type>;

  template<typename _InputIterator>
    using __iter_val_t =
    typename iterator_traits<_InputIterator>::value_type::second_type;

  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t =
    pair<add_const_t<__iter_key_t<_InputIterator>>,
  __iter_val_t<_InputIterator>>;



}
# 68 "/usr/include/c++/11/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/11/debug/debug.h" 1 3
# 48 "/usr/include/c++/11/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/11/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/11/bits/predefined_ops.h" 1 3
# 35 "/usr/include/c++/11/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/11/bits/stl_algobase.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
# 105 "/usr/include/c++/11/bits/stl_algobase.h" 3
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 149 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 182 "/usr/include/c++/11/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 198 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 227 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 275 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 297 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }

  template<typename _Ite, typename _Seq>
    _Ite
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&);




  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;





  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
   
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 608 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 641 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 845 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 881 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
# 943 "/usr/include/c++/11/bits/stl_algobase.h" 3
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 989 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1041 "/usr/include/c++/11/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }





  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1141 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>

 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>

 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1487 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1543 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1574 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1664 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1697 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1729 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1764 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 1877 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1905 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1939 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1988 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2024 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2181 "/usr/include/c++/11/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



}
# 46 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/limits" 1 3
# 40 "/usr/include/c++/11/limits" 3
       
# 41 "/usr/include/c++/11/limits" 3
# 158 "/usr/include/c++/11/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/11/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/11/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/11/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/11/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 796 "/usr/include/c++/11/limits" 3
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1635 "/usr/include/c++/11/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1667 "/usr/include/c++/11/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176508575932662800702e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176508575932662800702e+4932L; }


      static constexpr int digits = 113;
      static constexpr int digits10 = 33;

      static constexpr int max_digits10
  = (2 + (113) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.92592994438723585305597794258492732e-34L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 47 "/usr/include/c++/11/bits/specfun.h" 2 3


# 1 "/usr/include/c++/11/tr1/gamma.tcc" 1 3
# 49 "/usr/include/c++/11/tr1/gamma.tcc" 3
# 1 "/usr/include/c++/11/tr1/special_function_util.h" 1 3
# 39 "/usr/include/c++/11/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/11/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/usr/include/c++/11/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "/usr/include/c++/11/tr1/special_function_util.h" 3
  }





}
# 50 "/usr/include/c++/11/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/11/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/usr/include/c++/11/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 50 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/bessel_function.tcc" 1 3
# 55 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "/usr/include/c++/11/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 51 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/beta_function.tcc" 1 3
# 49 "/usr/include/c++/11/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/11/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/usr/include/c++/11/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/usr/include/c++/11/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/usr/include/c++/11/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/usr/include/c++/11/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/usr/include/c++/11/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 52 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/ell_integral.tcc" 1 3
# 45 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 153 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 191 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 219 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 266 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 314 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 399 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 433 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 492 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 561 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 661 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 701 "/usr/include/c++/11/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 53 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/exp_integral.tcc" 1 3
# 50 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/usr/include/c++/11/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 54 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/usr/include/c++/11/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 55 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/legendre_function.tcc" 1 3
# 49 "/usr/include/c++/11/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/11/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/usr/include/c++/11/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "/usr/include/c++/11/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "/usr/include/c++/11/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 56 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/usr/include/c++/11/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 57 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/include/c++/11/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/11/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/usr/include/c++/11/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/usr/include/c++/11/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 58 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/usr/include/c++/11/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 59 "/usr/include/c++/11/bits/specfun.h" 2 3
# 1 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/usr/include/c++/11/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 60 "/usr/include/c++/11/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 205 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 250 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 266 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 296 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 311 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 341 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 357 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 389 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 405 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 436 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 452 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 487 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 503 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 533 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 549 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 579 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 595 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 631 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 647 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 679 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 695 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 727 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 743 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 775 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 791 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 828 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 843 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 868 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 884 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 916 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 932 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 960 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 976 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1005 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1021 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1056 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1072 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1100 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1116 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1127 "/usr/include/c++/11/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1147 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1163 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1191 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1218 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
# 1294 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1305 "/usr/include/c++/11/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1325 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1342 "/usr/include/c++/11/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1353 "/usr/include/c++/11/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1374 "/usr/include/c++/11/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}


#pragma GCC visibility pop
# 1936 "/usr/include/c++/11/cmath" 2 3


}
# 37 "/usr/include/c++/11/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 56 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 203 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf (int __name) noexcept (true);
}
# 82 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/aarch64-linux-gnu/11/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 2 3 4
# 57 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 2
# 91 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wclass-memaccess"
# 114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"

# 114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
struct ImBitVector;
struct ImRect;
struct ImDrawDataBuilder;
struct ImDrawListSharedData;
struct ImGuiColorMod;
struct ImGuiContext;
struct ImGuiContextHook;
struct ImGuiDataTypeInfo;
struct ImGuiGroupData;
struct ImGuiInputTextState;
struct ImGuiLastItemData;
struct ImGuiLocEntry;
struct ImGuiMenuColumns;
struct ImGuiNavItemData;
struct ImGuiMetricsConfig;
struct ImGuiNextWindowData;
struct ImGuiNextItemData;
struct ImGuiOldColumnData;
struct ImGuiOldColumns;
struct ImGuiPopupData;
struct ImGuiSettingsHandler;
struct ImGuiStackSizes;
struct ImGuiStyleMod;
struct ImGuiTabBar;
struct ImGuiTabItem;
struct ImGuiTable;
struct ImGuiTableColumn;
struct ImGuiTableInstanceData;
struct ImGuiTableTempData;
struct ImGuiTableSettings;
struct ImGuiTableColumnsSettings;
struct ImGuiWindow;
struct ImGuiWindowTempData;
struct ImGuiWindowSettings;



enum ImGuiLocKey : int;
typedef int ImGuiLayoutType;


typedef int ImGuiActivateFlags;
typedef int ImGuiDebugLogFlags;
typedef int ImGuiInputFlags;
typedef int ImGuiItemFlags;
typedef int ImGuiItemStatusFlags;
typedef int ImGuiOldColumnFlags;
typedef int ImGuiNavHighlightFlags;
typedef int ImGuiNavMoveFlags;
typedef int ImGuiNextItemDataFlags;
typedef int ImGuiNextWindowDataFlags;
typedef int ImGuiScrollFlags;
typedef int ImGuiSeparatorFlags;
typedef int ImGuiTextFlags;
typedef int ImGuiTooltipFlags;

typedef void (*ImGuiErrorLogCallback)(void* user_data, const char* fmt, ...);







extern ImGuiContext* GImGui;






namespace ImStb
{
# 195 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
# 1 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imstb_textedit.h" 1
# 301 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imstb_textedit.h"
typedef struct
{

   int where;
   int insert_length;
   int delete_length;
   int char_storage;
} StbUndoRecord;

typedef struct
{

   StbUndoRecord undo_rec [99];
   ImWchar undo_char[999];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{





   int cursor;


   int select_start;
   int select_end;





   unsigned char insert_mode;



   int row_count_per_page;







   unsigned char cursor_at_end_of_line;
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x;
   StbUndoState undostate;
} STB_TexteditState;
# 366 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imstb_textedit.h"
typedef struct
{
   float x0,x1;
   float baseline_y_delta;
   float ymin,ymax;
   int num_chars;
} StbTexteditRow;
# 196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 2

}
# 315 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
 ImGuiID ImHashData(const void* data, size_t data_size, ImU32 seed = 0);
 ImGuiID ImHashStr(const char* data, size_t data_size = 0, ImU32 seed = 0);



static inline void ImQsort(void* base, size_t count, size_t size_of_element, int( *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }



 ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b);


static inline bool ImIsPowerOfTwo(int v) { return v != 0 && (v & (v - 1)) == 0; }
static inline bool ImIsPowerOfTwo(ImU64 v) { return v != 0 && (v & (v - 1)) == 0; }
static inline int ImUpperPowerOfTwo(int v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }


 int ImStricmp(const char* str1, const char* str2);
 int ImStrnicmp(const char* str1, const char* str2, size_t count);
 void ImStrncpy(char* dst, const char* src, size_t count);
 char* ImStrdup(const char* str);
 char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);
 const char* ImStrchrRange(const char* str_begin, const char* str_end, char c);
 int ImStrlenW(const ImWchar* str);
 const char* ImStreolRange(const char* str, const char* str_end);
 const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);
 const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
 void ImStrTrimBlanks(char* str);
 const char* ImStrSkipBlank(const char* str);

static inline char ImToUpper(char c) { return (c >= 'a' && c <= 'z') ? c &= ~32 : c; }
static inline bool ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }
static inline bool ImCharIsBlankW(unsigned int c) { return c == ' ' || c == '\t' || c == 0x3000; }



 int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
 int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
 void ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
 void ImFormatStringToTempBufferV(const char** out_buf, const char** out_buf_end, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
 const char* ImParseFormatFindStart(const char* format);
 const char* ImParseFormatFindEnd(const char* format);
 const char* ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);
 void ImParseFormatSanitizeForPrinting(const char* fmt_in, char* fmt_out, size_t fmt_out_size);
 const char* ImParseFormatSanitizeForScanning(const char* fmt_in, char* fmt_out, size_t fmt_out_size);
 int ImParseFormatPrecision(const char* format, int default_value);


 const char* ImTextCharToUtf8(char out_buf[5], unsigned int c);
 int ImTextStrToUtf8(char* out_buf, int out_buf_size, const ImWchar* in_text, const ImWchar* in_text_end);
 int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);
 int ImTextStrFromUtf8(ImWchar* out_buf, int out_buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = 
# 366 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                       __null
# 366 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                           );
 int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);
 int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);
 int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);






static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
static inline ImVec2 operator/(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x / rhs, lhs.y / rhs); }
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x / rhs.x, lhs.y / rhs.y); }
static inline ImVec2& operator*=(ImVec2& lhs, const float rhs) { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const float rhs) { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs) { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
static inline ImVec2& operator*=(ImVec2& lhs, const ImVec2& rhs) { lhs.x *= rhs.x; lhs.y *= rhs.y; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const ImVec2& rhs) { lhs.x /= rhs.x; lhs.y /= rhs.y; return lhs; }
static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs) { return ImVec4(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w); }
static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs) { return ImVec4(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w); }
static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs) { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }

# 405 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
typedef FILE* ImFileHandle;
 ImFileHandle ImFileOpen(const char* filename, const char* mode);
 bool ImFileClose(ImFileHandle file);
 ImU64 ImFileGetSize(ImFileHandle file);
 ImU64 ImFileRead(void* data, ImU64 size, ImU64 count, ImFileHandle file);
 ImU64 ImFileWrite(const void* data, ImU64 size, ImU64 count, ImFileHandle file);



 void* ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size = 
# 414 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                              __null
# 414 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                  , int padding_bytes = 0);



# 430 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
static inline float ImPow(float x, float y) { return powf(x, y); }
static inline double ImPow(double x, double y) { return pow(x, y); }
static inline float ImLog(float x) { return logf(x); }
static inline double ImLog(double x) { return log(x); }
static inline int ImAbs(int x) { return x < 0 ? -x : x; }
static inline float ImAbs(float x) { return fabsf(x); }
static inline double ImAbs(double x) { return fabs(x); }
static inline float ImSign(float x) { return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f : 0.0f; }
static inline double ImSign(double x) { return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0 : 0.0; }



static inline float ImRsqrt(float x) { return 1.0f / sqrtf(x); }

static inline double ImRsqrt(double x) { return 1.0 / sqrt(x); }



template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }
template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }
template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }
template<typename T> static inline T ImLerp(T a, T b, float t) { return (T)(a + (b - a) * t); }
template<typename T> static inline void ImSwap(T& a, T& b) { T tmp = a; a = b; b = tmp; }
template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx) { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }
template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx) { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }

static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx) { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t) { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t) { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float ImSaturate(float f) { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline float ImLengthSqr(const ImVec2& lhs) { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }
static inline float ImLengthSqr(const ImVec4& lhs) { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w); }
static inline float ImInvLength(const ImVec2& lhs, float fail_value) { float d = (lhs.x * lhs.x) + (lhs.y * lhs.y); if (d > 0.0f) return ImRsqrt(d); return fail_value; }
static inline float ImFloor(float f) { return (float)(int)(f); }
static inline float ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); }
static inline ImVec2 ImFloor(const ImVec2& v) { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
static inline ImVec2 ImFloorSigned(const ImVec2& v) { return ImVec2(ImFloorSigned(v.x), ImFloorSigned(v.y)); }
static inline int ImModPositive(int a, int b) { return (a + b) % b; }
static inline float ImDot(const ImVec2& a, const ImVec2& b) { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a) { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float ImLinearSweep(float current, float target, float speed) { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
static inline bool ImIsFloatAboveGuaranteedIntegerPrecision(float f) { return f <= -16777216 || f >= 16777216; }



 ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t);
 ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments);
 ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol);
 ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t);
 ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
 bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
 ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
 void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);
inline float ImTriangleArea(const ImVec2& a, const ImVec2& b, const ImVec2& c) { return fabsf((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5f; }
 ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy);




struct ImVec1
{
    float x;
    constexpr ImVec1() : x(0.0f) { }
    constexpr ImVec1(float _x) : x(_x) { }
};


struct ImVec2ih
{
    short x, y;
    constexpr ImVec2ih() : x(0), y(0) {}
    constexpr ImVec2ih(short _x, short _y) : x(_x), y(_y) {}
    constexpr explicit ImVec2ih(const ImVec2& rhs) : x((short)rhs.x), y((short)rhs.y) {}
};



struct ImRect
{
    ImVec2 Min;
    ImVec2 Max;

    constexpr ImRect() : Min(0.0f, 0.0f), Max(0.0f, 0.0f) {}
    constexpr ImRect(const ImVec2& min, const ImVec2& max) : Min(min), Max(max) {}
    constexpr ImRect(const ImVec4& v) : Min(v.x, v.y), Max(v.z, v.w) {}
    constexpr ImRect(float x1, float y1, float x2, float y2) : Min(x1, y1), Max(x2, y2) {}

    ImVec2 GetCenter() const { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
    ImVec2 GetSize() const { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
    float GetWidth() const { return Max.x - Min.x; }
    float GetHeight() const { return Max.y - Min.y; }
    float GetArea() const { return (Max.x - Min.x) * (Max.y - Min.y); }
    ImVec2 GetTL() const { return Min; }
    ImVec2 GetTR() const { return ImVec2(Max.x, Min.y); }
    ImVec2 GetBL() const { return ImVec2(Min.x, Max.y); }
    ImVec2 GetBR() const { return Max; }
    bool Contains(const ImVec2& p) const { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }
    bool Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
    bool Overlaps(const ImRect& r) const { return r.Min.y < Max.y && r.Max.y > Min.y && r.Min.x < Max.x && r.Max.x > Min.x; }
    void Add(const ImVec2& p) { if (Min.x > p.x) Min.x = p.x; if (Min.y > p.y) Min.y = p.y; if (Max.x < p.x) Max.x = p.x; if (Max.y < p.y) Max.y = p.y; }
    void Add(const ImRect& r) { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
    void Expand(const float amount) { Min.x -= amount; Min.y -= amount; Max.x += amount; Max.y += amount; }
    void Expand(const ImVec2& amount) { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
    void Translate(const ImVec2& d) { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }
    void TranslateX(float dx) { Min.x += dx; Max.x += dx; }
    void TranslateY(float dy) { Min.y += dy; Max.y += dy; }
    void ClipWith(const ImRect& r) { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }
    void ClipWithFull(const ImRect& r) { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); }
    void Floor() { Min.x = ((float)(int)(Min.x)); Min.y = ((float)(int)(Min.y)); Max.x = ((float)(int)(Max.x)); Max.y = ((float)(int)(Max.y)); }
    bool IsInverted() const { return Min.x > Max.x || Min.y > Max.y; }
    ImVec4 ToVec4() const { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
};



inline bool ImBitArrayTestBit(const ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }
inline void ImBitArrayClearBit(ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] &= ~mask; }
inline void ImBitArraySetBit(ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }
inline void ImBitArraySetBitRange(ImU32* arr, int n, int n2)
{
    n2--;
    while (n <= n2)
    {
        int a_mod = (n & 31);
        int b_mod = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1;
        ImU32 mask = (ImU32)(((ImU64)1 << b_mod) - 1) & ~(ImU32)(((ImU64)1 << a_mod) - 1);
        arr[n >> 5] |= mask;
        n = (n + 32) & ~31;
    }
}



template<int BITCOUNT, int OFFSET = 0>
struct ImBitArray
{
    ImU32 Storage[(BITCOUNT + 31) >> 5];
    ImBitArray() { ClearAllBits(); }
    void ClearAllBits() { memset(Storage, 0, sizeof(Storage)); }
    void SetAllBits() { memset(Storage, 255, sizeof(Storage)); }
    bool TestBit(int n) const { n += OFFSET; 
# 574 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              (static_cast <bool> (
# 574 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              n >= 0 && n < BITCOUNT
# 574 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              ) ? void (0) : __assert_fail (
# 574 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              "n >= 0 && n < BITCOUNT"
# 574 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 574, __extension__ __PRETTY_FUNCTION__))
# 574 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                               ; return ImBitArrayTestBit(Storage, n); }
    void SetBit(int n) { n += OFFSET; 
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              (static_cast <bool> (
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              n >= 0 && n < BITCOUNT
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              ) ? void (0) : __assert_fail (
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              "n >= 0 && n < BITCOUNT"
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 575, __extension__ __PRETTY_FUNCTION__))
# 575 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                               ; ImBitArraySetBit(Storage, n); }
    void ClearBit(int n) { n += OFFSET; 
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              (static_cast <bool> (
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              n >= 0 && n < BITCOUNT
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              ) ? void (0) : __assert_fail (
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              "n >= 0 && n < BITCOUNT"
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 576, __extension__ __PRETTY_FUNCTION__))
# 576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                               ; ImBitArrayClearBit(Storage, n); }
    void SetBitRange(int n, int n2) { n += OFFSET; n2 += OFFSET; 
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                            (static_cast <bool> (
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                            n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                            ) ? void (0) : __assert_fail (
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                            "n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT"
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                            , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 577, __extension__ __PRETTY_FUNCTION__))
# 577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                         ; ImBitArraySetBitRange(Storage, n, n2); }
    bool operator[](int n) const { n += OFFSET; 
# 578 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              (static_cast <bool> (
# 578 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              n >= 0 && n < BITCOUNT
# 578 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              ) ? void (0) : __assert_fail (
# 578 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                              "n >= 0 && n < BITCOUNT"
# 578 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                              , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 578, __extension__ __PRETTY_FUNCTION__))
# 578 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                               ; return ImBitArrayTestBit(Storage, n); }
};



struct ImBitVector
{
    ImVector<ImU32> Storage;
    void Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
    void Clear() { Storage.clear(); }
    bool TestBit(int n) const { 
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 (static_cast <bool> (
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                 n < (Storage.Size << 5)
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 ) ? void (0) : __assert_fail (
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                 "n < (Storage.Size << 5)"
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 588, __extension__ __PRETTY_FUNCTION__))
# 588 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                   ; return ImBitArrayTestBit(Storage.Data, n); }
    void SetBit(int n) { 
# 589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 (static_cast <bool> (
# 589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                 n < (Storage.Size << 5)
# 589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 ) ? void (0) : __assert_fail (
# 589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                 "n < (Storage.Size << 5)"
# 589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 589, __extension__ __PRETTY_FUNCTION__))
# 589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                   ; ImBitArraySetBit(Storage.Data, n); }
    void ClearBit(int n) { 
# 590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 (static_cast <bool> (
# 590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                 n < (Storage.Size << 5)
# 590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 ) ? void (0) : __assert_fail (
# 590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                 "n < (Storage.Size << 5)"
# 590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                 , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 590, __extension__ __PRETTY_FUNCTION__))
# 590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                   ; ImBitArrayClearBit(Storage.Data, n); }
};



template<typename T>
struct ImSpan
{
    T* Data;
    T* DataEnd;


    inline ImSpan() { Data = DataEnd = 
# 602 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                      __null
# 602 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                          ; }
    inline ImSpan(T* data, int size) { Data = data; DataEnd = data + size; }
    inline ImSpan(T* data, T* data_end) { Data = data; DataEnd = data_end; }

    inline void set(T* data, int size) { Data = data; DataEnd = data + size; }
    inline void set(T* data, T* data_end) { Data = data; DataEnd = data_end; }
    inline int size() const { return (int)(ptrdiff_t)(DataEnd - Data); }
    inline int size_in_bytes() const { return (int)(ptrdiff_t)(DataEnd - Data) * (int)sizeof(T); }
    inline T& operator[](int i) { T* p = Data + i; 
# 610 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                      (static_cast <bool> (
# 610 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                      p >= Data && p < DataEnd
# 610 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                      ) ? void (0) : __assert_fail (
# 610 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                      "p >= Data && p < DataEnd"
# 610 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                      , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 610, __extension__ __PRETTY_FUNCTION__))
# 610 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                         ; return *p; }
    inline const T& operator[](int i) const { const T* p = Data + i; 
# 611 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                            (static_cast <bool> (
# 611 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                            p >= Data && p < DataEnd
# 611 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                            ) ? void (0) : __assert_fail (
# 611 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                            "p >= Data && p < DataEnd"
# 611 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                            , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 611, __extension__ __PRETTY_FUNCTION__))
# 611 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                               ; return *p; }

    inline T* begin() { return Data; }
    inline const T* begin() const { return Data; }
    inline T* end() { return DataEnd; }
    inline const T* end() const { return DataEnd; }


    inline int index_from_ptr(const T* it) const { 
# 619 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     (static_cast <bool> (
# 619 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     it >= Data && it < DataEnd
# 619 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     ) ? void (0) : __assert_fail (
# 619 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     "it >= Data && it < DataEnd"
# 619 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 619, __extension__ __PRETTY_FUNCTION__))
# 619 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                          ; const ptrdiff_t off = it - Data; return (int)off; }
};




template<int CHUNKS>
struct ImSpanAllocator
{
    char* BasePtr;
    int CurrOff;
    int CurrIdx;
    int Offsets[CHUNKS];
    int Sizes[CHUNKS];

    ImSpanAllocator() { memset(this, 0, sizeof(*this)); }
    inline void Reserve(int n, size_t sz, int a=4) { 
# 635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     (static_cast <bool> (
# 635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     n == CurrIdx && n < CHUNKS
# 635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     ) ? void (0) : __assert_fail (
# 635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     "n == CurrIdx && n < CHUNKS"
# 635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 635, __extension__ __PRETTY_FUNCTION__))
# 635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                          ; CurrOff = (((CurrOff) + ((a) - 1)) & ~((a) - 1)); Offsets[n] = CurrOff; Sizes[n] = (int)sz; CurrIdx++; CurrOff += (int)sz; }
    inline int GetArenaSizeInBytes() { return CurrOff; }
    inline void SetArenaBasePtr(void* base_ptr) { BasePtr = (char*)base_ptr; }
    inline void* GetSpanPtrBegin(int n) { 
# 638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     (static_cast <bool> (
# 638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     n >= 0 && n < CHUNKS && CurrIdx == CHUNKS
# 638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     ) ? void (0) : __assert_fail (
# 638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     "n >= 0 && n < CHUNKS && CurrIdx == CHUNKS"
# 638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 638, __extension__ __PRETTY_FUNCTION__))
# 638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                         ; return (void*)(BasePtr + Offsets[n]); }
    inline void* GetSpanPtrEnd(int n) { 
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     (static_cast <bool> (
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     n >= 0 && n < CHUNKS && CurrIdx == CHUNKS
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     ) ? void (0) : __assert_fail (
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     "n >= 0 && n < CHUNKS && CurrIdx == CHUNKS"
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 639, __extension__ __PRETTY_FUNCTION__))
# 639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                         ; return (void*)(BasePtr + Offsets[n] + Sizes[n]); }
    template<typename T>
    inline void GetSpan(int n, ImSpan<T>* span) { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }
};




typedef int ImPoolIdx;
template<typename T>
struct ImPool
{
    ImVector<T> Buf;
    ImGuiStorage Map;
    ImPoolIdx FreeIdx;
    ImPoolIdx AliveCount;

    ImPool() { FreeIdx = AliveCount = 0; }
    ~ImPool() { Clear(); }
    T* GetByKey(ImGuiID key) { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Buf[idx] : 
# 658 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                     __null
# 658 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                         ; }
    T* GetByIndex(ImPoolIdx n) { return &Buf[n]; }
    ImPoolIdx GetIndex(const T* p) const { 
# 660 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     (static_cast <bool> (
# 660 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     p >= Buf.Data && p < Buf.Data + Buf.Size
# 660 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     ) ? void (0) : __assert_fail (
# 660 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                     "p >= Buf.Data && p < Buf.Data + Buf.Size"
# 660 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                     , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 660, __extension__ __PRETTY_FUNCTION__))
# 660 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                        ; return (ImPoolIdx)(p - Buf.Data); }
    T* GetOrAddByKey(ImGuiID key) { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }
    bool Contains(const T* p) const { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }
    void Clear() { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Buf[idx].~T(); } Map.Clear(); Buf.clear(); FreeIdx = AliveCount = 0; }
    T* Add() { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } new(ImNewWrapper(), &Buf[idx]) T(); AliveCount++; return &Buf[idx]; }
    void Remove(ImGuiID key, const T* p) { Remove(key, GetIndex(p)); }
    void Remove(ImGuiID key, ImPoolIdx idx) { Buf[idx].~T(); *(int*)&Buf[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); AliveCount--; }
    void Reserve(int capacity) { Buf.reserve(capacity); Map.Data.reserve(capacity); }



    int GetAliveCount() const { return AliveCount; }
    int GetBufSize() const { return Buf.Size; }
    int GetMapSize() const { return Map.Data.Size; }
    T* TryGetMapData(ImPoolIdx n) { int idx = Map.Data[n].val_i; if (idx == -1) return 
# 674 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                        __null
# 674 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                            ; return GetByIndex(idx); }

    int GetSize() { return GetMapSize(); }

};






template<typename T>
struct ImChunkStream
{
    ImVector<char> Buf;

    void clear() { Buf.clear(); }
    bool empty() const { return Buf.Size == 0; }
    int size() const { return Buf.Size; }
    T* alloc_chunk(size_t sz) { size_t HDR_SZ = 4; sz = (((HDR_SZ + sz) + ((4u) - 1)) & ~((4u) - 1)); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }
    T* begin() { size_t HDR_SZ = 4; if (!Buf.Data) return 
# 694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                  __null
# 694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                      ; return (T*)(void*)(Buf.Data + HDR_SZ); }
    T* next_chunk(T* p) { size_t HDR_SZ = 4; 
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                            (static_cast <bool> (
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                            p >= begin() && p < end()
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                            ) ? void (0) : __assert_fail (
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                            "p >= begin() && p < end()"
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                            , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 695, __extension__ __PRETTY_FUNCTION__))
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                ; p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; 
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                               (static_cast <bool> (
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                               p < end()
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                               ) ? void (0) : __assert_fail (
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                               "p < end()"
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                               , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 695, __extension__ __PRETTY_FUNCTION__))
# 695 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                                                   ; return p; }
    int chunk_size(const T* p) { return ((const int*)p)[-1]; }
    T* end() { return (T*)(void*)(Buf.Data + Buf.Size); }
    int offset_from_ptr(const T* p) { 
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                         (static_cast <bool> (
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                         p >= begin() && p < end()
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                         ) ? void (0) : __assert_fail (
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                         "p >= begin() && p < end()"
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                         , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 698, __extension__ __PRETTY_FUNCTION__))
# 698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                             ; const ptrdiff_t off = (const char*)p - Buf.Data; return (int)off; }
    T* ptr_from_offset(int off) { 
# 699 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                         (static_cast <bool> (
# 699 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                         off >= 4 && off < Buf.Size
# 699 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                         ) ? void (0) : __assert_fail (
# 699 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                         "off >= 4 && off < Buf.Size"
# 699 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                         , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 699, __extension__ __PRETTY_FUNCTION__))
# 699 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                              ; return (T*)(void*)(Buf.Data + off); }
    void swap(ImChunkStream<T>& rhs) { rhs.Buf.swap(Buf); }

};



struct ImGuiTextIndex
{
    ImVector<int> LineOffsets;
    int EndOffset = 0;

    void clear() { LineOffsets.clear(); EndOffset = 0; }
    int size() { return LineOffsets.Size; }
    const char* get_line_begin(const char* base, int n) { return base + LineOffsets[n]; }
    const char* get_line_end(const char* base, int n) { return base + (n + 1 < LineOffsets.Size ? (LineOffsets[n + 1] - 1) : EndOffset); }
    void append(const char* base, int old_size, int new_size);
};
# 749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
struct ImDrawListSharedData
{
    ImVec2 TexUvWhitePixel;
    ImFont* Font;
    float FontSize;
    float CurveTessellationTol;
    float CircleSegmentMaxError;
    ImVec4 ClipRectFullscreen;
    ImDrawListFlags InitialFlags;


    ImVector<ImVec2> TempBuffer;


    ImVec2 ArcFastVtx[48];
    float ArcFastRadiusCutoff;
    ImU8 CircleSegmentCounts[64];
    const ImVec4* TexUvLines;

    ImDrawListSharedData();
    void SetCircleTessellationMaxError(float max_error);
};

struct ImDrawDataBuilder
{
    ImVector<ImDrawList*> Layers[2];

    void Clear() { for (int n = 0; n < ((int)(sizeof(Layers) / sizeof(*(Layers)))); n++) Layers[n].resize(0); }
    void ClearFreeMemory() { for (int n = 0; n < ((int)(sizeof(Layers) / sizeof(*(Layers)))); n++) Layers[n].clear(); }
    int GetDrawListCount() const { int count = 0; for (int n = 0; n < ((int)(sizeof(Layers) / sizeof(*(Layers)))); n++) count += Layers[n].Size; return count; }
    void FlattenIntoSingleLayer();
};
# 791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
enum ImGuiItemFlags_
{

    ImGuiItemFlags_None = 0,
    ImGuiItemFlags_NoTabStop = 1 << 0,
    ImGuiItemFlags_ButtonRepeat = 1 << 1,
    ImGuiItemFlags_Disabled = 1 << 2,
    ImGuiItemFlags_NoNav = 1 << 3,
    ImGuiItemFlags_NoNavDefaultFocus = 1 << 4,
    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,
    ImGuiItemFlags_MixedValue = 1 << 6,
    ImGuiItemFlags_ReadOnly = 1 << 7,
    ImGuiItemFlags_NoWindowHoverableCheck = 1 << 8,


    ImGuiItemFlags_Inputable = 1 << 10,
};



enum ImGuiItemStatusFlags_
{
    ImGuiItemStatusFlags_None = 0,
    ImGuiItemStatusFlags_HoveredRect = 1 << 0,
    ImGuiItemStatusFlags_HasDisplayRect = 1 << 1,
    ImGuiItemStatusFlags_Edited = 1 << 2,
    ImGuiItemStatusFlags_ToggledSelection = 1 << 3,
    ImGuiItemStatusFlags_ToggledOpen = 1 << 4,
    ImGuiItemStatusFlags_HasDeactivated = 1 << 5,
    ImGuiItemStatusFlags_Deactivated = 1 << 6,
    ImGuiItemStatusFlags_HoveredWindow = 1 << 7,
    ImGuiItemStatusFlags_FocusedByTabbing = 1 << 8,
    ImGuiItemStatusFlags_Visible = 1 << 9,







};


enum ImGuiInputTextFlagsPrivate_
{

    ImGuiInputTextFlags_Multiline = 1 << 26,
    ImGuiInputTextFlags_NoMarkEdited = 1 << 27,
    ImGuiInputTextFlags_MergedItem = 1 << 28,
};


enum ImGuiButtonFlagsPrivate_
{
    ImGuiButtonFlags_PressedOnClick = 1 << 4,
    ImGuiButtonFlags_PressedOnClickRelease = 1 << 5,
    ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6,
    ImGuiButtonFlags_PressedOnRelease = 1 << 7,
    ImGuiButtonFlags_PressedOnDoubleClick = 1 << 8,
    ImGuiButtonFlags_PressedOnDragDropHold = 1 << 9,
    ImGuiButtonFlags_Repeat = 1 << 10,
    ImGuiButtonFlags_FlattenChildren = 1 << 11,
    ImGuiButtonFlags_AllowItemOverlap = 1 << 12,
    ImGuiButtonFlags_DontClosePopups = 1 << 13,

    ImGuiButtonFlags_AlignTextBaseLine = 1 << 15,
    ImGuiButtonFlags_NoKeyModifiers = 1 << 16,
    ImGuiButtonFlags_NoHoldingActiveId = 1 << 17,
    ImGuiButtonFlags_NoNavFocus = 1 << 18,
    ImGuiButtonFlags_NoHoveredOnFocus = 1 << 19,
    ImGuiButtonFlags_NoSetKeyOwner = 1 << 20,
    ImGuiButtonFlags_NoTestKeyOwner = 1 << 21,
    ImGuiButtonFlags_PressedOnMask_ = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
    ImGuiButtonFlags_PressedOnDefault_ = ImGuiButtonFlags_PressedOnClickRelease,
};


enum ImGuiComboFlagsPrivate_
{
    ImGuiComboFlags_CustomPreview = 1 << 20,
};


enum ImGuiSliderFlagsPrivate_
{
    ImGuiSliderFlags_Vertical = 1 << 20,
    ImGuiSliderFlags_ReadOnly = 1 << 21,
};


enum ImGuiSelectableFlagsPrivate_
{

    ImGuiSelectableFlags_NoHoldingActiveID = 1 << 20,
    ImGuiSelectableFlags_SelectOnNav = 1 << 21,
    ImGuiSelectableFlags_SelectOnClick = 1 << 22,
    ImGuiSelectableFlags_SelectOnRelease = 1 << 23,
    ImGuiSelectableFlags_SpanAvailWidth = 1 << 24,
    ImGuiSelectableFlags_DrawHoveredWhenHeld = 1 << 25,
    ImGuiSelectableFlags_SetNavIdOnHover = 1 << 26,
    ImGuiSelectableFlags_NoPadWithHalfSpacing = 1 << 27,
    ImGuiSelectableFlags_NoSetKeyOwner = 1 << 28,
};


enum ImGuiTreeNodeFlagsPrivate_
{
    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 20,
};

enum ImGuiSeparatorFlags_
{
    ImGuiSeparatorFlags_None = 0,
    ImGuiSeparatorFlags_Horizontal = 1 << 0,
    ImGuiSeparatorFlags_Vertical = 1 << 1,
    ImGuiSeparatorFlags_SpanAllColumns = 1 << 2,
};

enum ImGuiTextFlags_
{
    ImGuiTextFlags_None = 0,
    ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0,
};

enum ImGuiTooltipFlags_
{
    ImGuiTooltipFlags_None = 0,
    ImGuiTooltipFlags_OverridePreviousTooltip = 1 << 0,
};



enum ImGuiLayoutType_
{
    ImGuiLayoutType_Horizontal = 0,
    ImGuiLayoutType_Vertical = 1
};

enum ImGuiLogType
{
    ImGuiLogType_None = 0,
    ImGuiLogType_TTY,
    ImGuiLogType_File,
    ImGuiLogType_Buffer,
    ImGuiLogType_Clipboard,
};


enum ImGuiAxis
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X = 0,
    ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram,
};

enum ImGuiPopupPositionPolicy
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox,
    ImGuiPopupPositionPolicy_Tooltip,
};

struct ImGuiDataTypeTempStorage
{
    ImU8 Data[8];
};


struct ImGuiDataTypeInfo
{
    size_t Size;
    const char* Name;
    const char* PrintFmt;
    const char* ScanFmt;
};


enum ImGuiDataTypePrivate_
{
    ImGuiDataType_String = ImGuiDataType_COUNT + 1,
    ImGuiDataType_Pointer,
    ImGuiDataType_ID,
};


struct ImGuiColorMod
{
    ImGuiCol Col;
    ImVec4 BackupValue;
};


struct ImGuiStyleMod
{
    ImGuiStyleVar VarIdx;
    union { int BackupInt[2]; float BackupFloat[2]; };
    ImGuiStyleMod(ImGuiStyleVar idx, int v) { VarIdx = idx; BackupInt[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, float v) { VarIdx = idx; BackupFloat[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v) { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};


struct ImGuiComboPreviewData
{
    ImRect PreviewRect;
    ImVec2 BackupCursorPos;
    ImVec2 BackupCursorMaxPos;
    ImVec2 BackupCursorPosPrevLine;
    float BackupPrevLineTextBaseOffset;
    ImGuiLayoutType BackupLayout;

    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
};


struct ImGuiGroupData
{
    ImGuiID WindowID;
    ImVec2 BackupCursorPos;
    ImVec2 BackupCursorMaxPos;
    ImVec1 BackupIndent;
    ImVec1 BackupGroupOffset;
    ImVec2 BackupCurrLineSize;
    float BackupCurrLineTextBaseOffset;
    ImGuiID BackupActiveIdIsAlive;
    bool BackupActiveIdPreviousFrameIsAlive;
    bool BackupHoveredIdIsAlive;
    bool EmitItem;
};


struct ImGuiMenuColumns
{
    ImU32 TotalWidth;
    ImU32 NextTotalWidth;
    ImU16 Spacing;
    ImU16 OffsetIcon;
    ImU16 OffsetLabel;
    ImU16 OffsetShortcut;
    ImU16 OffsetMark;
    ImU16 Widths[4];

    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
    void Update(float spacing, bool window_reappearing);
    float DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark);
    void CalcNextTotalWidth(bool update_offsets);
};



struct ImGuiInputTextState
{
    ImGuiID ID;
    int CurLenW, CurLenA;
    ImVector<ImWchar> TextW;
    ImVector<char> TextA;
    ImVector<char> InitialTextA;
    bool TextAIsValid;
    int BufCapacityA;
    float ScrollX;
    ImStb::STB_TexteditState Stb;
    float CursorAnim;
    bool CursorFollow;
    bool SelectedAllMouseLock;
    bool Edited;
    ImGuiInputTextFlags Flags;

    ImGuiInputTextState() { memset(this, 0, sizeof(*this)); }
    void ClearText() { CurLenW = CurLenA = 0; TextW[0] = 0; TextA[0] = 0; CursorClamp(); }
    void ClearFreeMemory() { TextW.clear(); TextA.clear(); InitialTextA.clear(); }
    int GetUndoAvailCount() const { return Stb.undostate.undo_point; }
    int GetRedoAvailCount() const { return 99 - Stb.undostate.redo_point; }
    void OnKeyPressed(int key);


    void CursorAnimReset() { CursorAnim = -0.30f; }
    void CursorClamp() { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }
    bool HasSelection() const { return Stb.select_start != Stb.select_end; }
    void ClearSelection() { Stb.select_start = Stb.select_end = Stb.cursor; }
    int GetCursorPos() const { return Stb.cursor; }
    int GetSelectionStart() const { return Stb.select_start; }
    int GetSelectionEnd() const { return Stb.select_end; }
    void SelectAll() { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }
};


struct ImGuiPopupData
{
    ImGuiID PopupId;
    ImGuiWindow* Window;
    ImGuiWindow* BackupNavWindow;
    int ParentNavLayer;
    int OpenFrameCount;
    ImGuiID OpenParentId;
    ImVec2 OpenPopupPos;
    ImVec2 OpenMousePos;

    ImGuiPopupData() { memset(this, 0, sizeof(*this)); ParentNavLayer = OpenFrameCount = -1; }
};

enum ImGuiNextWindowDataFlags_
{
    ImGuiNextWindowDataFlags_None = 0,
    ImGuiNextWindowDataFlags_HasPos = 1 << 0,
    ImGuiNextWindowDataFlags_HasSize = 1 << 1,
    ImGuiNextWindowDataFlags_HasContentSize = 1 << 2,
    ImGuiNextWindowDataFlags_HasCollapsed = 1 << 3,
    ImGuiNextWindowDataFlags_HasSizeConstraint = 1 << 4,
    ImGuiNextWindowDataFlags_HasFocus = 1 << 5,
    ImGuiNextWindowDataFlags_HasBgAlpha = 1 << 6,
    ImGuiNextWindowDataFlags_HasScroll = 1 << 7,
};


struct ImGuiNextWindowData
{
    ImGuiNextWindowDataFlags Flags;
    ImGuiCond PosCond;
    ImGuiCond SizeCond;
    ImGuiCond CollapsedCond;
    ImVec2 PosVal;
    ImVec2 PosPivotVal;
    ImVec2 SizeVal;
    ImVec2 ContentSizeVal;
    ImVec2 ScrollVal;
    bool CollapsedVal;
    ImRect SizeConstraintRect;
    ImGuiSizeCallback SizeCallback;
    void* SizeCallbackUserData;
    float BgAlphaVal;
    ImVec2 MenuBarOffsetMinVal;

    ImGuiNextWindowData() { memset(this, 0, sizeof(*this)); }
    inline void ClearFlags() { Flags = ImGuiNextWindowDataFlags_None; }
};

enum ImGuiNextItemDataFlags_
{
    ImGuiNextItemDataFlags_None = 0,
    ImGuiNextItemDataFlags_HasWidth = 1 << 0,
    ImGuiNextItemDataFlags_HasOpen = 1 << 1,
};

struct ImGuiNextItemData
{
    ImGuiNextItemDataFlags Flags;
    float Width;
    ImGuiID FocusScopeId;
    ImGuiCond OpenCond;
    bool OpenVal;

    ImGuiNextItemData() { memset(this, 0, sizeof(*this)); }
    inline void ClearFlags() { Flags = ImGuiNextItemDataFlags_None; }
};


struct ImGuiLastItemData
{
    ImGuiID ID;
    ImGuiItemFlags InFlags;
    ImGuiItemStatusFlags StatusFlags;
    ImRect Rect;
    ImRect NavRect;
    ImRect DisplayRect;

    ImGuiLastItemData() { memset(this, 0, sizeof(*this)); }
};

struct ImGuiStackSizes
{
    short SizeOfIDStack;
    short SizeOfColorStack;
    short SizeOfStyleVarStack;
    short SizeOfFontStack;
    short SizeOfFocusScopeStack;
    short SizeOfGroupStack;
    short SizeOfItemFlagsStack;
    short SizeOfBeginPopupStack;
    short SizeOfDisabledStack;

    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
    void SetToCurrentState();
    void CompareWithCurrentState();
};


struct ImGuiWindowStackData
{
    ImGuiWindow* Window;
    ImGuiLastItemData ParentLastItemDataBackup;
    ImGuiStackSizes StackSizesOnBegin;
};

struct ImGuiShrinkWidthItem
{
    int Index;
    float Width;
    float InitialWidth;
};

struct ImGuiPtrOrIndex
{
    void* Ptr;
    int Index;

    ImGuiPtrOrIndex(void* ptr) { Ptr = ptr; Index = -1; }
    ImGuiPtrOrIndex(int index) { Ptr = 
# 1203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                       __null
# 1203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                           ; Index = index; }
};





typedef ImBitArray<ImGuiKey_NamedKey_COUNT, -ImGuiKey_NamedKey_BEGIN> ImBitArrayForNamedKeys;
# 1234 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
enum ImGuiInputEventType
{
    ImGuiInputEventType_None = 0,
    ImGuiInputEventType_MousePos,
    ImGuiInputEventType_MouseWheel,
    ImGuiInputEventType_MouseButton,
    ImGuiInputEventType_Key,
    ImGuiInputEventType_Text,
    ImGuiInputEventType_Focus,
    ImGuiInputEventType_COUNT
};

enum ImGuiInputSource
{
    ImGuiInputSource_None = 0,
    ImGuiInputSource_Mouse,
    ImGuiInputSource_Keyboard,
    ImGuiInputSource_Gamepad,
    ImGuiInputSource_Clipboard,
    ImGuiInputSource_Nav,
    ImGuiInputSource_COUNT
};



struct ImGuiInputEventMousePos { float PosX, PosY; };
struct ImGuiInputEventMouseWheel { float WheelX, WheelY; };
struct ImGuiInputEventMouseButton { int Button; bool Down; };
struct ImGuiInputEventKey { ImGuiKey Key; bool Down; float AnalogValue; };
struct ImGuiInputEventText { unsigned int Char; };
struct ImGuiInputEventAppFocused { bool Focused; };

struct ImGuiInputEvent
{
    ImGuiInputEventType Type;
    ImGuiInputSource Source;
    union
    {
        ImGuiInputEventMousePos MousePos;
        ImGuiInputEventMouseWheel MouseWheel;
        ImGuiInputEventMouseButton MouseButton;
        ImGuiInputEventKey Key;
        ImGuiInputEventText Text;
        ImGuiInputEventAppFocused AppFocused;
    };
    bool AddedByTestEngine;

    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
};





typedef ImS16 ImGuiKeyRoutingIndex;


struct ImGuiKeyRoutingData
{
    ImGuiKeyRoutingIndex NextEntryIndex;
    ImU16 Mods;
    ImU8 RoutingNextScore;
    ImGuiID RoutingCurr;
    ImGuiID RoutingNext;

    ImGuiKeyRoutingData() { NextEntryIndex = -1; Mods = 0; RoutingNextScore = 255; RoutingCurr = RoutingNext = ((ImGuiID)-1); }
};



struct ImGuiKeyRoutingTable
{
    ImGuiKeyRoutingIndex Index[ImGuiKey_NamedKey_COUNT];
    ImVector<ImGuiKeyRoutingData> Entries;
    ImVector<ImGuiKeyRoutingData> EntriesNext;

    ImGuiKeyRoutingTable() { Clear(); }
    void Clear() { for (int n = 0; n < ((int)(sizeof(Index) / sizeof(*(Index)))); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }
};



struct ImGuiKeyOwnerData
{
    ImGuiID OwnerCurr;
    ImGuiID OwnerNext;
    bool LockThisFrame;
    bool LockUntilRelease;

    ImGuiKeyOwnerData() { OwnerCurr = OwnerNext = ((ImGuiID)-1); LockThisFrame = LockUntilRelease = false; }
};



enum ImGuiInputFlags_
{

    ImGuiInputFlags_None = 0,
    ImGuiInputFlags_Repeat = 1 << 0,
    ImGuiInputFlags_RepeatRateDefault = 1 << 1,
    ImGuiInputFlags_RepeatRateNavMove = 1 << 2,
    ImGuiInputFlags_RepeatRateNavTweak = 1 << 3,
    ImGuiInputFlags_RepeatRateMask_ = ImGuiInputFlags_RepeatRateDefault | ImGuiInputFlags_RepeatRateNavMove | ImGuiInputFlags_RepeatRateNavTweak,


    ImGuiInputFlags_CondHovered = 1 << 4,
    ImGuiInputFlags_CondActive = 1 << 5,
    ImGuiInputFlags_CondDefault_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,
    ImGuiInputFlags_CondMask_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,


    ImGuiInputFlags_LockThisFrame = 1 << 6,
    ImGuiInputFlags_LockUntilRelease = 1 << 7,
# 1358 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
    ImGuiInputFlags_RouteFocused = 1 << 8,
    ImGuiInputFlags_RouteGlobalLow = 1 << 9,
    ImGuiInputFlags_RouteGlobal = 1 << 10,
    ImGuiInputFlags_RouteGlobalHigh = 1 << 11,
    ImGuiInputFlags_RouteMask_ = ImGuiInputFlags_RouteFocused | ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteGlobalLow | ImGuiInputFlags_RouteGlobalHigh,
    ImGuiInputFlags_RouteAlways = 1 << 12,
    ImGuiInputFlags_RouteUnlessBgFocused= 1 << 13,
    ImGuiInputFlags_RouteExtraMask_ = ImGuiInputFlags_RouteAlways | ImGuiInputFlags_RouteUnlessBgFocused,


    ImGuiInputFlags_SupportedByIsKeyPressed = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_,
    ImGuiInputFlags_SupportedByShortcut = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RouteMask_ | ImGuiInputFlags_RouteExtraMask_,
    ImGuiInputFlags_SupportedBySetKeyOwner = ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease,
    ImGuiInputFlags_SupportedBySetItemKeyOwner = ImGuiInputFlags_SupportedBySetKeyOwner | ImGuiInputFlags_CondMask_,
};





struct ImGuiListClipperRange
{
    int Min;
    int Max;
    bool PosToIndexConvert;
    ImS8 PosToIndexOffsetMin;
    ImS8 PosToIndexOffsetMax;

    static ImGuiListClipperRange FromIndices(int min, int max) { ImGuiListClipperRange r = { min, max, false, 0, 0 }; return r; }
    static ImGuiListClipperRange FromPositions(float y1, float y2, int off_min, int off_max) { ImGuiListClipperRange r = { (int)y1, (int)y2, true, (ImS8)off_min, (ImS8)off_max }; return r; }
};


struct ImGuiListClipperData
{
    ImGuiListClipper* ListClipper;
    float LossynessOffset;
    int StepNo;
    int ItemsFrozen;
    ImVector<ImGuiListClipperRange> Ranges;

    ImGuiListClipperData() { memset(this, 0, sizeof(*this)); }
    void Reset(ImGuiListClipper* clipper) { ListClipper = clipper; StepNo = ItemsFrozen = 0; Ranges.resize(0); }
};





enum ImGuiActivateFlags_
{
    ImGuiActivateFlags_None = 0,
    ImGuiActivateFlags_PreferInput = 1 << 0,
    ImGuiActivateFlags_PreferTweak = 1 << 1,
    ImGuiActivateFlags_TryToPreserveState = 1 << 2,
};


enum ImGuiScrollFlags_
{
    ImGuiScrollFlags_None = 0,
    ImGuiScrollFlags_KeepVisibleEdgeX = 1 << 0,
    ImGuiScrollFlags_KeepVisibleEdgeY = 1 << 1,
    ImGuiScrollFlags_KeepVisibleCenterX = 1 << 2,
    ImGuiScrollFlags_KeepVisibleCenterY = 1 << 3,
    ImGuiScrollFlags_AlwaysCenterX = 1 << 4,
    ImGuiScrollFlags_AlwaysCenterY = 1 << 5,
    ImGuiScrollFlags_NoScrollParent = 1 << 6,
    ImGuiScrollFlags_MaskX_ = ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleCenterX | ImGuiScrollFlags_AlwaysCenterX,
    ImGuiScrollFlags_MaskY_ = ImGuiScrollFlags_KeepVisibleEdgeY | ImGuiScrollFlags_KeepVisibleCenterY | ImGuiScrollFlags_AlwaysCenterY,
};

enum ImGuiNavHighlightFlags_
{
    ImGuiNavHighlightFlags_None = 0,
    ImGuiNavHighlightFlags_TypeDefault = 1 << 0,
    ImGuiNavHighlightFlags_TypeThin = 1 << 1,
    ImGuiNavHighlightFlags_AlwaysDraw = 1 << 2,
    ImGuiNavHighlightFlags_NoRounding = 1 << 3,
};

enum ImGuiNavMoveFlags_
{
    ImGuiNavMoveFlags_None = 0,
    ImGuiNavMoveFlags_LoopX = 1 << 0,
    ImGuiNavMoveFlags_LoopY = 1 << 1,
    ImGuiNavMoveFlags_WrapX = 1 << 2,
    ImGuiNavMoveFlags_WrapY = 1 << 3,
    ImGuiNavMoveFlags_AllowCurrentNavId = 1 << 4,
    ImGuiNavMoveFlags_AlsoScoreVisibleSet = 1 << 5,
    ImGuiNavMoveFlags_ScrollToEdgeY = 1 << 6,
    ImGuiNavMoveFlags_Forwarded = 1 << 7,
    ImGuiNavMoveFlags_DebugNoResult = 1 << 8,
    ImGuiNavMoveFlags_FocusApi = 1 << 9,
    ImGuiNavMoveFlags_Tabbing = 1 << 10,
    ImGuiNavMoveFlags_Activate = 1 << 11,
    ImGuiNavMoveFlags_DontSetNavHighlight = 1 << 12,
};

enum ImGuiNavLayer
{
    ImGuiNavLayer_Main = 0,
    ImGuiNavLayer_Menu = 1,
    ImGuiNavLayer_COUNT
};

struct ImGuiNavItemData
{
    ImGuiWindow* Window;
    ImGuiID ID;
    ImGuiID FocusScopeId;
    ImRect RectRel;
    ImGuiItemFlags InFlags;
    float DistBox;
    float DistCenter;
    float DistAxial;

    ImGuiNavItemData() { Clear(); }
    void Clear() { Window = 
# 1476 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                  __null
# 1476 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                      ; ID = FocusScopeId = 0; InFlags = 0; DistBox = DistCenter = DistAxial = 3.40282346638528859811704183484516925e+38F; }
};






enum ImGuiOldColumnFlags_
{
    ImGuiOldColumnFlags_None = 0,
    ImGuiOldColumnFlags_NoBorder = 1 << 0,
    ImGuiOldColumnFlags_NoResize = 1 << 1,
    ImGuiOldColumnFlags_NoPreserveWidths = 1 << 2,
    ImGuiOldColumnFlags_NoForceWithinWindow = 1 << 3,
    ImGuiOldColumnFlags_GrowParentContentsSize = 1 << 4,



    ImGuiColumnsFlags_None = ImGuiOldColumnFlags_None,
    ImGuiColumnsFlags_NoBorder = ImGuiOldColumnFlags_NoBorder,
    ImGuiColumnsFlags_NoResize = ImGuiOldColumnFlags_NoResize,
    ImGuiColumnsFlags_NoPreserveWidths = ImGuiOldColumnFlags_NoPreserveWidths,
    ImGuiColumnsFlags_NoForceWithinWindow = ImGuiOldColumnFlags_NoForceWithinWindow,
    ImGuiColumnsFlags_GrowParentContentsSize = ImGuiOldColumnFlags_GrowParentContentsSize,

};

struct ImGuiOldColumnData
{
    float OffsetNorm;
    float OffsetNormBeforeResize;
    ImGuiOldColumnFlags Flags;
    ImRect ClipRect;

    ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }
};

struct ImGuiOldColumns
{
    ImGuiID ID;
    ImGuiOldColumnFlags Flags;
    bool IsFirstFrame;
    bool IsBeingResized;
    int Current;
    int Count;
    float OffMinX, OffMaxX;
    float LineMinY, LineMaxY;
    float HostCursorPosY;
    float HostCursorMaxPosX;
    ImRect HostInitialClipRect;
    ImRect HostBackupClipRect;
    ImRect HostBackupParentWorkRect;
    ImVector<ImGuiOldColumnData> Columns;
    ImDrawListSplitter Splitter;

    ImGuiOldColumns() { memset(this, 0, sizeof(*this)); }
};
# 1557 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
struct ImGuiViewportP : public ImGuiViewport
{
    int DrawListsLastFrame[2];
    ImDrawList* DrawLists[2];
    ImDrawData DrawDataP;
    ImDrawDataBuilder DrawDataBuilder;

    ImVec2 WorkOffsetMin;
    ImVec2 WorkOffsetMax;
    ImVec2 BuildWorkOffsetMin;
    ImVec2 BuildWorkOffsetMax;

    ImGuiViewportP() { DrawListsLastFrame[0] = DrawListsLastFrame[1] = -1; DrawLists[0] = DrawLists[1] = 
# 1569 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                           __null
# 1569 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                               ; }
    ~ImGuiViewportP() { if (DrawLists[0]) IM_DELETE(DrawLists[0]); if (DrawLists[1]) IM_DELETE(DrawLists[1]); }


    ImVec2 CalcWorkRectPos(const ImVec2& off_min) const { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }
    ImVec2 CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }
    void UpdateWorkRect() { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); }


    ImRect GetMainRect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
    ImRect GetWorkRect() const { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
    ImRect GetBuildWorkRect() const { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }
};
# 1590 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
struct ImGuiWindowSettings
{
    ImGuiID ID;
    ImVec2ih Pos;
    ImVec2ih Size;
    bool Collapsed;
    bool WantApply;

    ImGuiWindowSettings() { memset(this, 0, sizeof(*this)); }
    char* GetName() { return (char*)(this + 1); }
};

struct ImGuiSettingsHandler
{
    const char* TypeName;
    ImGuiID TypeHash;
    void (*ClearAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);
    void (*ReadInitFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);
    void* (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);
    void (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line);
    void (*ApplyAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);
    void (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);
    void* UserData;

    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};






enum ImGuiLocKey : int
{
    ImGuiLocKey_TableSizeOne,
    ImGuiLocKey_TableSizeAllFit,
    ImGuiLocKey_TableSizeAllDefault,
    ImGuiLocKey_TableResetOrder,
    ImGuiLocKey_WindowingMainMenuBar,
    ImGuiLocKey_WindowingPopup,
    ImGuiLocKey_WindowingUntitled,
    ImGuiLocKey_COUNT
};

struct ImGuiLocEntry
{
    ImGuiLocKey Key;
    const char* Text;
};






enum ImGuiDebugLogFlags_
{

    ImGuiDebugLogFlags_None = 0,
    ImGuiDebugLogFlags_EventActiveId = 1 << 0,
    ImGuiDebugLogFlags_EventFocus = 1 << 1,
    ImGuiDebugLogFlags_EventPopup = 1 << 2,
    ImGuiDebugLogFlags_EventNav = 1 << 3,
    ImGuiDebugLogFlags_EventClipper = 1 << 4,
    ImGuiDebugLogFlags_EventIO = 1 << 5,
    ImGuiDebugLogFlags_EventMask_ = ImGuiDebugLogFlags_EventActiveId | ImGuiDebugLogFlags_EventFocus | ImGuiDebugLogFlags_EventPopup | ImGuiDebugLogFlags_EventNav | ImGuiDebugLogFlags_EventClipper | ImGuiDebugLogFlags_EventIO,
    ImGuiDebugLogFlags_OutputToTTY = 1 << 10,
};

struct ImGuiMetricsConfig
{
    bool ShowDebugLog;
    bool ShowStackTool;
    bool ShowWindowsRects;
    bool ShowWindowsBeginOrder;
    bool ShowTablesRects;
    bool ShowDrawCmdMesh;
    bool ShowDrawCmdBoundingBoxes;
    int ShowWindowsRectsType;
    int ShowTablesRectsType;

    ImGuiMetricsConfig()
    {
        ShowDebugLog = ShowStackTool = ShowWindowsRects = ShowWindowsBeginOrder = ShowTablesRects = false;
        ShowDrawCmdMesh = true;
        ShowDrawCmdBoundingBoxes = true;
        ShowWindowsRectsType = ShowTablesRectsType = -1;
    }
};

struct ImGuiStackLevelInfo
{
    ImGuiID ID;
    ImS8 QueryFrameCount;
    bool QuerySuccess;
    ImGuiDataType DataType : 8;
    char Desc[57];

    ImGuiStackLevelInfo() { memset(this, 0, sizeof(*this)); }
};


struct ImGuiStackTool
{
    int LastActiveFrame;
    int StackLevel;
    ImGuiID QueryId;
    ImVector<ImGuiStackLevelInfo> Results;
    bool CopyToClipboardOnCtrlC;
    float CopyToClipboardLastTime;

    ImGuiStackTool() { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -3.40282346638528859811704183484516925e+38F; }
};





typedef void (*ImGuiContextHookCallback)(ImGuiContext* ctx, ImGuiContextHook* hook);
enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };

struct ImGuiContextHook
{
    ImGuiID HookId;
    ImGuiContextHookType Type;
    ImGuiID Owner;
    ImGuiContextHookCallback Callback;
    void* UserData;

    ImGuiContextHook() { memset(this, 0, sizeof(*this)); }
};





struct ImGuiContext
{
    bool Initialized;
    bool FontAtlasOwnedByContext;
    ImGuiIO IO;
    ImVector<ImGuiInputEvent> InputEventsQueue;
    ImVector<ImGuiInputEvent> InputEventsTrail;
    ImGuiStyle Style;
    ImFont* Font;
    float FontSize;
    float FontBaseSize;
    ImDrawListSharedData DrawListSharedData;
    double Time;
    int FrameCount;
    int FrameCountEnded;
    int FrameCountRendered;
    bool WithinFrameScope;
    bool WithinFrameScopeWithImplicitWindow;
    bool WithinEndChild;
    bool GcCompactAll;
    bool TestEngineHookItems;
    void* TestEngine;


    ImVector<ImGuiWindow*> Windows;
    ImVector<ImGuiWindow*> WindowsFocusOrder;
    ImVector<ImGuiWindow*> WindowsTempSortBuffer;
    ImVector<ImGuiWindowStackData> CurrentWindowStack;
    ImGuiStorage WindowsById;
    int WindowsActiveCount;
    ImVec2 WindowsHoverPadding;
    ImGuiWindow* CurrentWindow;
    ImGuiWindow* HoveredWindow;
    ImGuiWindow* HoveredWindowUnderMovingWindow;
    ImGuiWindow* MovingWindow;
    ImGuiWindow* WheelingWindow;
    ImVec2 WheelingWindowRefMousePos;
    float WheelingWindowReleaseTimer;


    ImGuiID DebugHookIdInfo;
    ImGuiID HoveredId;
    ImGuiID HoveredIdPreviousFrame;
    bool HoveredIdAllowOverlap;
    bool HoveredIdDisabled;
    float HoveredIdTimer;
    float HoveredIdNotActiveTimer;
    ImGuiID ActiveId;
    ImGuiID ActiveIdIsAlive;
    float ActiveIdTimer;
    bool ActiveIdIsJustActivated;
    bool ActiveIdAllowOverlap;
    bool ActiveIdNoClearOnFocusLoss;
    bool ActiveIdHasBeenPressedBefore;
    bool ActiveIdHasBeenEditedBefore;
    bool ActiveIdHasBeenEditedThisFrame;
    ImVec2 ActiveIdClickOffset;
    ImGuiWindow* ActiveIdWindow;
    ImGuiInputSource ActiveIdSource;
    int ActiveIdMouseButton;
    ImGuiID ActiveIdPreviousFrame;
    bool ActiveIdPreviousFrameIsAlive;
    bool ActiveIdPreviousFrameHasBeenEditedBefore;
    ImGuiWindow* ActiveIdPreviousFrameWindow;
    ImGuiID LastActiveId;
    float LastActiveIdTimer;





    ImGuiKeyOwnerData KeysOwnerData[ImGuiKey_NamedKey_COUNT];
    ImGuiKeyRoutingTable KeysRoutingTable;
    ImU32 ActiveIdUsingNavDirMask;
    bool ActiveIdUsingAllKeyboardKeys;

    ImU32 ActiveIdUsingNavInputMask;



    ImGuiID CurrentFocusScopeId;
    ImGuiItemFlags CurrentItemFlags;
    ImGuiID DebugLocateId;
    ImGuiNextItemData NextItemData;
    ImGuiLastItemData LastItemData;
    ImGuiNextWindowData NextWindowData;


    ImVector<ImGuiColorMod> ColorStack;
    ImVector<ImGuiStyleMod> StyleVarStack;
    ImVector<ImFont*> FontStack;
    ImVector<ImGuiID> FocusScopeStack;
    ImVector<ImGuiItemFlags>ItemFlagsStack;
    ImVector<ImGuiGroupData>GroupStack;
    ImVector<ImGuiPopupData>OpenPopupStack;
    ImVector<ImGuiPopupData>BeginPopupStack;
    int BeginMenuCount;


    ImVector<ImGuiViewportP*> Viewports;


    ImGuiWindow* NavWindow;
    ImGuiID NavId;
    ImGuiID NavFocusScopeId;
    ImGuiID NavActivateId;
    ImGuiID NavActivateDownId;
    ImGuiID NavActivatePressedId;
    ImGuiID NavActivateInputId;
    ImGuiActivateFlags NavActivateFlags;
    ImGuiID NavJustMovedToId;
    ImGuiID NavJustMovedToFocusScopeId;
    ImGuiKeyChord NavJustMovedToKeyMods;
    ImGuiID NavNextActivateId;
    ImGuiActivateFlags NavNextActivateFlags;
    ImGuiInputSource NavInputSource;
    ImGuiNavLayer NavLayer;
    bool NavIdIsAlive;
    bool NavMousePosDirty;
    bool NavDisableHighlight;
    bool NavDisableMouseHover;


    bool NavAnyRequest;
    bool NavInitRequest;
    bool NavInitRequestFromMove;
    ImGuiID NavInitResultId;
    ImRect NavInitResultRectRel;
    bool NavMoveSubmitted;
    bool NavMoveScoringItems;
    bool NavMoveForwardToNextFrame;
    ImGuiNavMoveFlags NavMoveFlags;
    ImGuiScrollFlags NavMoveScrollFlags;
    ImGuiKeyChord NavMoveKeyMods;
    ImGuiDir NavMoveDir;
    ImGuiDir NavMoveDirForDebug;
    ImGuiDir NavMoveClipDir;
    ImRect NavScoringRect;
    ImRect NavScoringNoClipRect;
    int NavScoringDebugCount;
    int NavTabbingDir;
    int NavTabbingCounter;
    ImGuiNavItemData NavMoveResultLocal;
    ImGuiNavItemData NavMoveResultLocalVisible;
    ImGuiNavItemData NavMoveResultOther;
    ImGuiNavItemData NavTabbingResultFirst;


    ImGuiKeyChord ConfigNavWindowingKeyNext;
    ImGuiKeyChord ConfigNavWindowingKeyPrev;
    ImGuiWindow* NavWindowingTarget;
    ImGuiWindow* NavWindowingTargetAnim;
    ImGuiWindow* NavWindowingListWindow;
    float NavWindowingTimer;
    float NavWindowingHighlightAlpha;
    bool NavWindowingToggleLayer;
    ImVec2 NavWindowingAccumDeltaPos;
    ImVec2 NavWindowingAccumDeltaSize;


    float DimBgRatio;
    ImGuiMouseCursor MouseCursor;


    bool DragDropActive;
    bool DragDropWithinSource;
    bool DragDropWithinTarget;
    ImGuiDragDropFlags DragDropSourceFlags;
    int DragDropSourceFrameCount;
    int DragDropMouseButton;
    ImGuiPayload DragDropPayload;
    ImRect DragDropTargetRect;
    ImGuiID DragDropTargetId;
    ImGuiDragDropFlags DragDropAcceptFlags;
    float DragDropAcceptIdCurrRectSurface;
    ImGuiID DragDropAcceptIdCurr;
    ImGuiID DragDropAcceptIdPrev;
    int DragDropAcceptFrameCount;
    ImGuiID DragDropHoldJustPressedId;
    ImVector<unsigned char> DragDropPayloadBufHeap;
    unsigned char DragDropPayloadBufLocal[16];


    int ClipperTempDataStacked;
    ImVector<ImGuiListClipperData> ClipperTempData;


    ImGuiTable* CurrentTable;
    int TablesTempDataStacked;
    ImVector<ImGuiTableTempData> TablesTempData;
    ImPool<ImGuiTable> Tables;
    ImVector<float> TablesLastTimeActive;
    ImVector<ImDrawChannel> DrawChannelsTempMergeBuffer;


    ImGuiTabBar* CurrentTabBar;
    ImPool<ImGuiTabBar> TabBars;
    ImVector<ImGuiPtrOrIndex> CurrentTabBarStack;
    ImVector<ImGuiShrinkWidthItem> ShrinkWidthBuffer;


    ImGuiID HoverDelayId;
    ImGuiID HoverDelayIdPreviousFrame;
    float HoverDelayTimer;
    float HoverDelayClearTimer;


    ImVec2 MouseLastValidPos;
    ImGuiInputTextState InputTextState;
    ImFont InputTextPasswordFont;
    ImGuiID TempInputId;
    ImGuiColorEditFlags ColorEditOptions;
    float ColorEditLastHue;
    float ColorEditLastSat;
    ImU32 ColorEditLastColor;
    ImVec4 ColorPickerRef;
    ImGuiComboPreviewData ComboPreviewData;
    float SliderGrabClickOffset;
    float SliderCurrentAccum;
    bool SliderCurrentAccumDirty;
    bool DragCurrentAccumDirty;
    float DragCurrentAccum;
    float DragSpeedDefaultRatio;
    float ScrollbarClickDeltaToGrabCenter;
    float DisabledAlphaBackup;
    short DisabledStackSize;
    short TooltipOverrideCount;
    ImVector<char> ClipboardHandlerData;
    ImVector<ImGuiID> MenusIdSubmittedThisFrame;


    ImGuiPlatformImeData PlatformImeData;
    ImGuiPlatformImeData PlatformImeDataPrev;
    char PlatformLocaleDecimalPoint;


    bool SettingsLoaded;
    float SettingsDirtyTimer;
    ImGuiTextBuffer SettingsIniData;
    ImVector<ImGuiSettingsHandler> SettingsHandlers;
    ImChunkStream<ImGuiWindowSettings> SettingsWindows;
    ImChunkStream<ImGuiTableSettings> SettingsTables;
    ImVector<ImGuiContextHook> Hooks;
    ImGuiID HookIdNext;


    const char* LocalizationTable[ImGuiLocKey_COUNT];


    bool LogEnabled;
    ImGuiLogType LogType;
    ImFileHandle LogFile;
    ImGuiTextBuffer LogBuffer;
    const char* LogNextPrefix;
    const char* LogNextSuffix;
    float LogLinePosY;
    bool LogLineFirstItem;
    int LogDepthRef;
    int LogDepthToExpand;
    int LogDepthToExpandDefault;


    ImGuiDebugLogFlags DebugLogFlags;
    ImGuiTextBuffer DebugLogBuf;
    ImGuiTextIndex DebugLogIndex;
    ImU8 DebugLocateFrames;
    bool DebugItemPickerActive;
    ImU8 DebugItemPickerMouseButton;
    ImGuiID DebugItemPickerBreakId;
    ImGuiMetricsConfig DebugMetricsConfig;
    ImGuiStackTool DebugStackTool;


    float FramerateSecPerFrame[60];
    int FramerateSecPerFrameIdx;
    int FramerateSecPerFrameCount;
    float FramerateSecPerFrameAccum;
    int WantCaptureMouseNextFrame;
    int WantCaptureKeyboardNextFrame;
    int WantTextInputNextFrame;
    ImVector<char> TempBuffer;

    ImGuiContext(ImFontAtlas* shared_font_atlas)
    {
        Initialized = false;
        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        Font = 
# 2012 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
              __null
# 2012 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                  ;
        FontSize = FontBaseSize = 0.0f;
        IO.Fonts = shared_font_atlas ? shared_font_atlas : new(ImNewWrapper(), ImGui::MemAlloc(sizeof(ImFontAtlas))) ImFontAtlas();
        Time = 0.0f;
        FrameCount = 0;
        FrameCountEnded = FrameCountRendered = -1;
        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
        GcCompactAll = false;
        TestEngineHookItems = false;
        TestEngine = 
# 2021 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                    __null
# 2021 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                        ;

        WindowsActiveCount = 0;
        CurrentWindow = 
# 2024 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                       __null
# 2024 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                           ;
        HoveredWindow = 
# 2025 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                       __null
# 2025 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                           ;
        HoveredWindowUnderMovingWindow = 
# 2026 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                        __null
# 2026 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                            ;
        MovingWindow = 
# 2027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                      __null
# 2027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                          ;
        WheelingWindow = 
# 2028 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                        __null
# 2028 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                            ;
        WheelingWindowReleaseTimer = 0.0f;

        DebugHookIdInfo = 0;
        HoveredId = HoveredIdPreviousFrame = 0;
        HoveredIdAllowOverlap = false;
        HoveredIdDisabled = false;
        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        ActiveId = 0;
        ActiveIdIsAlive = 0;
        ActiveIdTimer = 0.0f;
        ActiveIdIsJustActivated = false;
        ActiveIdAllowOverlap = false;
        ActiveIdNoClearOnFocusLoss = false;
        ActiveIdHasBeenPressedBefore = false;
        ActiveIdHasBeenEditedBefore = false;
        ActiveIdHasBeenEditedThisFrame = false;
        ActiveIdClickOffset = ImVec2(-1, -1);
        ActiveIdWindow = 
# 2046 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                        __null
# 2046 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                            ;
        ActiveIdSource = ImGuiInputSource_None;
        ActiveIdMouseButton = -1;
        ActiveIdPreviousFrame = 0;
        ActiveIdPreviousFrameIsAlive = false;
        ActiveIdPreviousFrameHasBeenEditedBefore = false;
        ActiveIdPreviousFrameWindow = 
# 2052 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                     __null
# 2052 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                         ;
        LastActiveId = 0;
        LastActiveIdTimer = 0.0f;

        ActiveIdUsingNavDirMask = 0x00;
        ActiveIdUsingAllKeyboardKeys = false;

        ActiveIdUsingNavInputMask = 0x00;


        CurrentFocusScopeId = 0;
        CurrentItemFlags = ImGuiItemFlags_None;
        BeginMenuCount = 0;

        NavWindow = 
# 2066 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                   __null
# 2066 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                       ;
        NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavActivateInputId = 0;
        NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
        NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
        NavJustMovedToKeyMods = ImGuiMod_None;
        NavInputSource = ImGuiInputSource_None;
        NavLayer = ImGuiNavLayer_Main;
        NavIdIsAlive = false;
        NavMousePosDirty = false;
        NavDisableHighlight = true;
        NavDisableMouseHover = false;
        NavAnyRequest = false;
        NavInitRequest = false;
        NavInitRequestFromMove = false;
        NavInitResultId = 0;
        NavMoveSubmitted = false;
        NavMoveScoringItems = false;
        NavMoveForwardToNextFrame = false;
        NavMoveFlags = ImGuiNavMoveFlags_None;
        NavMoveScrollFlags = ImGuiScrollFlags_None;
        NavMoveKeyMods = ImGuiMod_None;
        NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
        NavScoringDebugCount = 0;
        NavTabbingDir = 0;
        NavTabbingCounter = 0;

        ConfigNavWindowingKeyNext = ImGuiMod_Ctrl | ImGuiKey_Tab;
        ConfigNavWindowingKeyPrev = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab;
        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = 
# 2094 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                              __null
# 2094 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                  ;
        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        NavWindowingToggleLayer = false;

        DimBgRatio = 0.0f;
        MouseCursor = ImGuiMouseCursor_Arrow;

        DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
        DragDropSourceFlags = ImGuiDragDropFlags_None;
        DragDropSourceFrameCount = -1;
        DragDropMouseButton = -1;
        DragDropTargetId = 0;
        DragDropAcceptFlags = ImGuiDragDropFlags_None;
        DragDropAcceptIdCurrRectSurface = 0.0f;
        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        DragDropAcceptFrameCount = -1;
        DragDropHoldJustPressedId = 0;
        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

        ClipperTempDataStacked = 0;

        CurrentTable = 
# 2115 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                      __null
# 2115 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                          ;
        TablesTempDataStacked = 0;
        CurrentTabBar = 
# 2117 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                       __null
# 2117 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                           ;

        HoverDelayId = HoverDelayIdPreviousFrame = 0;
        HoverDelayTimer = HoverDelayClearTimer = 0.0f;

        TempInputId = 0;
        ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
        ColorEditLastHue = ColorEditLastSat = 0.0f;
        ColorEditLastColor = 0;
        SliderGrabClickOffset = 0.0f;
        SliderCurrentAccum = 0.0f;
        SliderCurrentAccumDirty = false;
        DragCurrentAccumDirty = false;
        DragCurrentAccum = 0.0f;
        DragSpeedDefaultRatio = 1.0f / 100.0f;
        ScrollbarClickDeltaToGrabCenter = 0.0f;
        DisabledAlphaBackup = 0.0f;
        DisabledStackSize = 0;
        TooltipOverrideCount = 0;

        PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
        PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f);
        PlatformLocaleDecimalPoint = '.';

        SettingsLoaded = false;
        SettingsDirtyTimer = 0.0f;
        HookIdNext = 0;

        memset(LocalizationTable, 0, sizeof(LocalizationTable));

        LogEnabled = false;
        LogType = ImGuiLogType_None;
        LogNextPrefix = LogNextSuffix = 
# 2149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                       __null
# 2149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                           ;
        LogFile = 
# 2150 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                 __null
# 2150 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                     ;
        LogLinePosY = 3.40282346638528859811704183484516925e+38F;
        LogLineFirstItem = false;
        LogDepthRef = 0;
        LogDepthToExpand = LogDepthToExpandDefault = 2;

        DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
        DebugLocateId = 0;
        DebugLocateFrames = 0;
        DebugItemPickerActive = false;
        DebugItemPickerMouseButton = ImGuiMouseButton_Left;
        DebugItemPickerBreakId = 0;

        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
        FramerateSecPerFrameAccum = 0.0f;
        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
    }
};
# 2177 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
struct ImGuiWindowTempData
{

    ImVec2 CursorPos;
    ImVec2 CursorPosPrevLine;
    ImVec2 CursorStartPos;
    ImVec2 CursorMaxPos;
    ImVec2 IdealMaxPos;
    ImVec2 CurrLineSize;
    ImVec2 PrevLineSize;
    float CurrLineTextBaseOffset;
    float PrevLineTextBaseOffset;
    bool IsSameLine;
    bool IsSetPos;
    ImVec1 Indent;
    ImVec1 ColumnsOffset;
    ImVec1 GroupOffset;
    ImVec2 CursorStartPosLossyness;


    ImGuiNavLayer NavLayerCurrent;
    short NavLayersActiveMask;
    short NavLayersActiveMaskNext;
    bool NavHideHighlightOneFrame;
    bool NavHasScroll;


    bool MenuBarAppending;
    ImVec2 MenuBarOffset;
    ImGuiMenuColumns MenuColumns;
    int TreeDepth;
    ImU32 TreeJumpToParentOnPopMask;
    ImVector<ImGuiWindow*> ChildWindows;
    ImGuiStorage* StateStorage;
    ImGuiOldColumns* CurrentColumns;
    int CurrentTableIdx;
    ImGuiLayoutType LayoutType;
    ImGuiLayoutType ParentLayoutType;



    float ItemWidth;
    float TextWrapPos;
    ImVector<float> ItemWidthStack;
    ImVector<float> TextWrapPosStack;
};


struct ImGuiWindow
{
    char* Name;
    ImGuiID ID;
    ImGuiWindowFlags Flags;
    ImGuiViewportP* Viewport;
    ImVec2 Pos;
    ImVec2 Size;
    ImVec2 SizeFull;
    ImVec2 ContentSize;
    ImVec2 ContentSizeIdeal;
    ImVec2 ContentSizeExplicit;
    ImVec2 WindowPadding;
    float WindowRounding;
    float WindowBorderSize;
    int NameBufLen;
    ImGuiID MoveId;
    ImGuiID ChildId;
    ImVec2 Scroll;
    ImVec2 ScrollMax;
    ImVec2 ScrollTarget;
    ImVec2 ScrollTargetCenterRatio;
    ImVec2 ScrollTargetEdgeSnapDist;
    ImVec2 ScrollbarSizes;
    bool ScrollbarX, ScrollbarY;
    bool Active;
    bool WasActive;
    bool WriteAccessed;
    bool Collapsed;
    bool WantCollapseToggle;
    bool SkipItems;
    bool Appearing;
    bool Hidden;
    bool IsFallbackWindow;
    bool IsExplicitChild;
    bool HasCloseButton;
    signed char ResizeBorderHeld;
    short BeginCount;
    short BeginCountPreviousFrame;
    short BeginOrderWithinParent;
    short BeginOrderWithinContext;
    short FocusOrder;
    ImGuiID PopupId;
    ImS8 AutoFitFramesX, AutoFitFramesY;
    ImS8 AutoFitChildAxises;
    bool AutoFitOnlyGrows;
    ImGuiDir AutoPosLastDirection;
    ImS8 HiddenFramesCanSkipItems;
    ImS8 HiddenFramesCannotSkipItems;
    ImS8 HiddenFramesForRenderOnly;
    ImS8 DisableInputsFrames;
    ImGuiCond SetWindowPosAllowFlags : 8;
    ImGuiCond SetWindowSizeAllowFlags : 8;
    ImGuiCond SetWindowCollapsedAllowFlags : 8;
    ImVec2 SetWindowPosVal;
    ImVec2 SetWindowPosPivot;

    ImVector<ImGuiID> IDStack;
    ImGuiWindowTempData DC;



    ImRect OuterRectClipped;
    ImRect InnerRect;
    ImRect InnerClipRect;
    ImRect WorkRect;
    ImRect ParentWorkRect;
    ImRect ClipRect;
    ImRect ContentRegionRect;
    ImVec2ih HitTestHoleSize;
    ImVec2ih HitTestHoleOffset;

    int LastFrameActive;
    float LastTimeActive;
    float ItemWidthDefault;
    ImGuiStorage StateStorage;
    ImVector<ImGuiOldColumns> ColumnsStorage;
    float FontWindowScale;
    int SettingsOffset;

    ImDrawList* DrawList;
    ImDrawList DrawListInst;
    ImGuiWindow* ParentWindow;
    ImGuiWindow* ParentWindowInBeginStack;
    ImGuiWindow* RootWindow;
    ImGuiWindow* RootWindowPopupTree;
    ImGuiWindow* RootWindowForTitleBarHighlight;
    ImGuiWindow* RootWindowForNav;

    ImGuiWindow* NavLastChildNavWindow;
    ImGuiID NavLastIds[ImGuiNavLayer_COUNT];
    ImRect NavRectRel[ImGuiNavLayer_COUNT];
    ImGuiID NavRootFocusScopeId;

    int MemoryDrawListIdxCapacity;
    int MemoryDrawListVtxCapacity;
    bool MemoryCompacted;

public:
    ImGuiWindow(ImGuiContext* context, const char* name);
    ~ImGuiWindow();

    ImGuiID GetID(const char* str, const char* str_end = 
# 2327 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                            __null
# 2327 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                );
    ImGuiID GetID(const void* ptr);
    ImGuiID GetID(int n);
    ImGuiID GetIDFromRectangle(const ImRect& r_abs);


    ImRect Rect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
    float CalcFontSize() const { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
    float TitleBarHeight() const { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }
    ImRect TitleBarRect() const { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float MenuBarHeight() const { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect MenuBarRect() const { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};






enum ImGuiTabBarFlagsPrivate_
{
    ImGuiTabBarFlags_DockNode = 1 << 20,
    ImGuiTabBarFlags_IsFocused = 1 << 21,
    ImGuiTabBarFlags_SaveSettings = 1 << 22,
};


enum ImGuiTabItemFlagsPrivate_
{
    ImGuiTabItemFlags_SectionMask_ = ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing,
    ImGuiTabItemFlags_NoCloseButton = 1 << 20,
    ImGuiTabItemFlags_Button = 1 << 21,
};


struct ImGuiTabItem
{
    ImGuiID ID;
    ImGuiTabItemFlags Flags;
    int LastFrameVisible;
    int LastFrameSelected;
    float Offset;
    float Width;
    float ContentWidth;
    float RequestedWidth;
    ImS32 NameOffset;
    ImS16 BeginOrder;
    ImS16 IndexDuringLayout;
    bool WantClose;

    ImGuiTabItem() { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }
};


struct ImGuiTabBar
{
    ImVector<ImGuiTabItem> Tabs;
    ImGuiTabBarFlags Flags;
    ImGuiID ID;
    ImGuiID SelectedTabId;
    ImGuiID NextSelectedTabId;
    ImGuiID VisibleTabId;
    int CurrFrameVisible;
    int PrevFrameVisible;
    ImRect BarRect;
    float CurrTabsContentsHeight;
    float PrevTabsContentsHeight;
    float WidthAllTabs;
    float WidthAllTabsIdeal;
    float ScrollingAnim;
    float ScrollingTarget;
    float ScrollingTargetDistToVisibility;
    float ScrollingSpeed;
    float ScrollingRectMinX;
    float ScrollingRectMaxX;
    ImGuiID ReorderRequestTabId;
    ImS16 ReorderRequestOffset;
    ImS8 BeginCount;
    bool WantLayout;
    bool VisibleTabWasSubmitted;
    bool TabsAddedNew;
    ImS16 TabsActiveCount;
    ImS16 LastTabItemIdx;
    float ItemSpacingY;
    ImVec2 FramePadding;
    ImVec2 BackupCursorPos;
    ImGuiTextBuffer TabsNames;

    ImGuiTabBar();
    int GetTabOrder(const ImGuiTabItem* tab) const { return Tabs.index_from_ptr(tab); }
    const char* GetTabName(const ImGuiTabItem* tab) const
    {
        
# 2419 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
       (static_cast <bool> (
# 2419 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
       tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size
# 2419 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
       ) ? void (0) : __assert_fail (
# 2419 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
       "tab->NameOffset != -1 && tab->NameOffset < TabsNames.Buf.Size"
# 2419 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 2419, __extension__ __PRETTY_FUNCTION__))
# 2419 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                               ;
        return TabsNames.Buf.Data + tab->NameOffset;
    }
};
# 2433 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
typedef ImS8 ImGuiTableColumnIdx;
typedef ImU8 ImGuiTableDrawChannelIdx;





struct ImGuiTableColumn
{
    ImGuiTableColumnFlags Flags;
    float WidthGiven;
    float MinX;
    float MaxX;
    float WidthRequest;
    float WidthAuto;
    float StretchWeight;
    float InitStretchWeightOrWidth;
    ImRect ClipRect;
    ImGuiID UserID;
    float WorkMinX;
    float WorkMaxX;
    float ItemWidth;
    float ContentMaxXFrozen;
    float ContentMaxXUnfrozen;
    float ContentMaxXHeadersUsed;
    float ContentMaxXHeadersIdeal;
    ImS16 NameOffset;
    ImGuiTableColumnIdx DisplayOrder;
    ImGuiTableColumnIdx IndexWithinEnabledSet;
    ImGuiTableColumnIdx PrevEnabledColumn;
    ImGuiTableColumnIdx NextEnabledColumn;
    ImGuiTableColumnIdx SortOrder;
    ImGuiTableDrawChannelIdx DrawChannelCurrent;
    ImGuiTableDrawChannelIdx DrawChannelFrozen;
    ImGuiTableDrawChannelIdx DrawChannelUnfrozen;
    bool IsEnabled;
    bool IsUserEnabled;
    bool IsUserEnabledNextFrame;
    bool IsVisibleX;
    bool IsVisibleY;
    bool IsRequestOutput;
    bool IsSkipItems;
    bool IsPreserveWidthAuto;
    ImS8 NavLayerCurrent;
    ImU8 AutoFitQueue;
    ImU8 CannotSkipItemsQueue;
    ImU8 SortDirection : 2;
    ImU8 SortDirectionsAvailCount : 2;
    ImU8 SortDirectionsAvailMask : 4;
    ImU8 SortDirectionsAvailList;

    ImGuiTableColumn()
    {
        memset(this, 0, sizeof(*this));
        StretchWeight = WidthRequest = -1.0f;
        NameOffset = -1;
        DisplayOrder = IndexWithinEnabledSet = -1;
        PrevEnabledColumn = NextEnabledColumn = -1;
        SortOrder = -1;
        SortDirection = ImGuiSortDirection_None;
        DrawChannelCurrent = DrawChannelFrozen = DrawChannelUnfrozen = (ImU8)-1;
    }
};



struct ImGuiTableCellData
{
    ImU32 BgColor;
    ImGuiTableColumnIdx Column;
};


struct ImGuiTableInstanceData
{
    float LastOuterHeight;
    float LastFirstRowHeight;

    ImGuiTableInstanceData() { LastOuterHeight = LastFirstRowHeight = 0.0f; }
};


struct ImGuiTable
{
    ImGuiID ID;
    ImGuiTableFlags Flags;
    void* RawData;
    ImGuiTableTempData* TempData;
    ImSpan<ImGuiTableColumn> Columns;
    ImSpan<ImGuiTableColumnIdx> DisplayOrderToIndex;
    ImSpan<ImGuiTableCellData> RowCellData;
    ImU64 EnabledMaskByDisplayOrder;
    ImU64 EnabledMaskByIndex;
    ImU64 VisibleMaskByIndex;
    ImU64 RequestOutputMaskByIndex;
    ImGuiTableFlags SettingsLoadedFlags;
    int SettingsOffset;
    int LastFrameActive;
    int ColumnsCount;
    int CurrentRow;
    int CurrentColumn;
    ImS16 InstanceCurrent;
    ImS16 InstanceInteracted;
    float RowPosY1;
    float RowPosY2;
    float RowMinHeight;
    float RowTextBaseline;
    float RowIndentOffsetX;
    ImGuiTableRowFlags RowFlags : 16;
    ImGuiTableRowFlags LastRowFlags : 16;
    int RowBgColorCounter;
    ImU32 RowBgColor[2];
    ImU32 BorderColorStrong;
    ImU32 BorderColorLight;
    float BorderX1;
    float BorderX2;
    float HostIndentX;
    float MinColumnWidth;
    float OuterPaddingX;
    float CellPaddingX;
    float CellPaddingY;
    float CellSpacingX1;
    float CellSpacingX2;
    float InnerWidth;
    float ColumnsGivenWidth;
    float ColumnsAutoFitWidth;
    float ColumnsStretchSumWeights;
    float ResizedColumnNextWidth;
    float ResizeLockMinContentsX2;
    float RefScale;
    ImRect OuterRect;
    ImRect InnerRect;
    ImRect WorkRect;
    ImRect InnerClipRect;
    ImRect BgClipRect;
    ImRect Bg0ClipRectForDrawCmd;
    ImRect Bg2ClipRectForDrawCmd;
    ImRect HostClipRect;
    ImRect HostBackupInnerClipRect;
    ImGuiWindow* OuterWindow;
    ImGuiWindow* InnerWindow;
    ImGuiTextBuffer ColumnsNames;
    ImDrawListSplitter* DrawSplitter;
    ImGuiTableInstanceData InstanceDataFirst;
    ImVector<ImGuiTableInstanceData> InstanceDataExtra;
    ImGuiTableColumnSortSpecs SortSpecsSingle;
    ImVector<ImGuiTableColumnSortSpecs> SortSpecsMulti;
    ImGuiTableSortSpecs SortSpecs;
    ImGuiTableColumnIdx SortSpecsCount;
    ImGuiTableColumnIdx ColumnsEnabledCount;
    ImGuiTableColumnIdx ColumnsEnabledFixedCount;
    ImGuiTableColumnIdx DeclColumnsCount;
    ImGuiTableColumnIdx HoveredColumnBody;
    ImGuiTableColumnIdx HoveredColumnBorder;
    ImGuiTableColumnIdx AutoFitSingleColumn;
    ImGuiTableColumnIdx ResizedColumn;
    ImGuiTableColumnIdx LastResizedColumn;
    ImGuiTableColumnIdx HeldHeaderColumn;
    ImGuiTableColumnIdx ReorderColumn;
    ImGuiTableColumnIdx ReorderColumnDir;
    ImGuiTableColumnIdx LeftMostEnabledColumn;
    ImGuiTableColumnIdx RightMostEnabledColumn;
    ImGuiTableColumnIdx LeftMostStretchedColumn;
    ImGuiTableColumnIdx RightMostStretchedColumn;
    ImGuiTableColumnIdx ContextPopupColumn;
    ImGuiTableColumnIdx FreezeRowsRequest;
    ImGuiTableColumnIdx FreezeRowsCount;
    ImGuiTableColumnIdx FreezeColumnsRequest;
    ImGuiTableColumnIdx FreezeColumnsCount;
    ImGuiTableColumnIdx RowCellDataCurrent;
    ImGuiTableDrawChannelIdx DummyDrawChannel;
    ImGuiTableDrawChannelIdx Bg2DrawChannelCurrent;
    ImGuiTableDrawChannelIdx Bg2DrawChannelUnfrozen;
    bool IsLayoutLocked;
    bool IsInsideRow;
    bool IsInitializing;
    bool IsSortSpecsDirty;
    bool IsUsingHeaders;
    bool IsContextPopupOpen;
    bool IsSettingsRequestLoad;
    bool IsSettingsDirty;
    bool IsDefaultDisplayOrder;
    bool IsResetAllRequest;
    bool IsResetDisplayOrderRequest;
    bool IsUnfrozenRows;
    bool IsDefaultSizingPolicy;
    bool MemoryCompacted;
    bool HostSkipItems;

    ImGuiTable() { memset(this, 0, sizeof(*this)); LastFrameActive = -1; }
    ~ImGuiTable() { ImGui::MemFree(RawData); }
};




struct ImGuiTableTempData
{
    int TableIndex;
    float LastTimeActive;

    ImVec2 UserOuterSize;
    ImDrawListSplitter DrawSplitter;

    ImRect HostBackupWorkRect;
    ImRect HostBackupParentWorkRect;
    ImVec2 HostBackupPrevLineSize;
    ImVec2 HostBackupCurrLineSize;
    ImVec2 HostBackupCursorMaxPos;
    ImVec1 HostBackupColumnsOffset;
    float HostBackupItemWidth;
    int HostBackupItemWidthStackSize;

    ImGuiTableTempData() { memset(this, 0, sizeof(*this)); LastTimeActive = -1.0f; }
};


struct ImGuiTableColumnSettings
{
    float WidthOrWeight;
    ImGuiID UserID;
    ImGuiTableColumnIdx Index;
    ImGuiTableColumnIdx DisplayOrder;
    ImGuiTableColumnIdx SortOrder;
    ImU8 SortDirection : 2;
    ImU8 IsEnabled : 1;
    ImU8 IsStretch : 1;

    ImGuiTableColumnSettings()
    {
        WidthOrWeight = 0.0f;
        UserID = 0;
        Index = -1;
        DisplayOrder = SortOrder = -1;
        SortDirection = ImGuiSortDirection_None;
        IsEnabled = 1;
        IsStretch = 0;
    }
};


struct ImGuiTableSettings
{
    ImGuiID ID;
    ImGuiTableFlags SaveFlags;
    float RefScale;
    ImGuiTableColumnIdx ColumnsCount;
    ImGuiTableColumnIdx ColumnsCountMax;
    bool WantApply;

    ImGuiTableSettings() { memset(this, 0, sizeof(*this)); }
    ImGuiTableColumnSettings* GetColumnSettings() { return (ImGuiTableColumnSettings*)(this + 1); }
};






namespace ImGui
{





    inline ImGuiWindow* GetCurrentWindowRead() { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
    inline ImGuiWindow* GetCurrentWindow() { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
    ImGuiWindow* FindWindowByID(ImGuiID id);
    ImGuiWindow* FindWindowByName(const char* name);
    void UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
    ImVec2 CalcWindowNextAutoFitSize(ImGuiWindow* window);
    bool IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy);
    bool IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
    bool IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below);
    bool IsWindowNavFocusable(ImGuiWindow* window);
    void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond = 0);
    void SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size);
    inline ImRect WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }
    inline ImRect WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }


    void FocusWindow(ImGuiWindow* window);
    void FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window);
    void BringWindowToFocusFront(ImGuiWindow* window);
    void BringWindowToDisplayFront(ImGuiWindow* window);
    void BringWindowToDisplayBack(ImGuiWindow* window);
    void BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* above_window);
    int FindWindowDisplayIndex(ImGuiWindow* window);
    ImGuiWindow* FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* window);


    void SetCurrentFont(ImFont* font);
    inline ImFont* GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
    inline ImDrawList* GetForegroundDrawList(ImGuiWindow* window) { ((void)(window)); return GetForegroundDrawList(); }
    ImDrawList* GetBackgroundDrawList(ImGuiViewport* viewport);
    ImDrawList* GetForegroundDrawList(ImGuiViewport* viewport);


    void Initialize();
    void Shutdown();


    void UpdateInputEvents(bool trickle_fast_inputs);
    void UpdateHoveredWindowAndCaptureFlags();
    void StartMouseMovingWindow(ImGuiWindow* window);
    void UpdateMouseMovingWindowNewFrame();
    void UpdateMouseMovingWindowEndFrame();


    ImGuiID AddContextHook(ImGuiContext* context, const ImGuiContextHook* hook);
    void RemoveContextHook(ImGuiContext* context, ImGuiID hook_to_remove);
    void CallContextHooks(ImGuiContext* context, ImGuiContextHookType type);


    void SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport);


    void MarkIniSettingsDirty();
    void MarkIniSettingsDirty(ImGuiWindow* window);
    void ClearIniSettings();
    ImGuiWindowSettings* CreateNewWindowSettings(const char* name);
    ImGuiWindowSettings* FindWindowSettings(ImGuiID id);
    ImGuiWindowSettings* FindOrCreateWindowSettings(const char* name);
    void AddSettingsHandler(const ImGuiSettingsHandler* handler);
    void RemoveSettingsHandler(const char* type_name);
    ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);


    void LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count);
    inline const char* LocalizeGetMsg(ImGuiLocKey key) { ImGuiContext& g = *GImGui; const char* msg = g.LocalizationTable[key]; return msg ? msg : "*Missing Text*"; }


    void SetScrollX(ImGuiWindow* window, float scroll_x);
    void SetScrollY(ImGuiWindow* window, float scroll_y);
    void SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio);
    void SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio);


    void ScrollToItem(ImGuiScrollFlags flags = 0);
    void ScrollToRect(ImGuiWindow* window, const ImRect& rect, ImGuiScrollFlags flags = 0);
    ImVec2 ScrollToRectEx(ImGuiWindow* window, const ImRect& rect, ImGuiScrollFlags flags = 0);

    inline void ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect) { ScrollToRect(window, rect, ImGuiScrollFlags_KeepVisibleEdgeY); }



    inline ImGuiID GetItemID() { ImGuiContext& g = *GImGui; return g.LastItemData.ID; }
    inline ImGuiItemStatusFlags GetItemStatusFlags(){ ImGuiContext& g = *GImGui; return g.LastItemData.StatusFlags; }
    inline ImGuiItemFlags GetItemFlags() { ImGuiContext& g = *GImGui; return g.LastItemData.InFlags; }
    inline ImGuiID GetActiveID() { ImGuiContext& g = *GImGui; return g.ActiveId; }
    inline ImGuiID GetFocusID() { ImGuiContext& g = *GImGui; return g.NavId; }
    void SetActiveID(ImGuiID id, ImGuiWindow* window);
    void SetFocusID(ImGuiID id, ImGuiWindow* window);
    void ClearActiveID();
    ImGuiID GetHoveredID();
    void SetHoveredID(ImGuiID id);
    void KeepAliveID(ImGuiID id);
    void MarkItemEdited(ImGuiID id);
    void PushOverrideID(ImGuiID id);
    ImGuiID GetIDWithSeed(const char* str_id_begin, const char* str_id_end, ImGuiID seed);


    void ItemSize(const ImVec2& size, float text_baseline_y = -1.0f);
    inline void ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); }
    bool ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = 
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                        __null
# 2800 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                            , ImGuiItemFlags extra_flags = 0);
    bool ItemHoverable(const ImRect& bb, ImGuiID id);
    bool IsClippedEx(const ImRect& bb, ImGuiID id);
    void SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags status_flags, const ImRect& item_rect);
    ImVec2 CalcItemSize(ImVec2 size, float default_w, float default_h);
    float CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
    void PushMultiItemsWidths(int components, float width_full);
    bool IsItemToggledSelection();
    ImVec2 GetContentRegionMaxAbs();
    void ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess);


    void PushItemFlag(ImGuiItemFlags option, bool enabled);
    void PopItemFlag();


    void LogBegin(ImGuiLogType type, int auto_open_depth);
    void LogToBuffer(int auto_open_depth = -1);
    void LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = 
# 2818 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                           __null
# 2818 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                               );
    void LogSetNextTextDecoration(const char* prefix, const char* suffix);


    bool BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);
    void OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags_None);
    void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);
    void ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);
    void ClosePopupsExceptModals();
    bool IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags);
    bool BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
    void BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags);
    ImRect GetPopupAllowedExtentRect(ImGuiWindow* window);
    ImGuiWindow* GetTopMostPopupModal();
    ImGuiWindow* GetTopMostAndVisiblePopupModal();
    ImVec2 FindBestWindowPosForPopup(ImGuiWindow* window);
    ImVec2 FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy);


    bool BeginViewportSideBar(const char* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags);
    bool BeginMenuEx(const char* label, const char* icon, bool enabled = true);
    bool MenuItemEx(const char* label, const char* icon, const char* shortcut = 
# 2839 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                  __null
# 2839 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                      , bool selected = false, bool enabled = true);


    bool BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags);
    bool BeginComboPreview();
    void EndComboPreview();


    void NavInitWindow(ImGuiWindow* window, bool force_reinit);
    void NavInitRequestApplyResult();
    bool NavMoveRequestButNoResultYet();
    void NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);
    void NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);
    void NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result);
    void NavMoveRequestCancel();
    void NavMoveRequestApplyResult();
    void NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
    void ActivateItem(ImGuiID id);
    void SetNavWindow(ImGuiWindow* window);
    void SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel);



    inline bool IsNamedKey(ImGuiKey key) { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }
    inline bool IsNamedKeyOrModKey(ImGuiKey key) { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super; }
    inline bool IsLegacyKey(ImGuiKey key) { return key >= 0 && key < 512; }
    inline bool IsKeyboardKey(ImGuiKey key) { return key >= (ImGuiKey_NamedKey_BEGIN) && key < (ImGuiKey_GamepadStart); }
    inline bool IsGamepadKey(ImGuiKey key) { return key >= (ImGuiKey_GamepadStart) && key < (ImGuiKey_GamepadRStickDown + 1); }
    inline bool IsMouseKey(ImGuiKey key) { return key >= (ImGuiKey_MouseLeft) && key < (ImGuiKey_MouseWheelY + 1); }
    inline bool IsAliasKey(ImGuiKey key) { return key >= ((ImGuiKey_MouseLeft)) && key < ((ImGuiKey_MouseWheelY + 1)); }
    inline ImGuiKey ConvertSingleModFlagToKey(ImGuiKey key)
    {
        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;
        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;
        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;
        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;
        return key;
    }

    ImGuiKeyData* GetKeyData(ImGuiKey key);
    void GetKeyChordName(ImGuiKeyChord key_chord, char* out_buf, int out_buf_size);
    inline ImGuiKey MouseButtonToKey(ImGuiMouseButton button) { 
# 2880 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         (static_cast <bool> (
# 2880 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         button >= 0 && button < ImGuiMouseButton_COUNT
# 2880 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         ) ? void (0) : __assert_fail (
# 2880 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         "button >= 0 && button < ImGuiMouseButton_COUNT"
# 2880 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 2880, __extension__ __PRETTY_FUNCTION__))
# 2880 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                  ; return (ImGuiKey)(ImGuiKey_MouseLeft + button); }
    bool IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold = -1.0f);
    ImVec2 GetKeyVector2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down);
    float GetNavTweakPressedAmount(ImGuiAxis axis);
    int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);
    void GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeat_delay, float* repeat_rate);
    void SetActiveIdUsingAllKeyboardKeys();
    inline bool IsActiveIdUsingNavDir(ImGuiDir dir) { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }
# 2900 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
    ImGuiID GetKeyOwner(ImGuiKey key);
    void SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
    void SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags = 0);
    bool TestKeyOwner(ImGuiKey key, ImGuiID owner_id);
    inline ImGuiKeyOwnerData* GetKeyOwnerData(ImGuiKey key) { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(key); 
# 2904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                   (static_cast <bool> (
# 2904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                   IsNamedKey(key)
# 2904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                   ) ? void (0) : __assert_fail (
# 2904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                   "IsNamedKey(key)"
# 2904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 2904, __extension__ __PRETTY_FUNCTION__))
# 2904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                             ; return &GImGui->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }







    bool IsKeyDown(ImGuiKey key, ImGuiID owner_id);
    bool IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
    bool IsKeyReleased(ImGuiKey key, ImGuiID owner_id);
    bool IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id);
    bool IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);
    bool IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id);
# 2929 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
    bool Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
    bool SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
    bool TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id);
    ImGuiKeyRoutingData* GetShortcutRoutingData(ImGuiKeyChord key_chord);
# 2942 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
    void PushFocusScope(ImGuiID id);
    void PopFocusScope();
    inline ImGuiID GetCurrentFocusScope() { ImGuiContext& g = *GImGui; return g.CurrentFocusScopeId; }


    bool IsDragDropActive();
    bool BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
    void ClearDragDrop();
    bool IsDragDropPayloadBeingAccepted();
    void RenderDragDropTargetRect(const ImRect& bb);


    void SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect);
    void BeginColumns(const char* str_id, int count, ImGuiOldColumnFlags flags = 0);
    void EndColumns();
    void PushColumnClipRect(int column_index);
    void PushColumnsBackground();
    void PopColumnsBackground();
    ImGuiID GetColumnsID(const char* str_id, int count);
    ImGuiOldColumns* FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);
    float GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm);
    float GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset);


    void TableOpenContextMenu(int column_n = -1);
    void TableSetColumnWidth(int column_n, float width);
    void TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs);
    int TableGetHoveredColumn();
    float TableGetHeaderRowHeight();
    void TablePushBackgroundChannel();
    void TablePopBackgroundChannel();


    inline ImGuiTable* GetCurrentTable() { ImGuiContext& g = *GImGui; return g.CurrentTable; }
    ImGuiTable* TableFindByID(ImGuiID id);
    bool BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0, 0), float inner_width = 0.0f);
    void TableBeginInitMemory(ImGuiTable* table, int columns_count);
    void TableBeginApplyRequests(ImGuiTable* table);
    void TableSetupDrawChannels(ImGuiTable* table);
    void TableUpdateLayout(ImGuiTable* table);
    void TableUpdateBorders(ImGuiTable* table);
    void TableUpdateColumnsWeightFromWidth(ImGuiTable* table);
    void TableDrawBorders(ImGuiTable* table);
    void TableDrawContextMenu(ImGuiTable* table);
    bool TableBeginContextMenuPopup(ImGuiTable* table);
    void TableMergeDrawChannels(ImGuiTable* table);
    inline ImGuiTableInstanceData* TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }
    void TableSortSpecsSanitize(ImGuiTable* table);
    void TableSortSpecsBuild(ImGuiTable* table);
    ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn* column);
    void TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column);
    float TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column);
    void TableBeginRow(ImGuiTable* table);
    void TableEndRow(ImGuiTable* table);
    void TableBeginCell(ImGuiTable* table, int column_n);
    void TableEndCell(ImGuiTable* table);
    ImRect TableGetCellBgRect(const ImGuiTable* table, int column_n);
    const char* TableGetColumnName(const ImGuiTable* table, int column_n);
    ImGuiID TableGetColumnResizeID(const ImGuiTable* table, int column_n, int instance_no = 0);
    float TableGetMaxColumnWidth(const ImGuiTable* table, int column_n);
    void TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n);
    void TableSetColumnWidthAutoAll(ImGuiTable* table);
    void TableRemove(ImGuiTable* table);
    void TableGcCompactTransientBuffers(ImGuiTable* table);
    void TableGcCompactTransientBuffers(ImGuiTableTempData* table);
    void TableGcCompactSettings();


    void TableLoadSettings(ImGuiTable* table);
    void TableSaveSettings(ImGuiTable* table);
    void TableResetSettings(ImGuiTable* table);
    ImGuiTableSettings* TableGetBoundSettings(ImGuiTable* table);
    void TableSettingsAddSettingsHandler();
    ImGuiTableSettings* TableSettingsCreate(ImGuiID id, int columns_count);
    ImGuiTableSettings* TableSettingsFindByID(ImGuiID id);


    bool BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);
    ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    void TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    void TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    void TabBarQueueReorder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int offset);
    void TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, ImVec2 mouse_pos);
    bool TabBarProcessReorder(ImGuiTabBar* tab_bar);
    bool TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);
    ImVec2 TabItemCalcSize(const char* label, bool has_close_button_or_unsaved_marker);
    void TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);
    void TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped);




    void RenderText(ImVec2 pos, const char* text, const char* text_end = 
# 3034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                           __null
# 3034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                               , bool hide_text_after_hash = true);
    void RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
    void RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = 
# 3036 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                                                   __null
# 3036 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                                                       );
    void RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = 
# 3037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                                                                            __null
# 3037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                                                                                );
    void RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end, const ImVec2* text_size_if_known);
    void RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
    void RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
    void RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, ImDrawFlags flags = 0);
    void RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault);
    const char* FindRenderedTextEnd(const char* text, const char* text_end = 
# 3043 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                        __null
# 3043 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                            );
    void RenderMouseCursor(ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow);


    void RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale = 1.0f);
    void RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col);
    void RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz);
    void RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
    void RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
    void RenderRectFilledWithHole(ImDrawList* draw_list, const ImRect& outer, const ImRect& inner, ImU32 col, float rounding);


    void TextEx(const char* text, const char* text_end = 
# 3055 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                           __null
# 3055 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                               , ImGuiTextFlags flags = 0);
    bool ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0, 0), ImGuiButtonFlags flags = 0);
    bool CloseButton(ImGuiID id, const ImVec2& pos);
    bool CollapseButton(ImGuiID id, const ImVec2& pos);
    bool ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags = 0);
    void Scrollbar(ImGuiAxis axis);
    bool ScrollbarEx(const ImRect& bb, ImGuiID id, ImGuiAxis axis, ImS64* p_scroll_v, ImS64 avail_v, ImS64 contents_v, ImDrawFlags flags);
    bool ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col);
    ImRect GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis);
    ImGuiID GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);
    ImGuiID GetWindowResizeCornerID(ImGuiWindow* window, int n);
    ImGuiID GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir);
    void SeparatorEx(ImGuiSeparatorFlags flags);
    bool CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value);
    bool CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value);


    bool ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
    bool DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags);
    bool SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    bool SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f);
    bool TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = 
# 3076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                             __null
# 3076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                 );
    void TreePushOverrideID(ImGuiID id);
    void TreeNodeSetOpen(ImGuiID id, bool open);
    bool TreeNodeUpdateNextOpen(ImGuiID id, ImGuiTreeNodeFlags flags);




    template<typename T, typename SIGNED_T, typename FLOAT_T> float ScaleRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);
    template<typename T, typename SIGNED_T, typename FLOAT_T> T ScaleValueFromRatioT(ImGuiDataType data_type, float t, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);
    template<typename T, typename SIGNED_T, typename FLOAT_T> bool DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, ImGuiSliderFlags flags);
    template<typename T, typename SIGNED_T, typename FLOAT_T> bool SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    template<typename T> T RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);
    template<typename T> bool CheckboxFlagsT(const char* label, T* flags, T flags_value);


    const ImGuiDataTypeInfo* DataTypeGetInfo(ImGuiDataType data_type);
    int DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format);
    void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg_1, const void* arg_2);
    bool DataTypeApplyFromText(const char* buf, ImGuiDataType data_type, void* p_data, const char* format);
    int DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2);
    bool DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max);


    bool InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = 
# 3100 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                          __null
# 3100 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                              , void* user_data = 
# 3100 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                                  __null
# 3100 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                                      );
    bool TempInputText(const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags);
    bool TempInputScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min = 
# 3102 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                 __null
# 3102 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                     , const void* p_clamp_max = 
# 3102 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                                                                 __null
# 3102 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                                                                     );
    inline bool TempInputIsActive(ImGuiID id) { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }
    inline ImGuiInputTextState* GetInputTextState(ImGuiID id) { ImGuiContext& g = *GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : 
# 3104 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                                                                                __null
# 3104 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                                                                    ; }


    void ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
    void ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
    void ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);


    int PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size);


    void ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
    void ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);


    void GcCompactTransientMiscBuffers();
    void GcCompactTransientWindowBuffers(ImGuiWindow* window);
    void GcAwakeTransientWindowBuffers(ImGuiWindow* window);


    void DebugLog(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void DebugLogV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));


    void ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data = 
# 3128 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                           __null
# 3128 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                               );
    void ErrorCheckEndWindowRecover(ImGuiErrorLogCallback log_callback, void* user_data = 
# 3129 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                                            __null
# 3129 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                );
    void ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    void DebugLocateItem(ImGuiID target_id);
    void DebugLocateItemOnHover(ImGuiID target_id);
    void DebugLocateItemResolveWithLastItem();
    inline void DebugDrawItemRect(ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(0)<<8) | ((ImU32)(255)<<0))) { ImGuiContext& g = *GImGui; ImGuiWindow* window = g.CurrentWindow; GetForegroundDrawList(window)->AddRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col); }
    inline void DebugStartItemPicker() { ImGuiContext& g = *GImGui; g.DebugItemPickerActive = true; }
    void ShowFontAtlas(ImFontAtlas* atlas);
    void DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void* data_id, const void* data_id_end);
    void DebugNodeColumns(ImGuiOldColumns* columns);
    void DebugNodeDrawList(ImGuiWindow* window, const ImDrawList* draw_list, const char* label);
    void DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb);
    void DebugNodeFont(ImFont* font);
    void DebugNodeFontGlyph(ImFont* font, const ImFontGlyph* glyph);
    void DebugNodeStorage(ImGuiStorage* storage, const char* label);
    void DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label);
    void DebugNodeTable(ImGuiTable* table);
    void DebugNodeTableSettings(ImGuiTableSettings* settings);
    void DebugNodeInputTextState(ImGuiInputTextState* state);
    void DebugNodeWindow(ImGuiWindow* window, const char* label);
    void DebugNodeWindowSettings(ImGuiWindowSettings* settings);
    void DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label);
    void DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windows_size, ImGuiWindow* parent_in_begin_stack);
    void DebugNodeViewport(ImGuiViewportP* viewport);
    void DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb);



    inline void SetItemUsingMouseWheel() { SetItemKeyOwner(ImGuiKey_MouseWheelY); }
    inline bool TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0) { return TreeNodeUpdateNextOpen(id, flags); }






    inline bool FocusableItemRegister(ImGuiWindow* window, ImGuiID id) { 
# 3165 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         (static_cast <bool> (
# 3165 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         0
# 3165 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         ) ? void (0) : __assert_fail (
# 3165 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         "0"
# 3165 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 3165, __extension__ __PRETTY_FUNCTION__))
# 3165 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                     ; ((void)(window)); ((void)(id)); return false; }
    inline void FocusableItemUnregister(ImGuiWindow* window) { 
# 3166 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         (static_cast <bool> (
# 3166 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         0
# 3166 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         ) ? void (0) : __assert_fail (
# 3166 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         "0"
# 3166 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 3166, __extension__ __PRETTY_FUNCTION__))
# 3166 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                     ; ((void)(window)); }


    inline bool IsKeyPressedMap(ImGuiKey key, bool repeat = true) { 
# 3169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         (static_cast <bool> (
# 3169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         IsNamedKey(key)
# 3169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         ) ? void (0) : __assert_fail (
# 3169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                         "IsNamedKey(key)"
# 3169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h" 3 4
                                                                                         , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h", 3169, __extension__ __PRETTY_FUNCTION__))
# 3169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
                                                                                                                   ; return IsKeyPressed(key, repeat); }


}







struct ImFontBuilderIO
{
    bool (*FontBuilder_Build)(ImFontAtlas* atlas);
};



 const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype();

 void ImFontAtlasBuildInit(ImFontAtlas* atlas);
 void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
 void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);
 void ImFontAtlasBuildFinish(ImFontAtlas* atlas);
 void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value);
 void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value);
 void ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
 void ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);
# 3221 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/include/imgui_internal.h"
#pragma GCC diagnostic pop
# 863 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 2






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 3 4

# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 2 3 4
# 870 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 2
# 935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
#pragma GCC diagnostic ignored "-Wformat"
#pragma GCC diagnostic ignored "-Wdouble-promotion"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wformat-nonliteral"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#pragma GCC diagnostic ignored "-Wclass-memaccess"
# 952 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"

# 952 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static const float NAV_WINDOWING_HIGHLIGHT_DELAY = 0.20f;
static const float NAV_WINDOWING_LIST_APPEAR_DELAY = 0.15f;


static const float WINDOWS_HOVER_PADDING = 4.0f;
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;
static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER = 0.70f;





static void SetCurrentWindow(ImGuiWindow* window);
static void FindHoveredWindow();
static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags);
static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window);

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);


static void WindowSettingsHandler_ClearAll(ImGuiContext*, ImGuiSettingsHandler*);
static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name);
static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line);
static void WindowSettingsHandler_ApplyAll(ImGuiContext*, ImGuiSettingsHandler*);
static void WindowSettingsHandler_WriteAll(ImGuiContext*, ImGuiSettingsHandler*, ImGuiTextBuffer* buf);


static const char* GetClipboardTextFn_DefaultImpl(void* user_data);
static void SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void SetPlatformImeDataFn_DefaultImpl(ImGuiViewport* viewport, ImGuiPlatformImeData* data);

namespace ImGui
{

static void NavUpdate();
static void NavUpdateWindowing();
static void NavUpdateWindowingOverlay();
static void NavUpdateCancelRequest();
static void NavUpdateCreateMoveRequest();
static void NavUpdateCreateTabbingRequest();
static float NavUpdatePageUpPageDown();
static inline void NavUpdateAnyRequestFlag();
static void NavUpdateCreateWrappingRequest();
static void NavEndFrame();
static bool NavScoreItem(ImGuiNavItemData* result);
static void NavApplyItemToResult(ImGuiNavItemData* result);
static void NavProcessItem();
static void NavProcessItemForTabbingRequest(ImGuiID id);
static ImVec2 NavCalcPreferredRefPos();
static void NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window);
static ImGuiWindow* NavRestoreLastChildNavWindow(ImGuiWindow* window);
static void NavRestoreLayer(ImGuiNavLayer layer);
static void NavRestoreHighlightAfterMove();
static int FindWindowFocusIndex(ImGuiWindow* window);


static void ErrorCheckNewFrameSanityChecks();
static void ErrorCheckEndFrameSanityChecks();
static void UpdateDebugToolItemPicker();
static void UpdateDebugToolStackQueries();


static void UpdateSettings();
static void UpdateKeyboardInputs();
static void UpdateMouseInputs();
static void UpdateMouseWheel();
static bool UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect);
static void RenderWindowOuterBorders(ImGuiWindow* window);
static void RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size);
static void RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open);
static void RenderDimmedBackgroundBehindWindow(ImGuiWindow* window, ImU32 col);
static void RenderDimmedBackgrounds();
static ImGuiWindow* FindBlockingModal(ImGuiWindow* window);


static void UpdateViewportsNewFrame();

}
# 1057 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
ImGuiContext* GImGui = 
# 1057 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        __null
# 1057 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            ;






static void* MallocWrapper(size_t size, void* user_data) { ((void)(user_data)); return malloc(size); }
static void FreeWrapper(void* ptr, void* user_data) { ((void)(user_data)); free(ptr); }




static ImGuiMemAllocFunc GImAllocatorAllocFunc = MallocWrapper;
static ImGuiMemFreeFunc GImAllocatorFreeFunc = FreeWrapper;
static void* GImAllocatorUserData = 
# 1072 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  __null
# 1072 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      ;





ImGuiStyle::ImGuiStyle()
{
    Alpha = 1.0f;
    DisabledAlpha = 0.60f;
    WindowPadding = ImVec2(8,8);
    WindowRounding = 0.0f;
    WindowBorderSize = 1.0f;
    WindowMinSize = ImVec2(32,32);
    WindowTitleAlign = ImVec2(0.0f,0.5f);
    WindowMenuButtonPosition= ImGuiDir_Left;
    ChildRounding = 0.0f;
    ChildBorderSize = 1.0f;
    PopupRounding = 0.0f;
    PopupBorderSize = 1.0f;
    FramePadding = ImVec2(4,3);
    FrameRounding = 0.0f;
    FrameBorderSize = 0.0f;
    ItemSpacing = ImVec2(8,4);
    ItemInnerSpacing = ImVec2(4,4);
    CellPadding = ImVec2(4,2);
    TouchExtraPadding = ImVec2(0,0);
    IndentSpacing = 21.0f;
    ColumnsMinSpacing = 6.0f;
    ScrollbarSize = 14.0f;
    ScrollbarRounding = 9.0f;
    GrabMinSize = 12.0f;
    GrabRounding = 0.0f;
    LogSliderDeadzone = 4.0f;
    TabRounding = 4.0f;
    TabBorderSize = 0.0f;
    TabMinWidthForCloseButton = 0.0f;
    ColorButtonPosition = ImGuiDir_Right;
    ButtonTextAlign = ImVec2(0.5f,0.5f);
    SelectableTextAlign = ImVec2(0.0f,0.0f);
    DisplayWindowPadding = ImVec2(19,19);
    DisplaySafeAreaPadding = ImVec2(3,3);
    MouseCursorScale = 1.0f;
    AntiAliasedLines = true;
    AntiAliasedLinesUseTex = true;
    AntiAliasedFill = true;
    CurveTessellationTol = 1.25f;
    CircleTessellationMaxError = 0.30f;


    ImGui::StyleColorsDark(this);
}



void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    CellPadding = ImFloor(CellPadding * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    LogSliderDeadzone = ImFloor(LogSliderDeadzone * scale_factor);
    TabRounding = ImFloor(TabRounding * scale_factor);
    TabMinWidthForCloseButton = (TabMinWidthForCloseButton != 3.40282346638528859811704183484516925e+38F) ? ImFloor(TabMinWidthForCloseButton * scale_factor) : 3.40282346638528859811704183484516925e+38F;
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{

    memset(this, 0, sizeof(*this));
    static_assert(((int)(sizeof(ImGuiIO::MouseDown) / sizeof(*(ImGuiIO::MouseDown)))) == ImGuiMouseButton_COUNT && ((int)(sizeof(ImGuiIO::MouseClicked) / sizeof(*(ImGuiIO::MouseClicked)))) == ImGuiMouseButton_COUNT, "");


    ConfigFlags = ImGuiConfigFlags_None;
    BackendFlags = ImGuiBackendFlags_None;
    DisplaySize = ImVec2(-1.0f, -1.0f);
    DeltaTime = 1.0f / 60.0f;
    IniSavingRate = 5.0f;
    IniFilename = "imgui.ini";
    LogFilename = "imgui_log.txt";
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;

    for (int i = 0; i < ImGuiKey_COUNT; i++)
        KeyMap[i] = -1;

    KeyRepeatDelay = 0.275f;
    KeyRepeatRate = 0.050f;
    HoverDelayNormal = 0.30f;
    HoverDelayShort = 0.10f;
    UserData = 
# 1178 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1178 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;

    Fonts = 
# 1180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           __null
# 1180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
    FontGlobalScale = 1.0f;
    FontDefault = 
# 1182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                 __null
# 1182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);


    MouseDrawCursor = false;



    ConfigMacOSXBehaviors = false;

    ConfigInputTrickleEventQueue = true;
    ConfigInputTextCursorBlink = true;
    ConfigInputTextEnterKeepActive = false;
    ConfigDragClickToInputText = false;
    ConfigWindowsResizeFromEdges = true;
    ConfigWindowsMoveFromTitleBarOnly = false;
    ConfigMemoryCompactTimer = 60.0f;


    BackendPlatformName = BackendRendererName = 
# 1202 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                               __null
# 1202 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   ;
    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = 
# 1203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                 __null
# 1203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                     ;
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = 
# 1206 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                       __null
# 1206 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;
    SetPlatformImeDataFn = SetPlatformImeDataFn_DefaultImpl;


    MousePos = ImVec2(-3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    MousePosPrev = ImVec2(-3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < ((int)(sizeof(MouseDownDuration) / sizeof(*(MouseDownDuration)))); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < ((int)(sizeof(KeysData) / sizeof(*(KeysData)))); i++) { KeysData[i].DownDuration = KeysData[i].DownDurationPrev = -1.0f; }
    AppAcceptingEvents = true;
    BackendUsingLegacyKeyArrays = (ImS8)-1;
    BackendUsingLegacyNavInputArray = true;
}





void ImGuiIO::AddInputCharacter(unsigned int c)
{
    ImGuiContext& g = *GImGui;
    
# 1227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   &g.IO == this && "Can only add events to current context."
# 1227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "&g.IO == this && \"Can only add events to current context.\""
# 1227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1227, __extension__ __PRETTY_FUNCTION__))
# 1227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;
    if (c == 0 || !AppAcceptingEvents)
        return;

    ImGuiInputEvent e;
    e.Type = ImGuiInputEventType_Text;
    e.Source = ImGuiInputSource_Keyboard;
    e.Text.Char = c;
    g.InputEventsQueue.push_back(e);
}



void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)
{
    if ((c == 0 && InputQueueSurrogate == 0) || !AppAcceptingEvents)
        return;

    if ((c & 0xFC00) == 0xD800)
    {
        if (InputQueueSurrogate != 0)
            AddInputCharacter(0xFFFD);
        InputQueueSurrogate = c;
        return;
    }

    ImWchar cp = c;
    if (InputQueueSurrogate != 0)
    {
        if ((c & 0xFC00) != 0xDC00)
        {
            AddInputCharacter(0xFFFD);
        }
        else
        {

            cp = 0xFFFD;



        }

        InputQueueSurrogate = 0;
    }
    AddInputCharacter((unsigned)cp);
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    if (!AppAcceptingEvents)
        return;
    while (*utf8_chars != 0)
    {
        unsigned int c = 0;
        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, 
# 1281 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                        __null
# 1281 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            );
        if (c != 0)
            AddInputCharacter(c);
    }
}


void ImGuiIO::ClearInputCharacters()
{
    InputQueueCharacters.resize(0);
}


void ImGuiIO::ClearInputKeys()
{

    memset(KeysDown, 0, sizeof(KeysDown));

    for (int n = 0; n < ((int)(sizeof(KeysData) / sizeof(*(KeysData)))); n++)
    {
        KeysData[n].Down = false;
        KeysData[n].DownDuration = -1.0f;
        KeysData[n].DownDurationPrev = -1.0f;
    }
    KeyCtrl = KeyShift = KeyAlt = KeySuper = false;
    KeyMods = ImGuiMod_None;
    MousePos = ImVec2(-3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    for (int n = 0; n < ((int)(sizeof(MouseDown) / sizeof(*(MouseDown)))); n++)
    {
        MouseDown[n] = false;
        MouseDownDuration[n] = MouseDownDurationPrev[n] = -1.0f;
    }
    MouseWheel = MouseWheelH = 0.0f;
}

static ImGuiInputEvent* FindLatestInputEvent(ImGuiInputEventType type, int arg = -1)
{
    ImGuiContext& g = *GImGui;
    for (int n = g.InputEventsQueue.Size - 1; n >= 0; n--)
    {
        ImGuiInputEvent* e = &g.InputEventsQueue[n];
        if (e->Type != type)
            continue;
        if (type == ImGuiInputEventType_Key && e->Key.Key != arg)
            continue;
        if (type == ImGuiInputEventType_MouseButton && e->MouseButton.Button != arg)
            continue;
        return e;
    }
    return 
# 1330 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 1330 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}





void ImGuiIO::AddKeyAnalogEvent(ImGuiKey key, bool down, float analog_value)
{

    if (key == ImGuiKey_None || !AppAcceptingEvents)
        return;
    ImGuiContext& g = *GImGui;
    
# 1343 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1343 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   &g.IO == this && "Can only add events to current context."
# 1343 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1343 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "&g.IO == this && \"Can only add events to current context.\""
# 1343 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1343, __extension__ __PRETTY_FUNCTION__))
# 1343 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;
    
# 1344 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1344 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   ImGui::IsNamedKeyOrModKey(key)
# 1344 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1344 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "ImGui::IsNamedKeyOrModKey(key)"
# 1344 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1344, __extension__ __PRETTY_FUNCTION__))
# 1344 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            ;
    
# 1345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   !ImGui::IsAliasKey(key)
# 1345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "!ImGui::IsAliasKey(key)"
# 1345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1345, __extension__ __PRETTY_FUNCTION__))
# 1345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                     ;



    
# 1349 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1349 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!"
# 1349 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1349 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(BackendUsingLegacyKeyArrays == -1 || BackendUsingLegacyKeyArrays == 0) && \"Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!\""
# 1349 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1349, __extension__ __PRETTY_FUNCTION__))
# 1349 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                                                            ;
    if (BackendUsingLegacyKeyArrays == -1)
        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
            
# 1352 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 1352 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           KeyMap[n] == -1 && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!"
# 1352 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 1352 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "KeyMap[n] == -1 && \"Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!\""
# 1352 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1352, __extension__ __PRETTY_FUNCTION__))
# 1352 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                            ;
    BackendUsingLegacyKeyArrays = 0;

    if (ImGui::IsGamepadKey(key))
        BackendUsingLegacyNavInputArray = false;


    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_Key, (int)key);
    const ImGuiKeyData* key_data = ImGui::GetKeyData(key);
    const bool latest_key_down = latest_event ? latest_event->Key.Down : key_data->Down;
    const float latest_key_analog = latest_event ? latest_event->Key.AnalogValue : key_data->AnalogValue;
    if (latest_key_down == down && latest_key_analog == analog_value)
        return;


    ImGuiInputEvent e;
    e.Type = ImGuiInputEventType_Key;
    e.Source = ImGui::IsGamepadKey(key) ? ImGuiInputSource_Gamepad : ImGuiInputSource_Keyboard;
    e.Key.Key = key;
    e.Key.Down = down;
    e.Key.AnalogValue = analog_value;
    g.InputEventsQueue.push_back(e);
}

void ImGuiIO::AddKeyEvent(ImGuiKey key, bool down)
{
    if (!AppAcceptingEvents)
        return;
    AddKeyAnalogEvent(key, down, down ? 1.0f : 0.0f);
}




void ImGuiIO::SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index)
{
    if (key == ImGuiKey_None)
        return;
    
# 1390 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1390 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   ImGui::IsNamedKey(key)
# 1390 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1390 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "ImGui::IsNamedKey(key)"
# 1390 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1390, __extension__ __PRETTY_FUNCTION__))
# 1390 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;
    
# 1391 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1391 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)
# 1391 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1391 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "native_legacy_index == -1 || ImGui::IsLegacyKey((ImGuiKey)native_legacy_index)"
# 1391 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1391, __extension__ __PRETTY_FUNCTION__))
# 1391 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                            ;
    ((void)(native_keycode));
    ((void)(native_scancode));



    const int legacy_key = (native_legacy_index != -1) ? native_legacy_index : native_keycode;
    if (!ImGui::IsLegacyKey((ImGuiKey)legacy_key))
        return;
    KeyMap[legacy_key] = key;
    KeyMap[key] = legacy_key;




}


void ImGuiIO::SetAppAcceptingEvents(bool accepting_events)
{
    AppAcceptingEvents = accepting_events;
}


void ImGuiIO::AddMousePosEvent(float x, float y)
{
    ImGuiContext& g = *GImGui;
    
# 1418 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1418 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   &g.IO == this && "Can only add events to current context."
# 1418 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1418 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "&g.IO == this && \"Can only add events to current context.\""
# 1418 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1418, __extension__ __PRETTY_FUNCTION__))
# 1418 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;
    if (!AppAcceptingEvents)
        return;


    ImVec2 pos((x > -3.40282346638528859811704183484516925e+38F) ? ImFloorSigned(x) : x, (y > -3.40282346638528859811704183484516925e+38F) ? ImFloorSigned(y) : y);


    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_MousePos);
    const ImVec2 latest_pos = latest_event ? ImVec2(latest_event->MousePos.PosX, latest_event->MousePos.PosY) : g.IO.MousePos;
    if (latest_pos.x == pos.x && latest_pos.y == pos.y)
        return;

    ImGuiInputEvent e;
    e.Type = ImGuiInputEventType_MousePos;
    e.Source = ImGuiInputSource_Mouse;
    e.MousePos.PosX = pos.x;
    e.MousePos.PosY = pos.y;
    g.InputEventsQueue.push_back(e);
}

void ImGuiIO::AddMouseButtonEvent(int mouse_button, bool down)
{
    ImGuiContext& g = *GImGui;
    
# 1442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   &g.IO == this && "Can only add events to current context."
# 1442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "&g.IO == this && \"Can only add events to current context.\""
# 1442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1442, __extension__ __PRETTY_FUNCTION__))
# 1442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;
    
# 1443 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1443 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT
# 1443 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1443 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "mouse_button >= 0 && mouse_button < ImGuiMouseButton_COUNT"
# 1443 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1443, __extension__ __PRETTY_FUNCTION__))
# 1443 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;
    if (!AppAcceptingEvents)
        return;


    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_MouseButton, (int)mouse_button);
    const bool latest_button_down = latest_event ? latest_event->MouseButton.Down : g.IO.MouseDown[mouse_button];
    if (latest_button_down == down)
        return;

    ImGuiInputEvent e;
    e.Type = ImGuiInputEventType_MouseButton;
    e.Source = ImGuiInputSource_Mouse;
    e.MouseButton.Button = mouse_button;
    e.MouseButton.Down = down;
    g.InputEventsQueue.push_back(e);
}


void ImGuiIO::AddMouseWheelEvent(float wheel_x, float wheel_y)
{
    ImGuiContext& g = *GImGui;
    
# 1465 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1465 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   &g.IO == this && "Can only add events to current context."
# 1465 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1465 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "&g.IO == this && \"Can only add events to current context.\""
# 1465 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1465, __extension__ __PRETTY_FUNCTION__))
# 1465 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;


    if (!AppAcceptingEvents || (wheel_x == 0.0f && wheel_y == 0.0f))
        return;

    ImGuiInputEvent e;
    e.Type = ImGuiInputEventType_MouseWheel;
    e.Source = ImGuiInputSource_Mouse;
    e.MouseWheel.WheelX = wheel_x;
    e.MouseWheel.WheelY = wheel_y;
    g.InputEventsQueue.push_back(e);
}

void ImGuiIO::AddFocusEvent(bool focused)
{
    ImGuiContext& g = *GImGui;
    
# 1482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   &g.IO == this && "Can only add events to current context."
# 1482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "&g.IO == this && \"Can only add events to current context.\""
# 1482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1482, __extension__ __PRETTY_FUNCTION__))
# 1482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                        ;


    const ImGuiInputEvent* latest_event = FindLatestInputEvent(ImGuiInputEventType_Focus);
    const bool latest_focused = latest_event ? latest_event->AppFocused.Focused : !g.IO.AppFocusLost;
    if (latest_focused == focused)
        return;

    ImGuiInputEvent e;
    e.Type = ImGuiInputEventType_Focus;
    e.AppFocused.Focused = focused;
    g.InputEventsQueue.push_back(e);
}





ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)
{
    
# 1502 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1502 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   num_segments > 0
# 1502 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1502 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "num_segments > 0"
# 1502 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1502, __extension__ __PRETTY_FUNCTION__))
# 1502 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
    ImVec2 p_last = p1;
    ImVec2 p_closest;
    float p_closest_dist2 = 3.40282346638528859811704183484516925e+38F;
    float t_step = 1.0f / (float)num_segments;
    for (int i_step = 1; i_step <= num_segments; i_step++)
    {
        ImVec2 p_current = ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step);
        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
        float dist2 = ImLengthSqr(p - p_line);
        if (dist2 < p_closest_dist2)
        {
            p_closest = p_line;
            p_closest_dist2 = dist2;
        }
        p_last = p_current;
    }
    return p_closest;
}


static void ImBezierCubicClosestPointCasteljauStep(const ImVec2& p, ImVec2& p_closest, ImVec2& p_last, float& p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
    float dx = x4 - x1;
    float dy = y4 - y1;
    float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
    float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
    {
        ImVec2 p_current(x4, y4);
        ImVec2 p_line = ImLineClosestPoint(p_last, p_current, p);
        float dist2 = ImLengthSqr(p - p_line);
        if (dist2 < p_closest_dist2)
        {
            p_closest = p_line;
            p_closest_dist2 = dist2;
        }
        p_last = p_current;
    }
    else if (level < 10)
    {
        float x12 = (x1 + x2)*0.5f, y12 = (y1 + y2)*0.5f;
        float x23 = (x2 + x3)*0.5f, y23 = (y2 + y3)*0.5f;
        float x34 = (x3 + x4)*0.5f, y34 = (y3 + y4)*0.5f;
        float x123 = (x12 + x23)*0.5f, y123 = (y12 + y23)*0.5f;
        float x234 = (x23 + x34)*0.5f, y234 = (y23 + y34)*0.5f;
        float x1234 = (x123 + x234)*0.5f, y1234 = (y123 + y234)*0.5f;
        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
    }
}



ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol)
{
    
# 1560 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1560 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   tess_tol > 0.0f
# 1560 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1560 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "tess_tol > 0.0f"
# 1560 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1560, __extension__ __PRETTY_FUNCTION__))
# 1560 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             ;
    ImVec2 p_last = p1;
    ImVec2 p_closest;
    float p_closest_dist2 = 3.40282346638528859811704183484516925e+38F;
    ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0);
    return p_closest;
}

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
    ImVec2 ap = p - a;
    ImVec2 ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
    ImVec2 v0 = b - a;
    ImVec2 v1 = c - a;
    ImVec2 v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}






int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = ImToUpper(*str2) - ImToUpper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1)
        return;
    if (count > 1)
        strncpy(dst, src, count - 1);
    dst[count - 1] = 0;
}

char* ImStrdup(const char* str)
{
    size_t len = strlen(str);
    void* buf = ImGui::MemAlloc(len + 1);
    return (char*)memcpy(buf, (const void*)str, len + 1);
}

char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)
{
    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
    size_t src_size = strlen(src) + 1;
    if (dst_buf_size < src_size)
    {
        ImGui::MemFree(dst);
        dst = (char*)ImGui::MemAlloc(src_size);
        if (p_dst_size)
            *p_dst_size = src_size;
    }
    return (char*)memcpy(dst, (const void*)src, src_size);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    const char* p = (const char*)memchr(str, (int)c, str_end - str);
    return p;
}

int ImStrlenW(const ImWchar* str)
{

    int n = 0;
    while (*str++) n++;
    return n;
}


const char* ImStreolRange(const char* str, const char* str_end)
{
    const char* p = (const char*)memchr(str, '\n', str_end - str);
    return p ? p : str_end;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin)
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)ImToUpper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (ImToUpper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (ImToUpper(*a) != ImToUpper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return 
# 1712 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 1712 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}


void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')
        p++;
    char* p_start = p;
    while (*p != 0)
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))
        p--;
    if (p_start != buf)
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;
}

const char* ImStrSkipBlank(const char* str)
{
    while (str[0] == ' ' || str[0] == '\t')
        str++;
    return str;
}
# 1760 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    
# 1763 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_start(
# 1763 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 1763 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 1763 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   fmt
# 1763 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 1763 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;



    int w = vsnprintf(buf, buf_size, fmt, args);

    
# 1769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 1769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 1769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 1769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
    if (buf == 
# 1770 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1770 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  )
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{



    int w = vsnprintf(buf, buf_size, fmt, args);

    if (buf == 
# 1785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  )
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}


void ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    va_list args;
    
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_start(
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   fmt
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 1798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;
    int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
    *out_buf = g.TempBuffer.Data;
    if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
    
# 1802 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 1802 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 1802 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 1802 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
}

void ImFormatStringToTempBufferV(const char** out_buf, const char** out_buf_end, const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    int buf_len = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args);
    *out_buf = g.TempBuffer.Data;
    if (out_buf_end) { *out_buf_end = g.TempBuffer.Data + buf_len; }
}




static const ImU32 GCrc32LookupTable[256] =
{
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
};




ImGuiID ImHashData(const void* data_p, size_t data_size, ImU32 seed)
{
    ImU32 crc = ~seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    while (data_size-- != 0)
        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
    return ~crc;
}







ImGuiID ImHashStr(const char* data_p, size_t data_size, ImU32 seed)
{
    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    if (data_size != 0)
    {
        while (data_size-- != 0)
        {
            unsigned char c = *data++;
            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    else
    {
        while (unsigned char c = *data++)
        {
            if (c == '#' && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}
# 1890 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
ImFileHandle ImFileOpen(const char* filename, const char* mode)
{
# 1903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    return fopen(filename, mode);

}


bool ImFileClose(ImFileHandle f) { return fclose(f) == 0; }
ImU64 ImFileGetSize(ImFileHandle f) { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, 
# 1909 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                              2
# 1909 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                      ) && (sz = ftell(f)) != -1 && !fseek(f, off, 
# 1909 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                                                                   0
# 1909 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                           )) ? (ImU64)sz : (ImU64)-1; }
ImU64 ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f) { return fread(data, (size_t)sz, (size_t)count, f); }
ImU64 ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f) { return fwrite(data, (size_t)sz, (size_t)count, f); }





void* ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)
{
    
# 1919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 1919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   filename && mode
# 1919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 1919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "filename && mode"
# 1919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 1919, __extension__ __PRETTY_FUNCTION__))
# 1919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
    if (out_file_size)
        *out_file_size = 0;

    ImFileHandle f;
    if ((f = ImFileOpen(filename, mode)) == 
# 1924 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                           __null
# 1924 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               )
        return 
# 1925 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1925 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;

    size_t file_size = (size_t)ImFileGetSize(f);
    if (file_size == (size_t)-1)
    {
        ImFileClose(f);
        return 
# 1931 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1931 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;
    }

    void* file_data = ImGui::MemAlloc(file_size + padding_bytes);
    if (file_data == 
# 1935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                    __null
# 1935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        )
    {
        ImFileClose(f);
        return 
# 1938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;
    }
    if (ImFileRead(file_data, 1, file_size, f) != file_size)
    {
        ImFileClose(f);
        ImGui::MemFree(file_data);
        return 
# 1944 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 1944 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    ImFileClose(f);
    if (out_file_size)
        *out_file_size = file_size;

    return file_data;
}
# 1963 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    static const char lengths[32] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
    static const int masks[] = { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
    static const uint32_t mins[] = { 0x400000, 0, 0x80, 0x800, 0x10000 };
    static const int shiftc[] = { 0, 18, 12, 6, 0 };
    static const int shifte[] = { 0, 6, 4, 2, 0 };
    int len = lengths[*(const unsigned char*)in_text >> 3];
    int wanted = len + !len;

    if (in_text_end == 
# 1973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                      __null
# 1973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          )
        in_text_end = in_text + wanted;



    unsigned char s[4];
    s[0] = in_text + 0 < in_text_end ? in_text[0] : 0;
    s[1] = in_text + 1 < in_text_end ? in_text[1] : 0;
    s[2] = in_text + 2 < in_text_end ? in_text[2] : 0;
    s[3] = in_text + 3 < in_text_end ? in_text[3] : 0;


    *out_char = (uint32_t)(s[0] & masks[len]) << 18;
    *out_char |= (uint32_t)(s[1] & 0x3f) << 12;
    *out_char |= (uint32_t)(s[2] & 0x3f) << 6;
    *out_char |= (uint32_t)(s[3] & 0x3f) << 0;
    *out_char >>= shiftc[len];


    int e = 0;
    e = (*out_char < mins[len]) << 6;
    e |= ((*out_char >> 11) == 0x1b) << 7;
    e |= (*out_char > 0xFFFF) << 8;
    e |= (s[1] & 0xc0) >> 2;
    e |= (s[2] & 0xc0) >> 4;
    e |= (s[3] ) >> 6;
    e ^= 0x2a;
    e >>= shifte[len];

    if (e)
    {




        wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3]);
        *out_char = 0xFFFD;
    }

    return wanted;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        *buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        *in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        char_count++;
    }
    return char_count;
}


static inline int ImTextCharToUtf8_inline(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c ) & 0x3f));
        return 3;
    }
    if (c <= 0x10FFFF)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c ) & 0x3f));
        return 4;
    }

    return 0;
}

const char* ImTextCharToUtf8(char out_buf[5], unsigned int c)
{
    int count = ImTextCharToUtf8_inline(out_buf, 5, c);
    out_buf[count] = 0;
    return out_buf;
}


int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int unused = 0;
    return ImTextCharFromUtf8(&unused, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c < 0x10000) return 3;
    if (c <= 0x10FFFF) return 4;
    return 3;
}

int ImTextStrToUtf8(char* out_buf, int out_buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
    char* buf_p = out_buf;
    const char* buf_end = out_buf + out_buf_size;
    while (buf_p < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            *buf_p++ = (char)c;
        else
            buf_p += ImTextCharToUtf8_inline(buf_p, (int)(buf_end - buf_p - 1), c);
    }
    *buf_p = 0;
    return (int)(buf_p - out_buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}






 ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b)
{
    float t = ((col_b >> 24) & 0xFF) / 255.f;
    int r = ImLerp((int)(col_a >> 0) & 0xFF, (int)(col_b >> 0) & 0xFF, t);
    int g = ImLerp((int)(col_a >> 8) & 0xFF, (int)(col_b >> 8) & 0xFF, t);
    int b = ImLerp((int)(col_a >> 16) & 0xFF, (int)(col_b >> 16) & 0xFF, t);
    return (((ImU32)(0xFF)<<24) | ((ImU32)(b)<<16) | ((ImU32)(g)<<8) | ((ImU32)(r)<<0));
}

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f / 255.0f;
    return ImVec4(
        ((in >> 0) & 0xFF) * s,
        ((in >> 8) & 0xFF) * s,
        ((in >> 16) & 0xFF) * s,
        ((in >> 24) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
    ImU32 out;
    out = ((ImU32)((int)(ImSaturate(in.x) * 255.0f + 0.5f))) << 0;
    out |= ((ImU32)((int)(ImSaturate(in.y) * 255.0f + 0.5f))) << 8;
    out |= ((ImU32)((int)(ImSaturate(in.z) * 255.0f + 0.5f))) << 16;
    out |= ((ImU32)((int)(ImSaturate(in.w) * 255.0f + 0.5f))) << 24;
    return out;
}



void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = fabsf(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}



void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {

        out_r = out_g = out_b = v;
        return;
    }

    h = fmodf((h), (1.0f)) / (60.0f / 360.0f);
    int i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}







static ImGuiStorage::ImGuiStoragePair* LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key)
{
    ImGuiStorage::ImGuiStoragePair* first = data.Data;
    ImGuiStorage::ImGuiStoragePair* last = data.Data + data.Size;
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        ImGuiStorage::ImGuiStoragePair* mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return first;
}


void ImGuiStorage::BuildSortByKey()
{
    struct StaticFunc
    {
        static int PairComparerByID(const void* lhs, const void* rhs)
        {

            if (((const ImGuiStoragePair*)lhs)->key > ((const ImGuiStoragePair*)rhs)->key) return +1;
            if (((const ImGuiStoragePair*)lhs)->key < ((const ImGuiStoragePair*)rhs)->key) return -1;
            return 0;
        }
    };
    ImQsort(Data.Data, (size_t)Data.Size, sizeof(ImGuiStoragePair), StaticFunc::PairComparerByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
    ImGuiStoragePair* it = LowerBound(const_cast<ImVector<ImGuiStoragePair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return 
# 2290 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 2290 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;
    return it->val_p;
}


int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, ImGuiStoragePair(key, default_val));
    return &it->val_p;
}


void ImGuiStorage::SetInt(ImGuiID key, int val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, ImGuiStoragePair(key, val));
        return;
    }
    it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, ImGuiStoragePair(key, val));
        return;
    }
    it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
    ImGuiStoragePair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, ImGuiStoragePair(key, val));
        return;
    }
    it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}






ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
    InputBuf[0] = 0;
    CountGrep = 0;
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, ((int)(sizeof(InputBuf) / sizeof(*(InputBuf)))));
        Build();
    }
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        ImGui::SetNextItemWidth(width);
    bool value_changed = ImGui::InputText(label, InputBuf, ((int)(sizeof(InputBuf) / sizeof(*(InputBuf)))));
    if (value_changed)
        Build();
    return value_changed;
}

void ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange>* out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(ImGuiTextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(ImGuiTextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
    Filters.resize(0);
    ImGuiTextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        ImGuiTextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == 
# 2439 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               __null
# 2439 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   )
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const ImGuiTextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {

            if (ImStristr(text, text_end, f.b + 1, f.e) != 
# 2450 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                          __null
# 2450 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                              )
                return false;
        }
        else
        {

            if (ImStristr(text, text_end, f.b, f.e) != 
# 2456 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      __null
# 2456 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                          )
                return true;
        }
    }


    if (CountGrep == 0)
        return true;

    return false;
}
# 2482 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
char ImGuiTextBuffer::EmptyString[1] = { 0 };

void ImGuiTextBuffer::append(const char* str, const char* str_end)
{
    int len = str_end ? (int)(str_end - str) : (int)strlen(str);


    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    memcpy(&Buf[write_off - 1], str, (size_t)len);
    Buf[write_off - 1 + len] = 0;
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    
# 2505 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_start(
# 2505 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 2505 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 2505 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   fmt
# 2505 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 2505 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;
    appendfv(fmt, args);
    
# 2507 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 2507 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 2507 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 2507 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
}


void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    
# 2514 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_copy(
# 2514 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args_copy
# 2514 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 2514 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 2514 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 2514 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;

    int len = ImFormatStringV(
# 2516 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                             __null
# 2516 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 , 0, fmt, args);
    if (len <= 0)
    {
        
# 2519 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       __builtin_va_end(
# 2519 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       args_copy
# 2519 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       )
# 2519 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        ;
        return;
    }


    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    
# 2534 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 2534 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args_copy
# 2534 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 2534 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                    ;
}

void ImGuiTextIndex::append(const char* base, int old_size, int new_size)
{
    
# 2539 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 2539 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   old_size >= 0 && new_size >= old_size && new_size >= EndOffset
# 2539 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 2539 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "old_size >= 0 && new_size >= old_size && new_size >= EndOffset"
# 2539 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2539, __extension__ __PRETTY_FUNCTION__))
# 2539 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                            ;
    if (old_size == new_size)
        return;
    if (EndOffset == 0 || base[EndOffset - 1] == '\n')
        LineOffsets.push_back(EndOffset);
    const char* base_end = base + new_size;
    for (const char* p = base + old_size; (p = (const char*)memchr(p, '\n', base_end - p)) != 0; )
        if (++p < base_end)
            LineOffsets.push_back((int)(intptr_t)(p - base));
    EndOffset = ImMax(EndOffset, new_size);
}
# 2559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static bool GetSkipItemForListClipping()
{
    ImGuiContext& g = *GImGui;
    return (g.CurrentTable ? g.CurrentTable->HostSkipItems : g.CurrentWindow->SkipItems);
}





void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {

        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (GetSkipItemForListClipping())
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }



    ImRect rect = window->ClipRect;
    if (g.NavMoveScoringItems)
        rect.Add(g.NavScoringNoClipRect);
    if (g.NavJustMovedToId && window->NavLastIds[0] == g.NavJustMovedToId)
        rect.Add(WindowRectRelToAbs(window, window->NavRectRel[0]));

    const ImVec2 pos = window->DC.CursorPos;
    int start = (int)((rect.Min.y - pos.y) / items_height);
    int end = (int)((rect.Max.y - pos.y) / items_height);



    const bool is_nav_request = (g.NavMoveScoringItems && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
    if (is_nav_request && g.NavMoveClipDir == ImGuiDir_Up)
        start--;
    if (is_nav_request && g.NavMoveClipDir == ImGuiDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}


static void ImGuiListClipper_SortAndFuseRanges(ImVector<ImGuiListClipperRange>& ranges, int offset = 0)
{
    if (ranges.Size - offset <= 1)
        return;


    for (int sort_end = ranges.Size - offset - 1; sort_end > 0; --sort_end)
        for (int i = offset; i < sort_end + offset; ++i)
            if (ranges[i].Min > ranges[i + 1].Min)
                ImSwap(ranges[i], ranges[i + 1]);


    for (int i = 1 + offset; i < ranges.Size; i++)
    {
        
# 2627 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 2627 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       !ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert
# 2627 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 2627 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "!ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert"
# 2627 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2627, __extension__ __PRETTY_FUNCTION__))
# 2627 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                  ;
        if (ranges[i - 1].Max < ranges[i].Min)
            continue;
        ranges[i - 1].Min = ImMin(ranges[i - 1].Min, ranges[i].Min);
        ranges[i - 1].Max = ImMax(ranges[i - 1].Max, ranges[i].Max);
        ranges.erase(ranges.Data + i);
        i--;
    }
}

static void ImGuiListClipper_SeekCursorAndSetupPrevLine(float pos_y, float line_height)
{



    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float off_y = pos_y - window->DC.CursorPos.y;
    window->DC.CursorPos.y = pos_y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y);
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;
    window->DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y);
    if (ImGuiOldColumns* columns = window->DC.CurrentColumns)
        columns->LineMinY = window->DC.CursorPos.y;
    if (ImGuiTable* table = g.CurrentTable)
    {
        if (table->IsInsideRow)
            ImGui::TableEndRow(table);
        table->RowPosY2 = window->DC.CursorPos.y;
        const int row_increase = (int)((off_y / line_height) + 0.5f);

        table->RowBgColorCounter += row_increase;
    }
}

static void ImGuiListClipper_SeekCursorForItem(ImGuiListClipper* clipper, int item_n)
{


    ImGuiListClipperData* data = (ImGuiListClipperData*)clipper->TempData;
    float pos_y = (float)((double)clipper->StartPosY + data->LossynessOffset + (double)(item_n - data->ItemsFrozen) * clipper->ItemsHeight);
    ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, clipper->ItemsHeight);
}

ImGuiListClipper::ImGuiListClipper()
{
    memset(this, 0, sizeof(*this));
    ItemsCount = -1;
}

ImGuiListClipper::~ImGuiListClipper()
{
    End();
}

void ImGuiListClipper::Begin(int items_count, float items_height)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) ImGui::DebugLog("Clipper: Begin(%d,%.2f) in '%s'\n", items_count, items_height, window->Name); } while (0);

    if (ImGuiTable* table = g.CurrentTable)
        if (table->IsInsideRow)
            ImGui::TableEndRow(table);

    StartPosY = window->DC.CursorPos.y;
    ItemsHeight = items_height;
    ItemsCount = items_count;
    DisplayStart = -1;
    DisplayEnd = 0;


    if (++g.ClipperTempDataStacked > g.ClipperTempData.Size)
        g.ClipperTempData.resize(g.ClipperTempDataStacked, ImGuiListClipperData());
    ImGuiListClipperData* data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
    data->Reset(this);
    data->LossynessOffset = window->DC.CursorStartPosLossyness.y;
    TempData = data;
}

void ImGuiListClipper::End()
{
    ImGuiContext& g = *GImGui;
    if (ImGuiListClipperData* data = (ImGuiListClipperData*)TempData)
    {

        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) ImGui::DebugLog("Clipper: End() in '%s'\n", g.CurrentWindow->Name); } while (0);
        if (ItemsCount >= 0 && ItemsCount < 0x7fffffff && DisplayStart >= 0)
            ImGuiListClipper_SeekCursorForItem(this, ItemsCount);


        
# 2718 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 2718 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       data->ListClipper == this
# 2718 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 2718 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "data->ListClipper == this"
# 2718 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2718, __extension__ __PRETTY_FUNCTION__))
# 2718 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;
        data->StepNo = data->Ranges.Size;
        if (--g.ClipperTempDataStacked > 0)
        {
            data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
            data->ListClipper->TempData = data;
        }
        TempData = 
# 2725 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                  __null
# 2725 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;
    }
    ItemsCount = -1;
}

void ImGuiListClipper::ForceDisplayRangeByIndices(int item_min, int item_max)
{
    ImGuiListClipperData* data = (ImGuiListClipperData*)TempData;
    
# 2733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 2733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   DisplayStart < 0
# 2733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 2733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "DisplayStart < 0"
# 2733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2733, __extension__ __PRETTY_FUNCTION__))
# 2733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
    
# 2734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 2734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   item_min <= item_max
# 2734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 2734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "item_min <= item_max"
# 2734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2734, __extension__ __PRETTY_FUNCTION__))
# 2734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  ;
    if (item_min < item_max)
        data->Ranges.push_back(ImGuiListClipperRange::FromIndices(item_min, item_max));
}

static bool ImGuiListClipper_StepInternal(ImGuiListClipper* clipper)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiListClipperData* data = (ImGuiListClipperData*)clipper->TempData;
    
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   data != 
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && "Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?"
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "data != __null && \"Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?\""
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2744, __extension__ __PRETTY_FUNCTION__))
# 2744 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                     ;

    ImGuiTable* table = g.CurrentTable;
    if (table && table->IsInsideRow)
        ImGui::TableEndRow(table);


    if (clipper->ItemsCount == 0 || GetSkipItemForListClipping())
        return false;



    if (data->StepNo == 0 && table != 
# 2756 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                     __null 
# 2756 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          && !table->IsUnfrozenRows)
    {
        clipper->DisplayStart = data->ItemsFrozen;
        clipper->DisplayEnd = ImMin(data->ItemsFrozen + 1, clipper->ItemsCount);
        if (clipper->DisplayStart < clipper->DisplayEnd)
            data->ItemsFrozen++;
        return true;
    }


    bool calc_clipping = false;
    if (data->StepNo == 0)
    {
        clipper->StartPosY = window->DC.CursorPos.y;
        if (clipper->ItemsHeight <= 0.0f)
        {

            data->Ranges.push_front(ImGuiListClipperRange::FromIndices(data->ItemsFrozen, data->ItemsFrozen + 1));
            clipper->DisplayStart = ImMax(data->Ranges[0].Min, data->ItemsFrozen);
            clipper->DisplayEnd = ImMin(data->Ranges[0].Max, clipper->ItemsCount);
            data->StepNo = 1;
            return true;
        }
        calc_clipping = true;
    }


    if (clipper->ItemsHeight <= 0.0f)
    {
        
# 2785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 2785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       data->StepNo == 1
# 2785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 2785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "data->StepNo == 1"
# 2785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2785, __extension__ __PRETTY_FUNCTION__))
# 2785 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;
        if (table)
            
# 2787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 2787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           table->RowPosY1 == clipper->StartPosY && table->RowPosY2 == window->DC.CursorPos.y
# 2787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 2787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "table->RowPosY1 == clipper->StartPosY && table->RowPosY2 == window->DC.CursorPos.y"
# 2787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2787, __extension__ __PRETTY_FUNCTION__))
# 2787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                        ;

        clipper->ItemsHeight = (window->DC.CursorPos.y - clipper->StartPosY) / (float)(clipper->DisplayEnd - clipper->DisplayStart);
        bool affected_by_floating_point_precision = ImIsFloatAboveGuaranteedIntegerPrecision(clipper->StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window->DC.CursorPos.y);
        if (affected_by_floating_point_precision)
            clipper->ItemsHeight = window->DC.PrevLineSize.y + g.Style.ItemSpacing.y;

        
# 2794 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 2794 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       clipper->ItemsHeight > 0.0f && "Unable to calculate item height! First item hasn't moved the cursor vertically!"
# 2794 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 2794 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "clipper->ItemsHeight > 0.0f && \"Unable to calculate item height! First item hasn't moved the cursor vertically!\""
# 2794 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2794, __extension__ __PRETTY_FUNCTION__))
# 2794 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                  ;
        calc_clipping = true;
    }


    const int already_submitted = clipper->DisplayEnd;
    if (calc_clipping)
    {
        if (g.LogEnabled)
        {

            data->Ranges.push_back(ImGuiListClipperRange::FromIndices(0, clipper->ItemsCount));
        }
        else
        {

            const bool is_nav_request = (g.NavMoveScoringItems && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
            if (is_nav_request)
                data->Ranges.push_back(ImGuiListClipperRange::FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0));
            if (is_nav_request && (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) && g.NavTabbingDir == -1)
                data->Ranges.push_back(ImGuiListClipperRange::FromIndices(clipper->ItemsCount - 1, clipper->ItemsCount));


            ImRect nav_rect_abs = ImGui::WindowRectRelToAbs(window, window->NavRectRel[0]);
            if (g.NavId != 0 && window->NavLastIds[0] == g.NavId)
                data->Ranges.push_back(ImGuiListClipperRange::FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0));


            const int off_min = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Up) ? -1 : 0;
            const int off_max = (is_nav_request && g.NavMoveClipDir == ImGuiDir_Down) ? 1 : 0;
            data->Ranges.push_back(ImGuiListClipperRange::FromPositions(window->ClipRect.Min.y, window->ClipRect.Max.y, off_min, off_max));
        }





        for (int i = 0; i < data->Ranges.Size; i++)
            if (data->Ranges[i].PosToIndexConvert)
            {
                int m1 = (int)(((double)data->Ranges[i].Min - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight);
                int m2 = (int)((((double)data->Ranges[i].Max - window->DC.CursorPos.y - data->LossynessOffset) / clipper->ItemsHeight) + 0.999999f);
                data->Ranges[i].Min = ImClamp(already_submitted + m1 + data->Ranges[i].PosToIndexOffsetMin, already_submitted, clipper->ItemsCount - 1);
                data->Ranges[i].Max = ImClamp(already_submitted + m2 + data->Ranges[i].PosToIndexOffsetMax, data->Ranges[i].Min + 1, clipper->ItemsCount);
                data->Ranges[i].PosToIndexConvert = false;
            }
        ImGuiListClipper_SortAndFuseRanges(data->Ranges, data->StepNo);
    }


    if (data->StepNo < data->Ranges.Size)
    {
        clipper->DisplayStart = ImMax(data->Ranges[data->StepNo].Min, already_submitted);
        clipper->DisplayEnd = ImMin(data->Ranges[data->StepNo].Max, clipper->ItemsCount);
        if (clipper->DisplayStart > already_submitted)
            ImGuiListClipper_SeekCursorForItem(clipper, clipper->DisplayStart);
        data->StepNo++;
        return true;
    }



    if (clipper->ItemsCount < 0x7fffffff)
        ImGuiListClipper_SeekCursorForItem(clipper, clipper->ItemsCount);

    return false;
}

bool ImGuiListClipper::Step()
{
    ImGuiContext& g = *GImGui;
    bool need_items_height = (ItemsHeight <= 0.0f);
    bool ret = ImGuiListClipper_StepInternal(this);
    if (ret && (DisplayStart == DisplayEnd))
        ret = false;
    if (g.CurrentTable && g.CurrentTable->IsUnfrozenRows == false)
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) ImGui::DebugLog("Clipper: Step(): inside frozen table row.\n"); } while (0);
    if (need_items_height && ItemsHeight > 0.0f)
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) ImGui::DebugLog("Clipper: Step(): computed ItemsHeight: %.2f.\n", ItemsHeight); } while (0);
    if (ret)
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) ImGui::DebugLog("Clipper: Step(): display %d to %d.\n", DisplayStart, DisplayEnd); } while (0);
    else
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper) ImGui::DebugLog("Clipper: Step(): End.\n"); } while (0);
    if (!ret)
        End();
    return ret;
}





ImGuiStyle& ImGui::GetStyle()
{
    
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   GImGui != 
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?"
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "GImGui != __null && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?\""
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2888, __extension__ __PRETTY_FUNCTION__))
# 2888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                          ;
    return GImGui->Style;
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
    ImGuiStyle& style = GImGui->Style;
    return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
    ImGuiStyle& style = GImGui->Style;
    if (style.Alpha >= 1.0f)
        return col;
    ImU32 a = (col & 0xFF000000) >> 24;
    a = (ImU32)(a * style.Alpha);
    return (col & ~0xFF000000) | (a << 24);
}


void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorStack.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorStack.push_back(backup);
    g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
    ImGuiContext& g = *GImGui;
    if (g.ColorStack.Size < count)
    {
        
# 2950 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 2950 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (g.ColorStack.Size > count) && "Calling PopStyleColor() too many times: stack underflow."
# 2950 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 2950 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(g.ColorStack.Size > count) && \"Calling PopStyleColor() too many times: stack underflow.\""
# 2950 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 2950, __extension__ __PRETTY_FUNCTION__))
# 2950 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                  ;
        count = g.ColorStack.Size;
    }
    while (count > 0)
    {
        ImGuiColorMod& backup = g.ColorStack.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorStack.pop_back();
        count--;
    }
}

struct ImGuiStyleVarInfo
{
    ImGuiDataType Type;
    ImU32 Count;
    ImU32 Offset;
    void* GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)
# 2972 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2972 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2972 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2972 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    Alpha
# 2972 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2972 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                   },
    { ImGuiDataType_Float, 1, (ImU32)
# 2973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    DisabledAlpha
# 2973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2973 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 2, (ImU32)
# 2974 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2974 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2974 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2974 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    WindowPadding
# 2974 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2974 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 1, (ImU32)
# 2975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    WindowRounding
# 2975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                            },
    { ImGuiDataType_Float, 1, (ImU32)
# 2976 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2976 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2976 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2976 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    WindowBorderSize
# 2976 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2976 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                              },
    { ImGuiDataType_Float, 2, (ImU32)
# 2977 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2977 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2977 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2977 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    WindowMinSize
# 2977 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2977 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 2, (ImU32)
# 2978 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2978 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2978 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2978 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    WindowTitleAlign
# 2978 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2978 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                              },
    { ImGuiDataType_Float, 1, (ImU32)
# 2979 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2979 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2979 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2979 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ChildRounding
# 2979 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2979 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 1, (ImU32)
# 2980 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2980 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2980 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2980 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ChildBorderSize
# 2980 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2980 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             },
    { ImGuiDataType_Float, 1, (ImU32)
# 2981 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2981 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2981 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2981 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    PopupRounding
# 2981 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2981 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 1, (ImU32)
# 2982 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2982 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2982 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2982 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    PopupBorderSize
# 2982 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2982 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             },
    { ImGuiDataType_Float, 2, (ImU32)
# 2983 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2983 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2983 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2983 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    FramePadding
# 2983 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2983 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                          },
    { ImGuiDataType_Float, 1, (ImU32)
# 2984 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2984 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2984 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2984 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    FrameRounding
# 2984 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2984 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 1, (ImU32)
# 2985 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2985 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2985 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2985 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    FrameBorderSize
# 2985 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2985 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             },
    { ImGuiDataType_Float, 2, (ImU32)
# 2986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ItemSpacing
# 2986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         },
    { ImGuiDataType_Float, 2, (ImU32)
# 2987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ItemInnerSpacing
# 2987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                              },
    { ImGuiDataType_Float, 1, (ImU32)
# 2988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    IndentSpacing
# 2988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 2, (ImU32)
# 2989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    CellPadding
# 2989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         },
    { ImGuiDataType_Float, 1, (ImU32)
# 2990 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2990 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2990 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2990 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ScrollbarSize
# 2990 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2990 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           },
    { ImGuiDataType_Float, 1, (ImU32)
# 2991 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2991 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2991 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2991 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ScrollbarRounding
# 2991 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2991 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                               },
    { ImGuiDataType_Float, 1, (ImU32)
# 2992 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2992 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2992 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2992 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    GrabMinSize
# 2992 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2992 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         },
    { ImGuiDataType_Float, 1, (ImU32)
# 2993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    GrabRounding
# 2993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                          },
    { ImGuiDataType_Float, 1, (ImU32)
# 2994 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2994 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2994 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2994 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    TabRounding
# 2994 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2994 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         },
    { ImGuiDataType_Float, 2, (ImU32)
# 2995 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2995 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2995 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2995 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ButtonTextAlign
# 2995 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2995 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             },
    { ImGuiDataType_Float, 2, (ImU32)
# 2996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __builtin_offsetof (
# 2996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ImGuiStyle
# 2996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    , 
# 2996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    SelectableTextAlign
# 2996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    ) 
# 2996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                 },
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
    
# 3001 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3001 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   idx >= 0 && idx < ImGuiStyleVar_COUNT
# 3001 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3001 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "idx >= 0 && idx < ImGuiStyleVar_COUNT"
# 3001 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3001, __extension__ __PRETTY_FUNCTION__))
# 3001 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   ;
    
# 3002 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3002 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   ((int)(sizeof(GStyleVarInfo) / sizeof(*(GStyleVarInfo)))) == ImGuiStyleVar_COUNT
# 3002 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3002 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "((int)(sizeof(GStyleVarInfo) / sizeof(*(GStyleVarInfo)))) == ImGuiStyleVar_COUNT"
# 3002 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3002, __extension__ __PRETTY_FUNCTION__))
# 3002 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                ;
    return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        ImGuiContext& g = *GImGui;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    
# 3017 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3017 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   0 && "Called PushStyleVar() float variant but variable is not a float!"
# 3017 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3017 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "0 && \"Called PushStyleVar() float variant but variable is not a float!\""
# 3017 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3017, __extension__ __PRETTY_FUNCTION__))
# 3017 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                     ;
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImGuiContext& g = *GImGui;
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
        g.StyleVarStack.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    
# 3031 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3031 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   0 && "Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!"
# 3031 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3031 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "0 && \"Called PushStyleVar() ImVec2 variant but variable is not a ImVec2!\""
# 3031 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3031, __extension__ __PRETTY_FUNCTION__))
# 3031 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                       ;
}

void ImGui::PopStyleVar(int count)
{
    ImGuiContext& g = *GImGui;
    if (g.StyleVarStack.Size < count)
    {
        
# 3039 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 3039 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (g.StyleVarStack.Size > count) && "Calling PopStyleVar() too many times: stack underflow."
# 3039 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 3039 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(g.StyleVarStack.Size > count) && \"Calling PopStyleVar() too many times: stack underflow.\""
# 3039 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3039, __extension__ __PRETTY_FUNCTION__))
# 3039 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                   ;
        count = g.StyleVarStack.Size;
    }
    while (count > 0)
    {

        ImGuiStyleMod& backup = g.StyleVarStack.back();
        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1) { ((float*)data)[0] = backup.BackupFloat[0]; }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleVarStack.pop_back();
        count--;
    }
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{

    switch (idx)
    {
    case ImGuiCol_Text: return "Text";
    case ImGuiCol_TextDisabled: return "TextDisabled";
    case ImGuiCol_WindowBg: return "WindowBg";
    case ImGuiCol_ChildBg: return "ChildBg";
    case ImGuiCol_PopupBg: return "PopupBg";
    case ImGuiCol_Border: return "Border";
    case ImGuiCol_BorderShadow: return "BorderShadow";
    case ImGuiCol_FrameBg: return "FrameBg";
    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    case ImGuiCol_TitleBg: return "TitleBg";
    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case ImGuiCol_CheckMark: return "CheckMark";
    case ImGuiCol_SliderGrab: return "SliderGrab";
    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    case ImGuiCol_Button: return "Button";
    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    case ImGuiCol_ButtonActive: return "ButtonActive";
    case ImGuiCol_Header: return "Header";
    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    case ImGuiCol_HeaderActive: return "HeaderActive";
    case ImGuiCol_Separator: return "Separator";
    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    case ImGuiCol_Tab: return "Tab";
    case ImGuiCol_TabHovered: return "TabHovered";
    case ImGuiCol_TabActive: return "TabActive";
    case ImGuiCol_TabUnfocused: return "TabUnfocused";
    case ImGuiCol_TabUnfocusedActive: return "TabUnfocusedActive";
    case ImGuiCol_PlotLines: return "PlotLines";
    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case ImGuiCol_TableHeaderBg: return "TableHeaderBg";
    case ImGuiCol_TableBorderStrong: return "TableBorderStrong";
    case ImGuiCol_TableBorderLight: return "TableBorderLight";
    case ImGuiCol_TableRowBg: return "TableRowBg";
    case ImGuiCol_TableRowBgAlt: return "TableRowBgAlt";
    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    case ImGuiCol_NavHighlight: return "NavHighlight";
    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    
# 3114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   0
# 3114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "0"
# 3114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3114, __extension__ __PRETTY_FUNCTION__))
# 3114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
    return "Unknown";
}
# 3126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}



void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;


    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    }
    else
    {
        if (!text_end)
            text_end = text + strlen(text);
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text);

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}



void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{

    ImVec2 pos = pos_min;
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect)
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);


    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);


    if (need_clipping)
    {
        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        draw_list->AddText(
# 3203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                          __null
# 3203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              , 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    }
    else
    {
        draw_list->AddText(
# 3207 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                          __null
# 3207 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              , 0.0f, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, 
# 3207 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                     __null
# 3207 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                         );
    }
}

void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{

    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_display_end);
}





void ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)
{
    ImGuiContext& g = *GImGui;
    if (text_end_full == 
# 3233 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        __null
# 3233 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            )
        text_end_full = FindRenderedTextEnd(text);
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_end_full, false, 0.0f);





    if (text_size.x > pos_max.x - pos_min.x)
    {





        const ImFont* font = draw_list->_Data->Font;
        const float font_size = draw_list->_Data->FontSize;
        const char* text_end_ellipsis = 
# 3250 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                       __null
# 3250 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;

        ImWchar ellipsis_char = font->EllipsisChar;
        int ellipsis_char_count = 1;
        if (ellipsis_char == (ImWchar)-1)
        {
            ellipsis_char = font->DotChar;
            ellipsis_char_count = 3;
        }
        const ImFontGlyph* glyph = font->FindGlyph(ellipsis_char);

        float ellipsis_glyph_width = glyph->X1;
        float ellipsis_total_width = ellipsis_glyph_width;

        if (ellipsis_char_count > 1)
        {

            const float spacing_between_dots = 1.0f * (draw_list->_Data->FontSize / font->FontSize);
            ellipsis_glyph_width = glyph->X1 - glyph->X0 + spacing_between_dots;
            ellipsis_total_width = ellipsis_glyph_width * (float)ellipsis_char_count - spacing_between_dots;
        }


        const float text_avail_width = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_total_width) - pos_min.x, 1.0f);
        float text_size_clipped_x = font->CalcTextSizeA(font_size, text_avail_width, 0.0f, text, text_end_full, &text_end_ellipsis).x;
        if (text == text_end_ellipsis && text_end_ellipsis < text_end_full)
        {

            text_end_ellipsis = text + ImTextCountUtf8BytesFromChar(text, text_end_full);
            text_size_clipped_x = font->CalcTextSizeA(font_size, 3.40282346638528859811704183484516925e+38F, 0.0f, text, text_end_ellipsis).x;
        }
        while (text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1]))
        {

            text_end_ellipsis--;
            text_size_clipped_x -= font->CalcTextSizeA(font_size, 3.40282346638528859811704183484516925e+38F, 0.0f, text_end_ellipsis, text_end_ellipsis + 1).x;
        }


        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_ellipsis, &text_size, ImVec2(0.0f, 0.0f));
        float ellipsis_x = pos_min.x + text_size_clipped_x;
        if (ellipsis_x + ellipsis_total_width <= ellipsis_max_x)
            for (int i = 0; i < ellipsis_char_count; i++)
            {
                font->RenderChar(draw_list, font_size, ImVec2(ellipsis_x, pos_min.y), GetColorU32(ImGuiCol_Text), ellipsis_char);
                ellipsis_x += ellipsis_glyph_width;
            }
    }
    else
    {
        RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_full, &text_size, ImVec2(0.0f, 0.0f));
    }

    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_end_full);
}


void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
    }
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, 0, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);
    }
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
        return;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & ImGuiNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(ImVec2(DISTANCE, DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, 0, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & ImGuiNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, 0, 1.0f);
    }
}

void ImGui::RenderMouseCursor(ImVec2 base_pos, float base_scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow)
{
    ImGuiContext& g = *GImGui;
    
# 3368 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3368 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT
# 3368 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3368 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT"
# 3368 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3368, __extension__ __PRETTY_FUNCTION__))
# 3368 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                           ;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        ImDrawList* draw_list = GetForegroundDrawList(viewport);
        ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;
        ImVec2 offset, size, uv[4];
        if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
        {
            const ImVec2 pos = base_pos - offset;
            const float scale = base_scale;
            ImTextureID tex_id = font_atlas->TexID;
            draw_list->PushTextureID(tex_id);
            draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);
            draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);
            draw_list->AddImage(tex_id, pos, pos + size * scale, uv[2], uv[3], col_border);
            draw_list->AddImage(tex_id, pos, pos + size * scale, uv[0], uv[1], col_fill);
            draw_list->PopTextureID();
        }
    }
}







ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name) : DrawListInst(
# 3396 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                __null
# 3396 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                    )
{
    memset(this, 0, sizeof(*this));
    Name = ImStrdup(name);
    NameBufLen = (int)strlen(name) + 1;
    ID = ImHashStr(name);
    IDStack.push_back(ID);
    MoveId = GetID("#MOVE");
    ScrollTarget = ImVec2(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F);
    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoPosLastDirection = ImGuiDir_None;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = ImVec2(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F);
    LastFrameActive = -1;
    LastTimeActive = -1.0f;
    FontWindowScale = 1.0f;
    SettingsOffset = -1;
    DrawList = &DrawListInst;
    DrawList->_Data = &context->DrawListSharedData;
    DrawList->_OwnerName = Name;
}

ImGuiWindow::~ImGuiWindow()
{
    
# 3421 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3421 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   DrawList == &DrawListInst
# 3421 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3421 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "DrawList == &DrawListInst"
# 3421 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3421, __extension__ __PRETTY_FUNCTION__))
# 3421 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       ;
    IM_DELETE(Name);
    ColumnsStorage.clear_destruct();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    ImGuiContext& g = *GImGui;
    if (g.DebugHookIdInfo == id)
        ImGui::DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
    return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&ptr, sizeof(void*), seed);
    ImGuiContext& g = *GImGui;
    if (g.DebugHookIdInfo == id)
        ImGui::DebugHookIdInfo(id, ImGuiDataType_Pointer, ptr, 
# 3442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                              __null
# 3442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  );
    return id;
}

ImGuiID ImGuiWindow::GetID(int n)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHashData(&n, sizeof(n), seed);
    ImGuiContext& g = *GImGui;
    if (g.DebugHookIdInfo == id)
        ImGui::DebugHookIdInfo(id, ImGuiDataType_S32, (void*)(intptr_t)n, 
# 3452 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                         __null
# 3452 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             );
    return id;
}


ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
    ImGuiID seed = IDStack.back();
    ImRect r_rel = ImGui::WindowRectAbsToRel(this, r_abs);
    ImGuiID id = ImHashData(&r_rel, sizeof(r_rel), seed);
    return id;
}

static void SetCurrentWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow = window;
    g.CurrentTable = window && window->DC.CurrentTableIdx != -1 ? g.Tables.GetByIndex(window->DC.CurrentTableIdx) : 
# 3469 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                   __null
# 3469 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                       ;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::GcCompactTransientMiscBuffers()
{
    ImGuiContext& g = *GImGui;
    g.ItemFlagsStack.clear();
    g.GroupStack.clear();
    TableGcCompactSettings();
}





void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)
{
    window->MemoryCompacted = true;
    window->MemoryDrawListIdxCapacity = window->DrawList->IdxBuffer.Capacity;
    window->MemoryDrawListVtxCapacity = window->DrawList->VtxBuffer.Capacity;
    window->IDStack.clear();
    window->DrawList->_ClearFreeMemory();
    window->DC.ChildWindows.clear();
    window->DC.ItemWidthStack.clear();
    window->DC.TextWrapPosStack.clear();
}

void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)
{


    window->MemoryCompacted = false;
    window->DrawList->IdxBuffer.reserve(window->MemoryDrawListIdxCapacity);
    window->DrawList->VtxBuffer.reserve(window->MemoryDrawListVtxCapacity);
    window->MemoryDrawListIdxCapacity = window->MemoryDrawListVtxCapacity = 0;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;




    if (g.MovingWindow != 
# 3515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                         __null 
# 3515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              && g.ActiveId == g.MovingWindow->MoveId)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) ImGui::DebugLog("SetActiveID() cancel MovingWindow\n"); } while (0);
        g.MovingWindow = 
# 3518 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        __null
# 3518 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            ;
    }


    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) ImGui::DebugLog("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow->Name : "", id, window ? window->Name : ""); } while (0);
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenPressedBefore = false;
        g.ActiveIdHasBeenEditedBefore = false;
        g.ActiveIdMouseButton = -1;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdNoClearOnFocusLoss = false;
    g.ActiveIdWindow = window;
    g.ActiveIdHasBeenEditedThisFrame = false;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavActivateInputId == id || g.NavJustMovedToId == id) ? (ImGuiInputSource)ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
    }



    g.ActiveIdUsingNavDirMask = 0x00;
    g.ActiveIdUsingAllKeyboardKeys = false;

    g.ActiveIdUsingNavInputMask = 0x00;

}

void ImGui::ClearActiveID()
{
    SetActiveID(0, 
# 3558 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                  __null
# 3558 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      );
}

void ImGui::SetHoveredID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}



void ImGui::KeepAliveID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited(ImGuiID id)
{


    ImGuiContext& g = *GImGui;
    
# 3592 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3592 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive
# 3592 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3592 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive"
# 3592 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3592, __extension__ __PRETTY_FUNCTION__))
# 3592 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                     ;
    ((void)(id));

    g.ActiveIdHasBeenEditedThisFrame = true;
    g.ActiveIdHasBeenEditedBefore = true;
    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{


    ImGuiContext& g = *GImGui;
    if (g.NavWindow)
        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
            {


                bool want_inhibit = false;
                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
                    want_inhibit = true;
                else if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
                    want_inhibit = true;


                if (want_inhibit)
                    if (!ImGui::IsWindowWithinBeginStackOf(window->RootWindow, focused_root_window))
                        return false;
            }
    return true;
}




bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight && !(flags & ImGuiHoveredFlags_NoNavOverride))
    {
        if ((g.LastItemData.InFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
            return false;
        if (!IsItemFocused())
            return false;
    }
    else
    {

        ImGuiItemStatusFlags status_flags = g.LastItemData.StatusFlags;
        if (!(status_flags & ImGuiItemStatusFlags_HoveredRect))
            return false;
        
# 3645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 3645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (flags & (ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_NoPopupHierarchy)) == 0
# 3645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 3645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(flags & (ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_NoPopupHierarchy)) == 0"
# 3645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3645, __extension__ __PRETTY_FUNCTION__))
# 3645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                   ;







        if (g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_HoveredWindow) == 0)
            if ((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0)
                return false;


        if ((flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == 0)
            if (g.ActiveId != 0 && g.ActiveId != g.LastItemData.ID && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
                return false;



        if (!IsWindowContentHoverable(window, flags) && !(g.LastItemData.InFlags & ImGuiItemFlags_NoWindowHoverableCheck))
            return false;


        if ((g.LastItemData.InFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
            return false;



        if (g.LastItemData.ID == window->MoveId && window->WriteAccessed)
            return false;
    }



    float delay;
    if (flags & ImGuiHoveredFlags_DelayNormal)
        delay = g.IO.HoverDelayNormal;
    else if (flags & ImGuiHoveredFlags_DelayShort)
        delay = g.IO.HoverDelayShort;
    else
        delay = 0.0f;
    if (delay > 0.0f)
    {
        ImGuiID hover_delay_id = (g.LastItemData.ID != 0) ? g.LastItemData.ID : window->GetIDFromRectangle(g.LastItemData.Rect);
        if ((flags & ImGuiHoveredFlags_NoSharedDelay) && (g.HoverDelayIdPreviousFrame != hover_delay_id))
            g.HoverDelayTimer = 0.0f;
        g.HoverDelayId = hover_delay_id;
        return g.HoverDelayTimer >= delay;
    }

    return true;
}


bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;


    ImGuiItemFlags item_flags = (g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags);
    if (!(item_flags & ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
    {
        g.HoveredIdDisabled = true;
        return false;
    }



    if (id != 0)
        SetHoveredID(id);


    if (item_flags & ImGuiItemFlags_Disabled)
    {

        if (g.ActiveId == id)
            ClearActiveID();
        g.HoveredIdDisabled = true;
        return false;
    }

    if (id != 0)
    {




        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id)
            GetForegroundDrawList()->AddRect(bb.Min, bb.Max, (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
        if (g.DebugItemPickerBreakId == id)
            
# 3745 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 3745 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           0
# 3745 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 3745 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "0"
# 3745 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3745, __extension__ __PRETTY_FUNCTION__))
# 3745 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;
    }

    if (g.NavDisableMouseHover)
        return false;

    return true;
}


bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || (id != g.ActiveId && id != g.NavId))
            if (!g.LogEnabled)
                return true;
    return false;
}



void ImGui::SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)
{
    ImGuiContext& g = *GImGui;
    g.LastItemData.ID = item_id;
    g.LastItemData.InFlags = in_flags;
    g.LastItemData.StatusFlags = item_flags;
    g.LastItemData.Rect = item_rect;
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (wrap_pos_x == 0.0f)
    {





        wrap_pos_x = window->WorkRect.Max.x;
    }
    else if (wrap_pos_x > 0.0f)
    {
        wrap_pos_x += window->Pos.x - window->Scroll.x;
    }

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}


void* ImGui::MemAlloc(size_t size)
{
    if (ImGuiContext* ctx = GImGui)
        ctx->IO.MetricsActiveAllocations++;
    return (*GImAllocatorAllocFunc)(size, GImAllocatorUserData);
}


void ImGui::MemFree(void* ptr)
{
    if (ptr)
        if (ImGuiContext* ctx = GImGui)
            ctx->IO.MetricsActiveAllocations--;
    return (*GImAllocatorFreeFunc)(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
    ImGuiContext& g = *GImGui;
    return g.IO.GetClipboardTextFn ? g.IO.GetClipboardTextFn(g.IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
    ImGuiContext& g = *GImGui;
    if (g.IO.SetClipboardTextFn)
        g.IO.SetClipboardTextFn(g.IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
    return "1.89.1 WIP";
}



ImGuiContext* ImGui::GetCurrentContext()
{
    return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{



    GImGui = ctx;

}

void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}


void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)
{
    *p_alloc_func = GImAllocatorAllocFunc;
    *p_free_func = GImAllocatorFreeFunc;
    *p_user_data = GImAllocatorUserData;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
    ImGuiContext* prev_ctx = GetCurrentContext();
    ImGuiContext* ctx = new(ImNewWrapper(), ImGui::MemAlloc(sizeof(ImGuiContext))) ImGuiContext(shared_font_atlas);
    SetCurrentContext(ctx);
    Initialize();
    if (prev_ctx != 
# 3873 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   __null
# 3873 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                       )
        SetCurrentContext(prev_ctx);
    return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
    ImGuiContext* prev_ctx = GetCurrentContext();
    if (ctx == 
# 3881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 3881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  )
        ctx = prev_ctx;
    SetCurrentContext(ctx);
    Shutdown();
    SetCurrentContext((prev_ctx != ctx) ? prev_ctx : 
# 3885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                    __null
# 3885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                        );
    IM_DELETE(ctx);
}


ImGuiID ImGui::AddContextHook(ImGuiContext* ctx, const ImGuiContextHook* hook)
{
    ImGuiContext& g = *ctx;
    
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   hook->Callback != 
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && hook->HookId == 0 && hook->Type != ImGuiContextHookType_PendingRemoval_
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "hook->Callback != __null && hook->HookId == 0 && hook->Type != ImGuiContextHookType_PendingRemoval_"
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3893, __extension__ __PRETTY_FUNCTION__))
# 3893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                               ;
    g.Hooks.push_back(*hook);
    g.Hooks.back().HookId = ++g.HookIdNext;
    return g.HookIdNext;
}


void ImGui::RemoveContextHook(ImGuiContext* ctx, ImGuiID hook_id)
{
    ImGuiContext& g = *ctx;
    
# 3903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   hook_id != 0
# 3903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "hook_id != 0"
# 3903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3903, __extension__ __PRETTY_FUNCTION__))
# 3903 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          ;
    for (int n = 0; n < g.Hooks.Size; n++)
        if (g.Hooks[n].HookId == hook_id)
            g.Hooks[n].Type = ImGuiContextHookType_PendingRemoval_;
}



void ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)
{
    ImGuiContext& g = *ctx;
    for (int n = 0; n < g.Hooks.Size; n++)
        if (g.Hooks[n].Type == hook_type)
            g.Hooks[n].Callback(&g, &g.Hooks[n]);
}

ImGuiIO& ImGui::GetIO()
{
    
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   GImGui != 
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?"
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "GImGui != __null && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?\""
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3921, __extension__ __PRETTY_FUNCTION__))
# 3921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                          ;
    return GImGui->IO;
}


ImDrawData* ImGui::GetDrawData()
{
    ImGuiContext& g = *GImGui;
    ImGuiViewportP* viewport = g.Viewports[0];
    return viewport->DrawDataP.Valid ? &viewport->DrawDataP : 
# 3930 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                             __null
# 3930 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                 ;
}

double ImGui::GetTime()
{
    return GImGui->Time;
}

int ImGui::GetFrameCount()
{
    return GImGui->FrameCount;
}

static ImDrawList* GetViewportDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)
{

    ImGuiContext& g = *GImGui;
    
# 3947 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 3947 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   drawlist_no < ((int)(sizeof(viewport->DrawLists) / sizeof(*(viewport->DrawLists))))
# 3947 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 3947 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "drawlist_no < ((int)(sizeof(viewport->DrawLists) / sizeof(*(viewport->DrawLists))))"
# 3947 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 3947, __extension__ __PRETTY_FUNCTION__))
# 3947 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                             ;
    ImDrawList* draw_list = viewport->DrawLists[drawlist_no];
    if (draw_list == 
# 3949 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                    __null
# 3949 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        )
    {
        draw_list = new(ImNewWrapper(), ImGui::MemAlloc(sizeof(ImDrawList))) ImDrawList(&g.DrawListSharedData);
        draw_list->_OwnerName = drawlist_name;
        viewport->DrawLists[drawlist_no] = draw_list;
    }


    if (viewport->DrawListsLastFrame[drawlist_no] != g.FrameCount)
    {
        draw_list->_ResetForNewFrame();
        draw_list->PushTextureID(g.IO.Fonts->TexID);
        draw_list->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size, false);
        viewport->DrawListsLastFrame[drawlist_no] = g.FrameCount;
    }
    return draw_list;
}

ImDrawList* ImGui::GetBackgroundDrawList(ImGuiViewport* viewport)
{
    return GetViewportDrawList((ImGuiViewportP*)viewport, 0, "##Background");
}

ImDrawList* ImGui::GetBackgroundDrawList()
{
    ImGuiContext& g = *GImGui;
    return GetBackgroundDrawList(g.Viewports[0]);
}

ImDrawList* ImGui::GetForegroundDrawList(ImGuiViewport* viewport)
{
    return GetViewportDrawList((ImGuiViewportP*)viewport, 1, "##Foreground");
}

ImDrawList* ImGui::GetForegroundDrawList()
{
    ImGuiContext& g = *GImGui;
    return GetForegroundDrawList(g.Viewports[0]);
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
    return &GImGui->DrawListSharedData;
}

void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
{



    ImGuiContext& g = *GImGui;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window->RootWindow->Pos;
    g.ActiveIdNoClearOnFocusLoss = true;
    SetActiveIdUsingAllKeyboardKeys();

    bool can_move_window = true;
    if ((window->Flags & ImGuiWindowFlags_NoMove) || (window->RootWindow->Flags & ImGuiWindowFlags_NoMove))
        can_move_window = false;
    if (can_move_window)
        g.MovingWindow = window;
}






void ImGui::UpdateMouseMovingWindowNewFrame()
{
    ImGuiContext& g = *GImGui;
    if (g.MovingWindow != 
# 4022 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                         __null
# 4022 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             )
    {


        KeepAliveID(g.ActiveId);
        
# 4027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 4027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.MovingWindow && g.MovingWindow->RootWindow
# 4027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 4027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.MovingWindow && g.MovingWindow->RootWindow"
# 4027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4027, __extension__ __PRETTY_FUNCTION__))
# 4027 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                              ;
        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
            SetWindowPos(moving_window, pos, ImGuiCond_Always);
            FocusWindow(g.MovingWindow);
        }
        else
        {
            g.MovingWindow = 
# 4037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                            __null
# 4037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                ;
            ClearActiveID();
        }
    }
    else
    {

        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}



void ImGui::UpdateMouseMovingWindowEndFrame()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId != 0 || g.HoveredId != 0)
        return;


    if (g.NavWindow && g.NavWindow->Appearing)
        return;



    if (g.IO.MouseClicked[0])
    {


        ImGuiWindow* root_window = g.HoveredWindow ? g.HoveredWindow->RootWindow : 
# 4071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                  __null
# 4071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                      ;
        const bool is_closed_popup = root_window && (root_window->Flags & ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window->PopupId, ImGuiPopupFlags_AnyPopupLevel);

        if (root_window != 
# 4074 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                          __null 
# 4074 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                               && !is_closed_popup)
        {
            StartMouseMovingWindow(g.HoveredWindow);


            if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(root_window->Flags & ImGuiWindowFlags_NoTitleBar))
                if (!root_window->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                    g.MovingWindow = 
# 4081 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                    __null
# 4081 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                        ;


            if (g.HoveredIdDisabled)
                g.MovingWindow = 
# 4085 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                __null
# 4085 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;
        }
        else if (root_window == 
# 4087 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                               __null 
# 4087 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    && g.NavWindow != 
# 4087 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      __null 
# 4087 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                           && GetTopMostPopupModal() == 
# 4087 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                        __null
# 4087 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                            )
        {

            FocusWindow(
# 4090 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                       __null
# 4090 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           );
        }
    }




    if (g.IO.MouseClicked[1])
    {


        ImGuiWindow* modal = GetTopMostPopupModal();
        bool hovered_window_above_modal = g.HoveredWindow && (modal == 
# 4102 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                      __null 
# 4102 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                           || IsWindowAbove(g.HoveredWindow, modal));
        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
    }
}

static bool IsWindowActiveAndVisible(ImGuiWindow* window)
{
    return (window->Active) && (!window->Hidden);
}

static void UpdateAliasKey(ImGuiKey key, bool v, float analog_value)
{
    
# 4114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   ImGui::IsAliasKey(key)
# 4114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "ImGui::IsAliasKey(key)"
# 4114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4114, __extension__ __PRETTY_FUNCTION__))
# 4114 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;
    ImGuiKeyData* key_data = ImGui::GetKeyData(key);
    key_data->Down = v;
    key_data->AnalogValue = analog_value;
}





static void UpdateKeyRoutingTable(ImGuiKeyRoutingTable* rt)
{
    ImGuiContext& g = *GImGui;
    rt->EntriesNext.resize(0);
    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
    {
        const int new_routing_start_idx = rt->EntriesNext.Size;
        ImGuiKeyRoutingData* routing_entry;
        for (int old_routing_idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry->NextEntryIndex)
        {
            routing_entry = &rt->Entries[old_routing_idx];
            routing_entry->RoutingCurr = routing_entry->RoutingNext;
            routing_entry->RoutingNext = ((ImGuiID)-1);
            routing_entry->RoutingNextScore = 255;
            if (routing_entry->RoutingCurr == ((ImGuiID)-1))
                continue;
            rt->EntriesNext.push_back(*routing_entry);


            if (routing_entry->Mods == g.IO.KeyMods)
            {
                ImGuiKeyOwnerData* owner_data = ImGui::GetKeyOwnerData(key);
                if (owner_data->OwnerCurr == ((ImGuiID)-1))
                    owner_data->OwnerCurr = routing_entry->RoutingCurr;
            }
        }


        rt->Index[key - ImGuiKey_NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < rt->EntriesNext.Size ? new_routing_start_idx : -1);
        for (int n = new_routing_start_idx; n < rt->EntriesNext.Size; n++)
            rt->EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt->EntriesNext.Size) ? n + 1 : -1);
    }
    rt->Entries.swap(rt->EntriesNext);
}


static ImGuiKeyChord GetMergedModsFromBools()
{
    ImGuiContext& g = *GImGui;
    ImGuiKeyChord key_chord = 0;
    if (g.IO.KeyCtrl) { key_chord |= ImGuiMod_Ctrl; }
    if (g.IO.KeyShift) { key_chord |= ImGuiMod_Shift; }
    if (g.IO.KeyAlt) { key_chord |= ImGuiMod_Alt; }
    if (g.IO.KeySuper) { key_chord |= ImGuiMod_Super; }
    return key_chord;
}

static void ImGui::UpdateKeyboardInputs()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;



    if (io.BackendUsingLegacyKeyArrays == 0)
    {

        for (int n = 0; n < 512; n++)
            
# 4182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 4182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           (io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && "Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!"
# 4182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 4182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "(io.KeysDown[n] == false || IsKeyDown((ImGuiKey)n)) && \"Backend needs to either only use io.AddKeyEvent(), either only fill legacy io.KeysDown[] + io.KeyMap[]. Not both!\""
# 4182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4182, __extension__ __PRETTY_FUNCTION__))
# 4182 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                                                ;
    }
    else
    {
        if (g.FrameCount == 0)
            for (int n = 0; n < 512; n++)
                
# 4188 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               (static_cast <bool> (
# 4188 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               g.IO.KeyMap[n] == -1 && "Backend is not allowed to write to io.KeyMap[0..511]!"
# 4188 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               ) ? void (0) : __assert_fail (
# 4188 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               "g.IO.KeyMap[n] == -1 && \"Backend is not allowed to write to io.KeyMap[0..511]!\""
# 4188 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4188, __extension__ __PRETTY_FUNCTION__))
# 4188 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                         ;


        for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; n++)
            if (io.KeyMap[n] != -1)
            {
                
# 4194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               (static_cast <bool> (
# 4194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               IsLegacyKey((ImGuiKey)io.KeyMap[n])
# 4194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               ) ? void (0) : __assert_fail (
# 4194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               "IsLegacyKey((ImGuiKey)io.KeyMap[n])"
# 4194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4194, __extension__ __PRETTY_FUNCTION__))
# 4194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                             ;
                io.KeyMap[io.KeyMap[n]] = n;
            }


        for (int n = 0; n < 512; n++)
            if (io.KeysDown[n] || io.BackendUsingLegacyKeyArrays == 1)
            {
                const ImGuiKey key = (ImGuiKey)(io.KeyMap[n] != -1 ? io.KeyMap[n] : n);
                
# 4203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               (static_cast <bool> (
# 4203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               io.KeyMap[n] == -1 || IsNamedKey(key)
# 4203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               ) ? void (0) : __assert_fail (
# 4203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               "io.KeyMap[n] == -1 || IsNamedKey(key)"
# 4203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4203, __extension__ __PRETTY_FUNCTION__))
# 4203 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                               ;
                io.KeysData[key].Down = io.KeysDown[n];
                if (key != n)
                    io.KeysDown[key] = io.KeysDown[n];
                io.BackendUsingLegacyKeyArrays = 1;
            }
        if (io.BackendUsingLegacyKeyArrays == 1)
        {
            GetKeyData(ImGuiMod_Ctrl)->Down = io.KeyCtrl;
            GetKeyData(ImGuiMod_Shift)->Down = io.KeyShift;
            GetKeyData(ImGuiMod_Alt)->Down = io.KeyAlt;
            GetKeyData(ImGuiMod_Super)->Down = io.KeySuper;
        }
    }


    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    if (io.BackendUsingLegacyNavInputArray && nav_gamepad_active)
    {


        do { io.KeysData[ImGuiKey_GamepadFaceDown].Down = (io.NavInputs[ImGuiNavInput_Activate] > 0.0f); io.KeysData[ImGuiKey_GamepadFaceDown].AnalogValue = io.NavInputs[ImGuiNavInput_Activate]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadFaceRight].Down = (io.NavInputs[ImGuiNavInput_Cancel] > 0.0f); io.KeysData[ImGuiKey_GamepadFaceRight].AnalogValue = io.NavInputs[ImGuiNavInput_Cancel]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadFaceLeft].Down = (io.NavInputs[ImGuiNavInput_Menu] > 0.0f); io.KeysData[ImGuiKey_GamepadFaceLeft].AnalogValue = io.NavInputs[ImGuiNavInput_Menu]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadFaceUp].Down = (io.NavInputs[ImGuiNavInput_Input] > 0.0f); io.KeysData[ImGuiKey_GamepadFaceUp].AnalogValue = io.NavInputs[ImGuiNavInput_Input]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadDpadLeft].Down = (io.NavInputs[ImGuiNavInput_DpadLeft] > 0.0f); io.KeysData[ImGuiKey_GamepadDpadLeft].AnalogValue = io.NavInputs[ImGuiNavInput_DpadLeft]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadDpadRight].Down = (io.NavInputs[ImGuiNavInput_DpadRight] > 0.0f); io.KeysData[ImGuiKey_GamepadDpadRight].AnalogValue = io.NavInputs[ImGuiNavInput_DpadRight]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadDpadUp].Down = (io.NavInputs[ImGuiNavInput_DpadUp] > 0.0f); io.KeysData[ImGuiKey_GamepadDpadUp].AnalogValue = io.NavInputs[ImGuiNavInput_DpadUp]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadDpadDown].Down = (io.NavInputs[ImGuiNavInput_DpadDown] > 0.0f); io.KeysData[ImGuiKey_GamepadDpadDown].AnalogValue = io.NavInputs[ImGuiNavInput_DpadDown]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadL1].Down = (io.NavInputs[ImGuiNavInput_FocusPrev] > 0.0f) || (io.NavInputs[ImGuiNavInput_TweakSlow] > 0.0f); io.KeysData[ImGuiKey_GamepadL1].AnalogValue = ImMax(io.NavInputs[ImGuiNavInput_FocusPrev], io.NavInputs[ImGuiNavInput_TweakSlow]); } while (0);
        do { io.KeysData[ImGuiKey_GamepadR1].Down = (io.NavInputs[ImGuiNavInput_FocusNext] > 0.0f) || (io.NavInputs[ImGuiNavInput_TweakFast] > 0.0f); io.KeysData[ImGuiKey_GamepadR1].AnalogValue = ImMax(io.NavInputs[ImGuiNavInput_FocusNext], io.NavInputs[ImGuiNavInput_TweakFast]); } while (0);
        do { io.KeysData[ImGuiKey_GamepadLStickLeft].Down = (io.NavInputs[ImGuiNavInput_LStickLeft] > 0.0f); io.KeysData[ImGuiKey_GamepadLStickLeft].AnalogValue = io.NavInputs[ImGuiNavInput_LStickLeft]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadLStickRight].Down = (io.NavInputs[ImGuiNavInput_LStickRight] > 0.0f); io.KeysData[ImGuiKey_GamepadLStickRight].AnalogValue = io.NavInputs[ImGuiNavInput_LStickRight]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadLStickUp].Down = (io.NavInputs[ImGuiNavInput_LStickUp] > 0.0f); io.KeysData[ImGuiKey_GamepadLStickUp].AnalogValue = io.NavInputs[ImGuiNavInput_LStickUp]; } while (0);
        do { io.KeysData[ImGuiKey_GamepadLStickDown].Down = (io.NavInputs[ImGuiNavInput_LStickDown] > 0.0f); io.KeysData[ImGuiKey_GamepadLStickDown].AnalogValue = io.NavInputs[ImGuiNavInput_LStickDown]; } while (0);

    }





    io.KeyMods = GetMergedModsFromBools();
    for (int n = 0; n < ImGuiMouseButton_COUNT; n++)
        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0f : 0.0f);
    UpdateAliasKey(ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0f, io.MouseWheelH);
    UpdateAliasKey(ImGuiKey_MouseWheelY, io.MouseWheel != 0.0f, io.MouseWheel);


    if ((io.BackendFlags & ImGuiBackendFlags_HasGamepad) == 0)
        for (int i = (ImGuiKey_GamepadStart); i < (ImGuiKey_GamepadRStickDown + 1); i++)
        {
            io.KeysData[i - ImGuiKey_KeysData_OFFSET].Down = false;
            io.KeysData[i - ImGuiKey_KeysData_OFFSET].AnalogValue = 0.0f;
        }


    for (int i = 0; i < ImGuiKey_KeysData_SIZE; i++)
    {
        ImGuiKeyData* key_data = &io.KeysData[i];
        key_data->DownDurationPrev = key_data->DownDuration;
        key_data->DownDuration = key_data->Down ? (key_data->DownDuration < 0.0f ? 0.0f : key_data->DownDuration + io.DeltaTime) : -1.0f;
    }


    for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
    {
        ImGuiKeyData* key_data = &io.KeysData[key - ImGuiKey_KeysData_OFFSET];
        ImGuiKeyOwnerData* owner_data = &g.KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN];
        owner_data->OwnerCurr = owner_data->OwnerNext;
        if (!key_data->Down)
            owner_data->OwnerNext = ((ImGuiID)-1);
        owner_data->LockThisFrame = owner_data->LockUntilRelease = owner_data->LockUntilRelease && key_data->Down;
    }

    UpdateKeyRoutingTable(&g.KeysRoutingTable);
}

static void ImGui::UpdateMouseInputs()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;


    if (IsMousePosValid(&io.MousePos))
        io.MousePos = g.MouseLastValidPos = ImFloorSigned(io.MousePos);


    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev))
        io.MouseDelta = io.MousePos - io.MousePosPrev;
    else
        io.MouseDelta = ImVec2(0.0f, 0.0f);


    if (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    io.MousePosPrev = io.MousePos;
    for (int i = 0; i < ((int)(sizeof(io.MouseDown) / sizeof(*(io.MouseDown)))); i++)
    {
        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0f;
        io.MouseClickedCount[i] = 0;
        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0f;
        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0f ? 0.0f : io.MouseDownDuration[i] + io.DeltaTime) : -1.0f;
        if (io.MouseClicked[i])
        {
            bool is_repeated_click = false;
            if ((float)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
            {
                ImVec2 delta_from_click_pos = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)
                    is_repeated_click = true;
            }
            if (is_repeated_click)
                io.MouseClickedLastCount[i]++;
            else
                io.MouseClickedLastCount[i] = 1;
            io.MouseClickedTime[i] = g.Time;
            io.MouseClickedPos[i] = io.MousePos;
            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
            io.MouseDragMaxDistanceSqr[i] = 0.0f;
        }
        else if (io.MouseDown[i])
        {

            float delta_sqr_click_pos = IsMousePosValid(&io.MousePos) ? ImLengthSqr(io.MousePos - io.MouseClickedPos[i]) : 0.0f;
            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], delta_sqr_click_pos);
        }


        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);


        if (io.MouseClicked[i])
            g.NavDisableMouseHover = false;
    }
}

static void LockWheelingWindow(ImGuiWindow* window, float wheel_amount)
{
    ImGuiContext& g = *GImGui;
    if (window)
        g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
    else
        g.WheelingWindowReleaseTimer = 0.0f;
    if (g.WheelingWindow == window)
        return;
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("LockWheelingWindow() \"%s\"\n", window ? window->Name : "NULL"); } while (0);
    g.WheelingWindow = window;
    g.WheelingWindowRefMousePos = g.IO.MousePos;
}

void ImGui::UpdateMouseWheel()
{
    ImGuiContext& g = *GImGui;


    if (g.WheelingWindow != 
# 4361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                           __null
# 4361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                               )
    {
        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold)
            g.WheelingWindowReleaseTimer = 0.0f;
        if (g.WheelingWindowReleaseTimer <= 0.0f)
            LockWheelingWindow(
# 4367 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                              __null
# 4367 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  , 0.0f);
    }

    ImVec2 wheel;
    wheel.x = TestKeyOwner(ImGuiKey_MouseWheelX, ((ImGuiID)-1)) ? g.IO.MouseWheelH : 0.0f;
    wheel.y = TestKeyOwner(ImGuiKey_MouseWheelY, ((ImGuiID)-1)) ? g.IO.MouseWheel : 0.0f;
    if (wheel.x == 0.0f && wheel.y == 0.0f)
        return;


    ImGuiWindow* mouse_window = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
    if (!mouse_window || mouse_window->Collapsed)
        return;



    if (wheel.y != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
    {
        LockWheelingWindow(mouse_window, wheel.y);
        ImGuiWindow* window = mouse_window;
        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
        const float scale = new_font_scale / window->FontWindowScale;
        window->FontWindowScale = new_font_scale;
        if (window == window->RootWindow)
        {
            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            SetWindowPos(window, window->Pos + offset, 0);
            window->Size = ImFloor(window->Size * scale);
            window->SizeFull = ImFloor(window->SizeFull * scale);
        }
        return;
    }
    if (g.IO.KeyCtrl)
        return;




    const bool swap_axis = g.IO.KeyShift && !g.IO.ConfigMacOSXBehaviors;
    if (swap_axis)
    {
        wheel.x = wheel.y;
        wheel.y = 0.0f;
    }






    if (wheel.y != 0.0f)
    {
        ImGuiWindow* window = mouse_window;
        while ((window->Flags & ImGuiWindowFlags_ChildWindow) && ((window->ScrollMax.y == 0.0f) || ((window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))))
            window = window->ParentWindow;
        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
        {
            LockWheelingWindow(mouse_window, wheel.y);
            float max_step = window->InnerRect.GetHeight() * 0.67f;
            float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step));
            SetScrollY(window, window->Scroll.y - wheel.y * scroll_step);
        }
    }


    if (wheel.x != 0.0f)
    {
        ImGuiWindow* window = mouse_window;
        while ((window->Flags & ImGuiWindowFlags_ChildWindow) && ((window->ScrollMax.x == 0.0f) || ((window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))))
            window = window->ParentWindow;
        if (!(window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(window->Flags & ImGuiWindowFlags_NoMouseInputs))
        {
            LockWheelingWindow(mouse_window, wheel.x);
            float max_step = window->InnerRect.GetWidth() * 0.67f;
            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step));
            SetScrollX(window, window->Scroll.x - wheel.x * scroll_step);
        }
    }
}


void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;
    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING));





    bool clear_hovered_windows = false;
    FindHoveredWindow();


    ImGuiWindow* modal_window = GetTopMostPopupModal();
    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow->RootWindow, modal_window))
        clear_hovered_windows = true;


    if (io.ConfigFlags & ImGuiConfigFlags_NoMouse)
        clear_hovered_windows = true;



    const bool has_open_popup = (g.OpenPopupStack.Size > 0);
    const bool has_open_modal = (modal_window != 
# 4473 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                __null
# 4473 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                    );
    int mouse_earliest_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < ((int)(sizeof(io.MouseDown) / sizeof(*(io.MouseDown)))); i++)
    {
        if (io.MouseClicked[i])
        {
            io.MouseDownOwned[i] = (g.HoveredWindow != 
# 4480 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      __null
# 4480 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                          ) || has_open_popup;
            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != 
# 4481 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                      __null
# 4481 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                          ) || has_open_modal;
        }
        mouse_any_down |= io.MouseDown[i];
        if (io.MouseDown[i])
            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])
                mouse_earliest_down = i;
    }
    const bool mouse_avail = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
    const bool mouse_avail_unless_popup_close = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];



    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail && !mouse_dragging_extern_payload)
        clear_hovered_windows = true;

    if (clear_hovered_windows)
        g.HoveredWindow = g.HoveredWindowUnderMovingWindow = 
# 4498 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                            __null
# 4498 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                ;



    if (g.WantCaptureMouseNextFrame != -1)
    {
        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
    }
    else
    {
        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != 
# 4508 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                 __null 
# 4508 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                      || mouse_any_down)) || has_open_popup;
        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != 
# 4509 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                    __null 
# 4509 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                         || mouse_any_down)) || has_open_modal;
    }


    if (g.WantCaptureKeyboardNextFrame != -1)
        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        io.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != 
# 4516 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                      __null
# 4516 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                          );
    if (io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(io.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        io.WantCaptureKeyboard = true;


    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

void ImGui::NewFrame()
{
    
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   GImGui != 
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?"
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "GImGui != __null && \"No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?\""
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4526, __extension__ __PRETTY_FUNCTION__))
# 4526 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                          ;
    ImGuiContext& g = *GImGui;



    for (int n = g.Hooks.Size - 1; n >= 0; n--)
        if (g.Hooks[n].Type == ImGuiContextHookType_PendingRemoval_)
            g.Hooks.erase(&g.Hooks[n]);

    CallContextHooks(&g, ImGuiContextHookType_NewFramePre);


    ErrorCheckNewFrameSanityChecks();


    UpdateSettings();

    g.Time += g.IO.DeltaTime;
    g.WithinFrameScope = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;
    g.MenusIdSubmittedThisFrame.resize(0);


    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % ((int)(sizeof(g.FramerateSecPerFrame) / sizeof(*(g.FramerateSecPerFrame))));
    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, ((int)(sizeof(g.FramerateSecPerFrame) / sizeof(*(g.FramerateSecPerFrame)))));
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)g.FramerateSecPerFrameCount)) : 3.40282346638528859811704183484516925e+38F;

    UpdateViewportsNewFrame();


    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    
# 4562 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4562 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Font->IsLoaded()
# 4562 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4562 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Font->IsLoaded()"
# 4562 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4562, __extension__ __PRETTY_FUNCTION__))
# 4562 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                ;
    ImRect virtual_space(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    for (int n = 0; n < g.Viewports.Size; n++)
        virtual_space.Add(g.Viewports[n]->GetMainRect());
    g.DrawListSharedData.ClipRectFullscreen = virtual_space.ToVec4();
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
    g.DrawListSharedData.InitialFlags = ImDrawListFlags_None;
    if (g.Style.AntiAliasedLines)
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLines;
    if (g.Style.AntiAliasedLinesUseTex && !(g.Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines))
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedLinesUseTex;
    if (g.Style.AntiAliasedFill)
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AntiAliasedFill;
    if (g.IO.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset)
        g.DrawListSharedData.InitialFlags |= ImDrawListFlags_AllowVtxOffset;


    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->DrawDataP.Clear();
    }


    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);


    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        g.HoveredIdNotActiveTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    if (g.HoveredId && g.ActiveId != g.HoveredId)
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    g.HoveredIdDisabled = false;




    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) ImGui::DebugLog("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n"); } while (0);
        ClearActiveID();
    }


    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdHasBeenEditedThisFrame = false;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)
        g.TempInputId = 0;
    if (g.ActiveId == 0)
    {
        g.ActiveIdUsingNavDirMask = 0x00;
        g.ActiveIdUsingAllKeyboardKeys = false;

        g.ActiveIdUsingNavInputMask = 0x00;

    }


    if (g.ActiveId == 0)
        g.ActiveIdUsingNavInputMask = 0;
    else if (g.ActiveIdUsingNavInputMask != 0)
    {


        if (g.ActiveIdUsingNavInputMask & (1 << ImGuiNavInput_Cancel))
            SetKeyOwner(ImGuiKey_Escape, g.ActiveId);
        if (g.ActiveIdUsingNavInputMask & ~(1 << ImGuiNavInput_Cancel))
            
# 4645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 4645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           0
# 4645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 4645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "0"
# 4645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4645, __extension__ __PRETTY_FUNCTION__))
# 4645 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                       ;
    }



    g.HoverDelayIdPreviousFrame = g.HoverDelayId;
    if (g.HoverDelayId != 0)
    {

        g.HoverDelayTimer += g.IO.DeltaTime;
        g.HoverDelayClearTimer = 0.0f;
        g.HoverDelayId = 0;
    }
    else if (g.HoverDelayTimer > 0.0f)
    {

        g.HoverDelayClearTimer += g.IO.DeltaTime;
        if (g.HoverDelayClearTimer >= ImMax(0.20f, g.IO.DeltaTime * 2.0f))
            g.HoverDelayTimer = g.HoverDelayClearTimer = 0.0f;
    }


    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = 3.40282346638528859811704183484516925e+38F;
    g.DragDropWithinSource = false;
    g.DragDropWithinTarget = false;
    g.DragDropHoldJustPressedId = 0;






    g.InputEventsTrail.resize(0);
    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);


    UpdateKeyboardInputs();







    NavUpdate();


    UpdateMouseInputs();



    UpdateHoveredWindowAndCaptureFlags();


    UpdateMouseMovingWindowNewFrame();


    if (GetTopMostPopupModal() != 
# 4704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                 __null 
# 4704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                      || (g.NavWindowingTarget != 
# 4704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                  __null 
# 4704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                       && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = ImGuiMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;


    g.PlatformImeDataPrev = g.PlatformImeData;
    g.PlatformImeData.WantVisible = false;


    UpdateMouseWheel();


    
# 4720 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4720 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WindowsFocusOrder.Size <= g.Windows.Size
# 4720 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4720 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WindowsFocusOrder.Size <= g.Windows.Size"
# 4720 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4720, __extension__ __PRETTY_FUNCTION__))
# 4720 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                        ;
    const float memory_compact_start_time = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0f) ? 3.40282346638528859811704183484516925e+38F : (float)g.Time - g.IO.ConfigMemoryCompactTimer;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->Active = false;
        window->WriteAccessed = false;
        window->BeginCountPreviousFrame = window->BeginCount;
        window->BeginCount = 0;


        if (!window->WasActive && !window->MemoryCompacted && window->LastTimeActive < memory_compact_start_time)
            GcCompactTransientWindowBuffers(window);
    }


    for (int i = 0; i < g.TablesLastTimeActive.Size; i++)
        if (g.TablesLastTimeActive[i] >= 0.0f && g.TablesLastTimeActive[i] < memory_compact_start_time)
            TableGcCompactTransientBuffers(g.Tables.GetByIndex(i));
    for (int i = 0; i < g.TablesTempData.Size; i++)
        if (g.TablesTempData[i].LastTimeActive >= 0.0f && g.TablesTempData[i].LastTimeActive < memory_compact_start_time)
            TableGcCompactTransientBuffers(&g.TablesTempData[i]);
    if (g.GcCompactAll)
        GcCompactTransientMiscBuffers();
    g.GcCompactAll = false;


    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusTopMostWindowUnderOne(
# 4749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                  __null
# 4749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                      , 
# 4749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                        __null
# 4749 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            );



    g.CurrentWindowStack.resize(0);
    g.BeginPopupStack.resize(0);
    g.ItemFlagsStack.resize(0);
    g.ItemFlagsStack.push_back(ImGuiItemFlags_None);
    g.GroupStack.resize(0);


    UpdateDebugToolItemPicker();
    UpdateDebugToolStackQueries();
    if (g.DebugLocateFrames > 0 && --g.DebugLocateFrames == 0)
        g.DebugLocateId = 0;




    g.WithinFrameScopeWithImplicitWindow = true;
    SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
    Begin("Debug##Default");
    
# 4771 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4771 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.CurrentWindow->IsFallbackWindow == true
# 4771 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4771 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.CurrentWindow->IsFallbackWindow == true"
# 4771 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4771, __extension__ __PRETTY_FUNCTION__))
# 4771 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                       ;

    CallContextHooks(&g, ImGuiContextHookType_NewFramePost);
}


static const ImGuiLocEntry GLocalizationEntriesEnUS[] =
{
    { ImGuiLocKey_TableSizeOne, "Size column to fit###SizeOne" },
    { ImGuiLocKey_TableSizeAllFit, "Size all columns to fit###SizeAll" },
    { ImGuiLocKey_TableSizeAllDefault, "Size all columns to default###SizeAll" },
    { ImGuiLocKey_TableResetOrder, "Reset order###ResetOrder" },
    { ImGuiLocKey_WindowingMainMenuBar, "(Main menu bar)" },
    { ImGuiLocKey_WindowingPopup, "(Popup)" },
    { ImGuiLocKey_WindowingUntitled, "(Untitled)" },
};

void ImGui::Initialize()
{
    ImGuiContext& g = *GImGui;
    
# 4791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   !g.Initialized && !g.SettingsLoaded
# 4791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "!g.Initialized && !g.SettingsLoaded"
# 4791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4791, __extension__ __PRETTY_FUNCTION__))
# 4791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                 ;


    {
        ImGuiSettingsHandler ini_handler;
        ini_handler.TypeName = "Window";
        ini_handler.TypeHash = ImHashStr("Window");
        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
        AddSettingsHandler(&ini_handler);
    }
    TableSettingsAddSettingsHandler();


    LocalizeRegisterEntries(GLocalizationEntriesEnUS, ((int)(sizeof(GLocalizationEntriesEnUS) / sizeof(*(GLocalizationEntriesEnUS)))));


    ImGuiViewportP* viewport = new(ImNewWrapper(), ImGui::MemAlloc(sizeof(ImGuiViewportP))) ImGuiViewportP();
    g.Viewports.push_back(viewport);
    g.TempBuffer.resize(1024 * 3 + 1, 0);




    g.Initialized = true;
}


void ImGui::Shutdown()
{

    ImGuiContext& g = *GImGui;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts->Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = 
# 4831 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                __null
# 4831 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                    ;
    g.DrawListSharedData.TempBuffer.clear();


    if (!g.Initialized)
        return;


    if (g.SettingsLoaded && g.IO.IniFilename != 
# 4839 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                               __null
# 4839 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   )
        SaveIniSettingsToDisk(g.IO.IniFilename);

    CallContextHooks(&g, ImGuiContextHookType_Shutdown);


    g.Windows.clear_delete();
    g.WindowsFocusOrder.clear();
    g.WindowsTempSortBuffer.clear();
    g.CurrentWindow = 
# 4848 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                     __null
# 4848 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         ;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = 
# 4851 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                 __null
# 4851 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;
    g.HoveredWindow = g.HoveredWindowUnderMovingWindow = 
# 4852 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                        __null
# 4852 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            ;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = 
# 4853 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      __null
# 4853 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                          ;
    g.MovingWindow = 
# 4854 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                    __null
# 4854 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        ;

    g.KeysRoutingTable.Clear();

    g.ColorStack.clear();
    g.StyleVarStack.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.BeginPopupStack.clear();

    g.Viewports.clear_delete();

    g.TabBars.Clear();
    g.CurrentTabBarStack.clear();
    g.ShrinkWidthBuffer.clear();

    g.ClipperTempData.clear_destruct();

    g.Tables.Clear();
    g.TablesTempData.clear_destruct();
    g.DrawChannelsTempMergeBuffer.clear();

    g.ClipboardHandlerData.clear();
    g.MenusIdSubmittedThisFrame.clear();
    g.InputTextState.ClearFreeMemory();

    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile)
    {

        if (g.LogFile != 
# 4886 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        stdout
# 4886 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              )

            ImFileClose(g.LogFile);
        g.LogFile = 
# 4889 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   __null
# 4889 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                       ;
    }
    g.LogBuffer.clear();
    g.DebugLogBuf.clear();
    g.DebugLogIndex.clear();

    g.Initialized = false;
}


static int ChildWindowComparer(const void* lhs, const void* rhs)
{
    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        ImQsort(window->DC.ChildWindows.Data, (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            ImGuiWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    if (draw_list->CmdBuffer.Size == 0)
        return;
    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == 
# 4930 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                           __null
# 4930 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                               )
        return;



    
# 4935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size
# 4935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size"
# 4935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4935, __extension__ __PRETTY_FUNCTION__))
# 4935 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                ;
    
# 4936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 4936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size
# 4936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 4936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size"
# 4936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4936, __extension__ __PRETTY_FUNCTION__))
# 4936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                ;
    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
        
# 4938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 4938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size
# 4938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 4938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size"
# 4938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4938, __extension__ __PRETTY_FUNCTION__))
# 4938 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             ;
# 4955 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    if (sizeof(ImDrawIdx) == 2)
        
# 4956 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 4956 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above"
# 4956 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 4956 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "draw_list->_VtxCurrentIdx < (1 << 16) && \"Too many vertices in ImDrawList using 16-bit indices. Read comment above\""
# 4956 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 4956, __extension__ __PRETTY_FUNCTION__))
# 4956 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                     ;

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImGuiWindow* window, int layer)
{
    ImGuiContext& g = *GImGui;
    ImGuiViewportP* viewport = g.Viewports[0];
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[layer], window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        ImGuiWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child))
            AddWindowToDrawData(child, layer);
    }
}

static inline int GetWindowDisplayLayer(ImGuiWindow* window)
{
    return (window->Flags & ImGuiWindowFlags_Tooltip) ? 1 : 0;
}


static inline void AddRootWindowToDrawData(ImGuiWindow* window)
{
    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < ((int)(sizeof(Layers) / sizeof(*(Layers)))); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < ((int)(sizeof(Layers) / sizeof(*(Layers)))); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupViewportDrawData(ImGuiViewportP* viewport, ImVector<ImDrawList*>* draw_lists)
{
    ImGuiIO& io = ImGui::GetIO();
    ImDrawData* draw_data = &viewport->DrawDataP;
    draw_data->Valid = true;
    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : 
# 5009 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                     __null
# 5009 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         ;
    draw_data->CmdListsCount = draw_lists->Size;
    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    draw_data->DisplayPos = viewport->Pos;
    draw_data->DisplaySize = viewport->Size;
    draw_data->FramebufferScale = io.DisplayFramebufferScale;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        ImDrawList* draw_list = draw_lists->Data[n];
        draw_list->_PopUnusedDrawCmd();
        draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
        draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
    }
}







void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

static void ImGui::RenderDimmedBackgroundBehindWindow(ImGuiWindow* window, ImU32 col)
{
    if ((col & 0xFF000000) == 0)
        return;

    ImGuiViewportP* viewport = (ImGuiViewportP*)GetMainViewport();
    ImRect viewport_rect = viewport->GetMainRect();


    {



        ImDrawList* draw_list = window->RootWindow->DrawList;
        if (draw_list->CmdBuffer.Size == 0)
            draw_list->AddDrawCmd();
        draw_list->PushClipRect(viewport_rect.Min - ImVec2(1, 1), viewport_rect.Max + ImVec2(1, 1), false);
        draw_list->AddRectFilled(viewport_rect.Min, viewport_rect.Max, col);
        ImDrawCmd cmd = draw_list->CmdBuffer.back();
        
# 5063 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 5063 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       cmd.ElemCount == 6
# 5063 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 5063 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "cmd.ElemCount == 6"
# 5063 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5063, __extension__ __PRETTY_FUNCTION__))
# 5063 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;
        draw_list->CmdBuffer.pop_back();
        draw_list->CmdBuffer.push_front(cmd);
        draw_list->PopClipRect();
        draw_list->AddDrawCmd();
    }
}

ImGuiWindow* ImGui::FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* parent_window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* bottom_most_visible_window = parent_window;
    for (int i = FindWindowDisplayIndex(parent_window); i >= 0; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_ChildWindow)
            continue;
        if (!IsWindowWithinBeginStackOf(window, parent_window))
            break;
        if (IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window))
            bottom_most_visible_window = window;
    }
    return bottom_most_visible_window;
}

static void ImGui::RenderDimmedBackgrounds()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* modal_window = GetTopMostAndVisiblePopupModal();
    if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
        return;
    const bool dim_bg_for_modal = (modal_window != 
# 5094 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  __null
# 5094 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      );
    const bool dim_bg_for_window_list = (g.NavWindowingTargetAnim != 
# 5095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                    __null 
# 5095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         && g.NavWindowingTargetAnim->Active);
    if (!dim_bg_for_modal && !dim_bg_for_window_list)
        return;

    if (dim_bg_for_modal)
    {

        ImGuiWindow* dim_behind_window = FindBottomMostVisibleWindowWithinBeginStack(modal_window);
        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(ImGuiCol_ModalWindowDimBg, g.DimBgRatio));
    }
    else if (dim_bg_for_window_list)
    {

        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_NavWindowingDimBg, g.DimBgRatio));


        ImGuiWindow* window = g.NavWindowingTargetAnim;
        ImGuiViewport* viewport = GetMainViewport();
        float distance = g.FontSize;
        ImRect bb = window->Rect();
        bb.Expand(distance);
        if (bb.GetWidth() >= viewport->Size.x && bb.GetHeight() >= viewport->Size.y)
            bb.Expand(-distance - 1.0f);
        if (window->DrawList->CmdBuffer.Size == 0)
            window->DrawList->AddDrawCmd();
        window->DrawList->PushClipRect(viewport->Pos, viewport->Pos + viewport->Size);
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window->WindowRounding, 0, 3.0f);
        window->DrawList->PopClipRect();
    }
}


void ImGui::EndFrame()
{
    ImGuiContext& g = *GImGui;
    
# 5130 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5130 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Initialized
# 5130 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5130 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Initialized"
# 5130 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5130, __extension__ __PRETTY_FUNCTION__))
# 5130 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;


    if (g.FrameCountEnded == g.FrameCount)
        return;
    
# 5135 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5135 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?"
# 5135 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5135 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WithinFrameScope && \"Forgot to call ImGui::NewFrame()?\""
# 5135 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5135, __extension__ __PRETTY_FUNCTION__))
# 5135 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                       ;

    CallContextHooks(&g, ImGuiContextHookType_EndFramePre);

    ErrorCheckEndFrameSanityChecks();


    if (g.IO.SetPlatformImeDataFn && memcmp(&g.PlatformImeData, &g.PlatformImeDataPrev, sizeof(ImGuiPlatformImeData)) != 0)
        g.IO.SetPlatformImeDataFn(GetMainViewport(), &g.PlatformImeData);


    g.WithinFrameScopeWithImplicitWindow = false;
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();


    NavEndFrame();


    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }


    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
    {
        g.DragDropWithinSource = true;
        SetTooltip("...");
        g.DragDropWithinSource = false;
    }


    g.WithinFrameScope = false;
    g.FrameCountEnded = g.FrameCount;


    UpdateMouseMovingWindowEndFrame();



    g.WindowsTempSortBuffer.resize(0);
    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))
            continue;
        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
    }


    
# 5191 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5191 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Windows.Size == g.WindowsTempSortBuffer.Size
# 5191 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5191 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Windows.Size == g.WindowsTempSortBuffer.Size"
# 5191 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5191, __extension__ __PRETTY_FUNCTION__))
# 5191 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            ;
    g.Windows.swap(g.WindowsTempSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;


    g.IO.Fonts->Locked = false;


    g.IO.AppFocusLost = false;
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    g.IO.InputQueueCharacters.resize(0);

    CallContextHooks(&g, ImGuiContextHookType_EndFramePost);
}




void ImGui::Render()
{
    ImGuiContext& g = *GImGui;
    
# 5212 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5212 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Initialized
# 5212 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5212 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Initialized"
# 5212 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5212, __extension__ __PRETTY_FUNCTION__))
# 5212 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;

    if (g.FrameCountEnded != g.FrameCount)
        EndFrame();
    const bool first_render_of_frame = (g.FrameCountRendered != g.FrameCount);
    g.FrameCountRendered = g.FrameCount;
    g.IO.MetricsRenderWindows = 0;

    CallContextHooks(&g, ImGuiContextHookType_RenderPre);


    for (int n = 0; n != g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->DrawDataBuilder.Clear();
        if (viewport->DrawLists[0] != 
# 5227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                     __null
# 5227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                         )
            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
    }


    if (first_render_of_frame)
        RenderDimmedBackgrounds();


    ImGuiWindow* windows_to_render_top_most[2];
    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : 
# 5237 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                                                                          __null
# 5237 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                              ;
    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : 
# 5238 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                      __null
# 5238 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                          );
    for (int n = 0; n != g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        ;
        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1])
            AddRootWindowToDrawData(window);
    }
    for (int n = 0; n < ((int)(sizeof(windows_to_render_top_most) / sizeof(*(windows_to_render_top_most)))); n++)
        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n]))
            AddRootWindowToDrawData(windows_to_render_top_most[n]);


    if (g.IO.MouseDrawCursor && first_render_of_frame && g.MouseCursor != ImGuiMouseCursor_None)
        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(0)<<8) | ((ImU32)(0)<<0)), (((ImU32)(48)<<24) | ((ImU32)(0)<<16) | ((ImU32)(0)<<8) | ((ImU32)(0)<<0)));


    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = 0;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        viewport->DrawDataBuilder.FlattenIntoSingleLayer();


        if (viewport->DrawLists[1] != 
# 5262 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                     __null
# 5262 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                         )
            AddDrawListToDrawData(&viewport->DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));

        SetupViewportDrawData(viewport, &viewport->DrawDataBuilder.Layers[0]);
        ImDrawData* draw_data = &viewport->DrawDataP;
        g.IO.MetricsRenderVertices += draw_data->TotalVtxCount;
        g.IO.MetricsRenderIndices += draw_data->TotalIdxCount;
    }

    CallContextHooks(&g, ImGuiContextHookType_RenderPost);
}



ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    ImGuiContext& g = *GImGui;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return ImVec2(0.0f, font_size);
    ImVec2 text_size = font->CalcTextSizeA(font_size, 3.40282346638528859811704183484516925e+38F, wrap_width, text, text_display_end, 
# 5290 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                  __null
# 5290 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                      );






    text_size.x = ((float)(int)(text_size.x + 0.99999f));

    return text_size;
}





static void FindHoveredWindow()
{
    ImGuiContext& g = *GImGui;

    ImGuiWindow* hovered_window = 
# 5310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                 __null
# 5310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                     ;
    ImGuiWindow* hovered_window_ignoring_moving_window = 
# 5311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                        __null
# 5311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            ;
    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoMouseInputs))
        hovered_window = g.MovingWindow;

    ImVec2 padding_regular = g.Style.TouchExtraPadding;
    ImVec2 padding_for_resize = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        ;
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & ImGuiWindowFlags_NoMouseInputs)
            continue;


        ImRect bb(window->OuterRectClipped);
        if (window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize))
            bb.Expand(padding_regular);
        else
            bb.Expand(padding_for_resize);
        if (!bb.Contains(g.IO.MousePos))
            continue;



        if (window->HitTestHoleSize.x != 0)
        {
            ImVec2 hole_pos(window->Pos.x + (float)window->HitTestHoleOffset.x, window->Pos.y + (float)window->HitTestHoleOffset.y);
            ImVec2 hole_size((float)window->HitTestHoleSize.x, (float)window->HitTestHoleSize.y);
            if (ImRect(hole_pos, hole_pos + hole_size).Contains(g.IO.MousePos))
                continue;
        }

        if (hovered_window == 
# 5345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                             __null
# 5345 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 )
            hovered_window = window;
        ;
        if (hovered_window_ignoring_moving_window == 
# 5348 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                    __null 
# 5348 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                         && (!g.MovingWindow || window->RootWindow != g.MovingWindow->RootWindow))
            hovered_window_ignoring_moving_window = window;
        if (hovered_window && hovered_window_ignoring_moving_window)
            break;
    }

    g.HoveredWindow = hovered_window;
    g.HoveredWindowUnderMovingWindow = hovered_window_ignoring_moving_window;
}

bool ImGui::IsItemActive()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
        return g.ActiveId == g.LastItemData.ID;
    return false;
}

bool ImGui::IsItemActivated()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
        if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)
            return true;
    return false;
}

bool ImGui::IsItemDeactivated()
{
    ImGuiContext& g = *GImGui;
    if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDeactivated)
        return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Deactivated) != 0;
    return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID);
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
    ImGuiContext& g = *GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));
}


bool ImGui::IsItemFocused()
{
    ImGuiContext& g = *GImGui;
    if (g.NavId != g.LastItemData.ID || g.NavId == 0)
        return false;
    return true;
}



bool ImGui::IsItemClicked(ImGuiMouseButton mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsItemToggledOpen()
{
    ImGuiContext& g = *GImGui;
    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledOpen) ? true : false;
}

bool ImGui::IsItemToggledSelection()
{
    ImGuiContext& g = *GImGui;
    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_ToggledSelection) ? true : false;
}

bool ImGui::IsAnyItemHovered()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
    ImGuiContext& g = *GImGui;
    return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
    ImGuiContext& g = *GImGui;
    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Visible) != 0;
}

bool ImGui::IsItemEdited()
{
    ImGuiContext& g = *GImGui;
    return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}



void ImGui::SetItemAllowOverlap()
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = g.LastItemData.ID;
    if (g.HoveredId == id)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == id)
        g.ActiveIdAllowOverlap = true;
}


void ImGui::SetActiveIdUsingAllKeyboardKeys()
{
    ImGuiContext& g = *GImGui;
    
# 5463 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5463 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.ActiveId != 0
# 5463 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5463 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.ActiveId != 0"
# 5463 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5463, __extension__ __PRETTY_FUNCTION__))
# 5463 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             ;
    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir_COUNT) - 1;
    g.ActiveIdUsingAllKeyboardKeys = true;
    NavMoveRequestCancel();
}

ImVec2 ImGui::GetItemRectMin()
{
    ImGuiContext& g = *GImGui;
    return g.LastItemData.Rect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
    ImGuiContext& g = *GImGui;
    return g.LastItemData.Rect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
    ImGuiContext& g = *GImGui;
    return g.LastItemData.Rect.GetSize();
}

bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;

    flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow;
    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);


    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f);
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);


    const char* temp_window_name;
    if (name)
        ImFormatStringToTempBuffer(&temp_window_name, 
# 5508 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                     __null
# 5508 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                         , "%s/%s_%08X", parent_window->Name, name, id);
    else
        ImFormatStringToTempBuffer(&temp_window_name, 
# 5510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                     __null
# 5510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                         , "%s/%08X", parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(temp_window_name, 
# 5515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                      __null
# 5515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          , flags);
    g.Style.ChildBorderSize = backup_border_size;

    ImGuiWindow* child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = (ImS8)auto_fit_axises;



    if (child_window->BeginCount == 1)
        parent_window->DC.CursorPos = child_window->Pos;


    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayersActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id + 1, child_window);
        g.ActiveIdSource = ImGuiInputSource_Nav;
    }
    return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    
# 5546 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5546 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   id != 0
# 5546 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5546 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "id != 0"
# 5546 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5546, __extension__ __PRETTY_FUNCTION__))
# 5546 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;
    return BeginChildEx(
# 5547 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                       __null
# 5547 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           , id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    
# 5555 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5555 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WithinEndChild == false
# 5555 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5555 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WithinEndChild == false"
# 5555 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5555, __extension__ __PRETTY_FUNCTION__))
# 5555 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       ;
    
# 5556 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5556 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->Flags & ImGuiWindowFlags_ChildWindow
# 5556 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5556 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->Flags & ImGuiWindowFlags_ChildWindow"
# 5556 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5556, __extension__ __PRETTY_FUNCTION__))
# 5556 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                          ;

    g.WithinEndChild = true;
    if (window->BeginCount > 1)
    {
        End();
    }
    else
    {
        ImVec2 sz = window->Size;
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X))
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        ImGuiWindow* parent_window = g.CurrentWindow;
        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayersActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);


            if (window->DC.NavLayersActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
        }
        else
        {

            ItemAdd(bb, 0);
        }
        if (g.HoveredWindow == window)
            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    }
    g.WithinEndChild = false;
    g.LogLinePosY = -3.40282346638528859811704183484516925e+38F;
}


bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void ImGui::EndChildFrame()
{
    EndChild();
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags = enabled ? (window->SetWindowPosAllowFlags | flags) : (window->SetWindowPosAllowFlags & ~flags);
    window->SetWindowSizeAllowFlags = enabled ? (window->SetWindowSizeAllowFlags | flags) : (window->SetWindowSizeAllowFlags & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
    ImGuiID id = ImHashStr(name);
    return FindWindowByID(id);
}

static void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)
{
    window->Pos = ImFloor(ImVec2(settings->Pos.x, settings->Pos.y));
    if (settings->Size.x > 0 && settings->Size.y > 0)
        window->Size = window->SizeFull = ImFloor(ImVec2(settings->Size.x, settings->Size.y));
    window->Collapsed = settings->Collapsed;
}

static void UpdateWindowInFocusOrderList(ImGuiWindow* window, bool just_created, ImGuiWindowFlags new_flags)
{
    ImGuiContext& g = *GImGui;

    const bool new_is_explicit_child = (new_flags & ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_ChildMenu) != 0);
    const bool child_flag_changed = new_is_explicit_child != window->IsExplicitChild;
    if ((just_created || child_flag_changed) && !new_is_explicit_child)
    {
        
# 5651 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 5651 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       !g.WindowsFocusOrder.contains(window)
# 5651 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 5651 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "!g.WindowsFocusOrder.contains(window)"
# 5651 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5651, __extension__ __PRETTY_FUNCTION__))
# 5651 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                       ;
        g.WindowsFocusOrder.push_back(window);
        window->FocusOrder = (short)(g.WindowsFocusOrder.Size - 1);
    }
    else if (!just_created && child_flag_changed && new_is_explicit_child)
    {
        
# 5657 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 5657 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.WindowsFocusOrder[window->FocusOrder] == window
# 5657 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 5657 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.WindowsFocusOrder[window->FocusOrder] == window"
# 5657 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5657, __extension__ __PRETTY_FUNCTION__))
# 5657 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                   ;
        for (int n = window->FocusOrder + 1; n < g.WindowsFocusOrder.Size; n++)
            g.WindowsFocusOrder[n]->FocusOrder--;
        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window->FocusOrder);
        window->FocusOrder = -1;
    }
    window->IsExplicitChild = new_is_explicit_child;
}

static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;



    ImGuiWindow* window = new(ImNewWrapper(), ImGui::MemAlloc(sizeof(ImGuiWindow))) ImGuiWindow(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);


    const ImGuiViewport* main_viewport = ImGui::GetMainViewport();
    window->Pos = main_viewport->Pos + ImVec2(60, 60);


    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
        {

            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
            ApplyWindowSettings(window, settings);
        }
    window->DC.CursorStartPos = window->DC.CursorMaxPos = window->DC.IdealMaxPos = window->Pos;

    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
    else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        g.Windows.push_front(window);
    else
        g.Windows.push_back(window);

    return window;
}

static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)
{
    ImGuiContext& g = *GImGui;
    ImVec2 new_size = size_desired;
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)
    {

        ImRect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            ImGuiSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
        new_size.x = ((float)(int)(new_size.x));
        new_size.y = ((float)(int)(new_size.y));
    }


    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
    {
        ImGuiWindow* window_for_height = window;
        const float decoration_up_height = window_for_height->TitleBarHeight() + window_for_height->MenuBarHeight();
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, decoration_up_height + ImMax(0.0f, g.Style.WindowRounding - 1.0f));
    }
    return new_size;
}

static void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)
{
    bool preserve_old_content_sizes = false;
    if (window->Collapsed && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        preserve_old_content_sizes = true;
    else if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
        preserve_old_content_sizes = true;
    if (preserve_old_content_sizes)
    {
        *content_size_current = window->ContentSize;
        *content_size_ideal = window->ContentSizeIdeal;
        return;
    }

    content_size_current->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : ((float)(int)(window->DC.CursorMaxPos.x - window->DC.CursorStartPos.x));
    content_size_current->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : ((float)(int)(window->DC.CursorMaxPos.y - window->DC.CursorStartPos.y));
    content_size_ideal->x = (window->ContentSizeExplicit.x != 0.0f) ? window->ContentSizeExplicit.x : ((float)(int)(ImMax(window->DC.CursorMaxPos.x, window->DC.IdealMaxPos.x) - window->DC.CursorStartPos.x));
    content_size_ideal->y = (window->ContentSizeExplicit.y != 0.0f) ? window->ContentSizeExplicit.y : ((float)(int)(ImMax(window->DC.CursorMaxPos.y, window->DC.IdealMaxPos.y) - window->DC.CursorStartPos.y));
}

static ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();
    ImVec2 size_pad = window->WindowPadding * 2.0f;
    ImVec2 size_desired = size_contents + size_pad + ImVec2(0.0f, decoration_up_height);
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {

        return size_desired;
    }
    else
    {

        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
        ImVec2 size_min = style.WindowMinSize;
        if (is_popup || is_menu)
            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));

        ImVec2 avail_size = ImGui::GetMainViewport()->WorkSize;
        ImVec2 size_auto_fit = ImClamp(size_desired, size_min, ImMax(size_min, avail_size - style.DisplaySafeAreaPadding * 2.0f));



        ImVec2 size_auto_fit_after_constraint = CalcWindowSizeAfterConstraint(window, size_auto_fit);
        bool will_have_scrollbar_x = (size_auto_fit_after_constraint.x - size_pad.x - 0.0f < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar);
        bool will_have_scrollbar_y = (size_auto_fit_after_constraint.y - size_pad.y - decoration_up_height < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar)) || (window->Flags & ImGuiWindowFlags_AlwaysVerticalScrollbar);
        if (will_have_scrollbar_x)
            size_auto_fit.y += style.ScrollbarSize;
        if (will_have_scrollbar_y)
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)
{
    ImVec2 size_contents_current;
    ImVec2 size_contents_ideal;
    CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
    ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, size_contents_ideal);
    ImVec2 size_final = CalcWindowSizeAfterConstraint(window, size_auto_fit);
    return size_final;
}

static ImGuiCol GetWindowBgColorIdx(ImGuiWindow* window)
{
    if (window->Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        return ImGuiCol_PopupBg;
    if (window->Flags & ImGuiWindowFlags_ChildWindow)
        return ImGuiCol_ChildBg;
    return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);
    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm);
    ImVec2 size_expected = pos_max - pos_min;
    ImVec2 size_constrained = CalcWindowSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}


struct ImGuiResizeGripDef
{
    ImVec2 CornerPosN;
    ImVec2 InnerDir;
    int AngleMin12, AngleMax12;
};
static const ImGuiResizeGripDef resize_grip_def[4] =
{
    { ImVec2(1, 1), ImVec2(-1, -1), 0, 3 },
    { ImVec2(0, 1), ImVec2(+1, -1), 3, 6 },
    { ImVec2(0, 0), ImVec2(+1, +1), 6, 9 },
    { ImVec2(1, 0), ImVec2(-1, +1), 9, 12 }
};


struct ImGuiResizeBorderDef
{
    ImVec2 InnerDir;
    ImVec2 SegmentN1, SegmentN2;
    float OuterAngle;
};
static const ImGuiResizeBorderDef resize_border_def[4] =
{
    { ImVec2(+1, 0), ImVec2(0, 1), ImVec2(0, 0), 3.14159265358979323846f * 1.00f },
    { ImVec2(-1, 0), ImVec2(1, 0), ImVec2(1, 1), 3.14159265358979323846f * 0.00f },
    { ImVec2(0, +1), ImVec2(0, 0), ImVec2(1, 0), 3.14159265358979323846f * 1.50f },
    { ImVec2(0, -1), ImVec2(1, 1), ImVec2(0, 1), 3.14159265358979323846f * 0.50f }
};

static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
    ImRect rect = window->Rect();
    if (thickness == 0.0f)
        rect.Max -= ImVec2(1, 1);
    if (border_n == ImGuiDir_Left) { return ImRect(rect.Min.x - thickness, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding); }
    if (border_n == ImGuiDir_Right) { return ImRect(rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x + thickness, rect.Max.y - perp_padding); }
    if (border_n == ImGuiDir_Up) { return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness, rect.Max.x - perp_padding, rect.Min.y + thickness); }
    if (border_n == ImGuiDir_Down) { return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y + thickness); }
    
# 5877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   0
# 5877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "0"
# 5877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5877, __extension__ __PRETTY_FUNCTION__))
# 5877 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
    return ImRect();
}


ImGuiID ImGui::GetWindowResizeCornerID(ImGuiWindow* window, int n)
{
    
# 5884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   n >= 0 && n < 4
# 5884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "n >= 0 && n < 4"
# 5884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5884, __extension__ __PRETTY_FUNCTION__))
# 5884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             ;
    ImGuiID id = window->ID;
    id = ImHashStr("#RESIZE", 0, id);
    id = ImHashData(&n, sizeof(int), id);
    return id;
}


ImGuiID ImGui::GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir)
{
    
# 5894 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 5894 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   dir >= 0 && dir < 4
# 5894 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 5894 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "dir >= 0 && dir < 4"
# 5894 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 5894, __extension__ __PRETTY_FUNCTION__))
# 5894 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 ;
    int n = (int)dir + 4;
    ImGuiID id = window->ID;
    id = ImHashStr("#RESIZE", 0, id);
    id = ImHashData(&n, sizeof(int), id);
    return id;
}



static bool ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;

    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return false;
    if (window->WasActive == false)
        return false;

    bool ret_auto_fit = false;
    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
    const float grip_draw_size = ((float)(int)(ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f)));
    const float grip_hover_inner_size = ((float)(int)(grip_draw_size * 0.75f));
    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0f;

    ImVec2 pos_target(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F);
    ImVec2 size_target(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F);


    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;


    PushID("#RESIZE");
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const ImGuiResizeGripDef& def = resize_grip_def[resize_grip_n];
        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, def.CornerPosN);


        bool hovered, held;
        ImRect resize_rect(corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        ImGuiID resize_grip_id = window->GetID(resize_grip_n);
        ItemAdd(resize_rect, resize_grip_id, 
# 5939 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                            __null
# 5939 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                , ImGuiItemFlags_NoNav);
        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);

        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseClickedCount[0] == 2 && resize_grip_n == 0)
        {

            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
            ret_auto_fit = true;
            ClearActiveID();
        }
        else if (held)
        {


            ImVec2 clamp_min = ImVec2(def.CornerPosN.x == 1.0f ? visibility_rect.Min.x : -3.40282346638528859811704183484516925e+38F, def.CornerPosN.y == 1.0f ? visibility_rect.Min.y : -3.40282346638528859811704183484516925e+38F);
            ImVec2 clamp_max = ImVec2(def.CornerPosN.x == 0.0f ? visibility_rect.Max.x : +3.40282346638528859811704183484516925e+38F, def.CornerPosN.y == 0.0f ? visibility_rect.Max.y : +3.40282346638528859811704183484516925e+38F);
            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN);
            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
        }


        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        const ImGuiResizeBorderDef& def = resize_border_def[border_n];
        const ImGuiAxis axis = (border_n == ImGuiDir_Left || border_n == ImGuiDir_Right) ? ImGuiAxis_X : ImGuiAxis_Y;

        bool hovered, held;
        ImRect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
        ImGuiID border_id = window->GetID(border_n + 4);
        ItemAdd(border_rect, border_id, 
# 5975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                       __null
# 5975 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           , ImGuiItemFlags_NoNav);
        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);

        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
        {
            g.MouseCursor = (axis == ImGuiAxis_X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
            if (held)
                *border_held = border_n;
        }
        if (held)
        {
            ImVec2 clamp_min(border_n == ImGuiDir_Right ? visibility_rect.Min.x : -3.40282346638528859811704183484516925e+38F, border_n == ImGuiDir_Down ? visibility_rect.Min.y : -3.40282346638528859811704183484516925e+38F);
            ImVec2 clamp_max(border_n == ImGuiDir_Left ? visibility_rect.Max.x : +3.40282346638528859811704183484516925e+38F, border_n == ImGuiDir_Up ? visibility_rect.Max.y : +3.40282346638528859811704183484516925e+38F);
            ImVec2 border_target = window->Pos;
            border_target[axis] = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING;
            border_target = ImClamp(border_target, clamp_min, clamp_max);
            CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
        }
    }
    PopID();


    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;




    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)
    {
        ImVec2 nav_resize_dir;
        if (g.NavInputSource == ImGuiInputSource_Keyboard && g.IO.KeyShift)
            nav_resize_dir = GetKeyVector2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
        if (g.NavInputSource == ImGuiInputSource_Gamepad)
            nav_resize_dir = GetKeyVector2d(ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown);
        if (nav_resize_dir.x != 0.0f || nav_resize_dir.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            const float resize_step = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, visibility_rect.Min - window->Pos - window->Size);
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
            ImVec2 accum_floored = ImFloor(g.NavWindowingAccumDeltaSize);
            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
            {

                size_target = CalcWindowSizeAfterConstraint(window, window->SizeFull + accum_floored);
                g.NavWindowingAccumDeltaSize -= accum_floored;
            }
        }
    }


    if (size_target.x != 3.40282346638528859811704183484516925e+38F)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != 3.40282346638528859811704183484516925e+38F)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    window->Size = window->SizeFull;
    return ret_auto_fit;
}

static inline void ClampWindowPos(ImGuiWindow* window, const ImRect& visibility_rect)
{
    ImGuiContext& g = *GImGui;
    ImVec2 size_for_clamping = window->Size;
    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
        size_for_clamping.y = window->TitleBarHeight();
    window->Pos = ImClamp(window->Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
}

static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    float rounding = window->WindowRounding;
    float border_size = window->WindowBorderSize;
    if (border_size > 0.0f && !(window->Flags & ImGuiWindowFlags_NoBackground))
        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), rounding, 0, border_size);

    int border_held = window->ResizeBorderHeld;
    if (border_held != -1)
    {
        const ImGuiResizeBorderDef& def = resize_border_def[border_held];
        ImRect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - 3.14159265358979323846f * 0.25f, def.OuterAngle);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + 3.14159265358979323846f * 0.25f);
        window->DrawList->PathStroke(GetColorU32(ImGuiCol_SeparatorActive), 0, ImMax(2.0f, border_size));
    }
    if (g.Style.FrameBorderSize > 0 && !(window->Flags & ImGuiWindowFlags_NoTitleBar))
    {
        float y = window->Pos.y + window->TitleBarHeight() - 1;
        window->DrawList->AddLine(ImVec2(window->Pos.x + border_size, y), ImVec2(window->Pos.x + window->Size.x - border_size, y), GetColorU32(ImGuiCol_Border), g.Style.FrameBorderSize);
    }
}



void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImGuiWindowFlags flags = window->Flags;


    
# 6086 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 6086 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->BeginCount == 0
# 6086 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 6086 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->BeginCount == 0"
# 6086 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6086, __extension__ __PRETTY_FUNCTION__))
# 6086 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                     ;
    window->SkipItems = false;



    const float window_rounding = window->WindowRounding;
    const float window_border_size = window->WindowBorderSize;
    if (window->Collapsed)
    {

        float backup_border_size = style.FrameBorderSize;
        g.Style.FrameBorderSize = window->WindowBorderSize;
        ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
        g.Style.FrameBorderSize = backup_border_size;
    }
    else
    {

        if (!(flags & ImGuiWindowFlags_NoBackground))
        {
            ImU32 bg_col = GetColorU32(GetWindowBgColorIdx(window));
            bool override_alpha = false;
            float alpha = 1.0f;
            if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasBgAlpha)
            {
                alpha = g.NextWindowData.BgAlphaVal;
                override_alpha = true;
            }
            if (override_alpha)
                bg_col = (bg_col & ~0xFF000000) | (((int)(ImSaturate(alpha) * 255.0f + 0.5f)) << 24);
            window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_RoundCornersBottom);
        }


        if (!(flags & ImGuiWindowFlags_NoTitleBar))
        {
            ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
            window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
        }


        if (flags & ImGuiWindowFlags_MenuBar)
        {
            ImRect menu_bar_rect = window->MenuBarRect();
            menu_bar_rect.ClipWith(window->Rect());
            window->DrawList->AddRectFilled(menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawFlags_RoundCornersTop);
            if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
        }


        if (window->ScrollbarX)
            Scrollbar(ImGuiAxis_X);
        if (window->ScrollbarY)
            Scrollbar(ImGuiAxis_Y);


        if (!(flags & ImGuiWindowFlags_NoResize))
        {
            for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
            {
                const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
                const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)));
                window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)));
                window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
            }
        }


        RenderWindowOuterBorders(window);
    }
}


void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImGuiWindowFlags flags = window->Flags;

    const bool has_close_button = (p_open != 
# 6169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                            __null
# 6169 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                );
    const bool has_collapse_button = !(flags & ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir_None);



    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
    window->DC.NavLayerCurrent = ImGuiNavLayer_Menu;



    float pad_l = style.FramePadding.x;
    float pad_r = style.FramePadding.x;
    float button_sz = g.FontSize;
    ImVec2 close_button_pos;
    ImVec2 collapse_button_pos;
    if (has_close_button)
    {
        pad_r += button_sz;
        close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
    }
    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Right)
    {
        pad_r += button_sz;
        collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - style.FramePadding.x, title_bar_rect.Min.y);
    }
    if (has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir_Left)
    {
        collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l - style.FramePadding.x, title_bar_rect.Min.y);
        pad_l += button_sz;
    }


    if (has_collapse_button)
        if (CollapseButton(window->GetID("#COLLAPSE"), collapse_button_pos))
            window->WantCollapseToggle = true;


    if (has_close_button)
        if (CloseButton(window->GetID("#CLOSE"), close_button_pos))
            *p_open = false;

    window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
    g.CurrentItemFlags = item_flags_backup;



    const float marker_size_x = (flags & ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80f : 0.0f;
    const ImVec2 text_size = CalcTextSize(name, 
# 6217 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                               __null
# 6217 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   , true) + ImVec2(marker_size_x, 0.0f);



    if (pad_l > style.FramePadding.x)
        pad_l += g.Style.ItemInnerSpacing.x;
    if (pad_r > style.FramePadding.x)
        pad_r += g.Style.ItemInnerSpacing.x;
    if (style.WindowTitleAlign.x > 0.0f && style.WindowTitleAlign.x < 1.0f)
    {
        float centerness = ImSaturate(1.0f - fabsf(style.WindowTitleAlign.x - 0.5f) * 2.0f);
        float pad_extend = ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
        pad_l = ImMax(pad_l, pad_extend * centerness);
        pad_r = ImMax(pad_r, pad_extend * centerness);
    }

    ImRect layout_r(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y);
    ImRect clip_r(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
    if (flags & ImGuiWindowFlags_UnsavedDocument)
    {
        ImVec2 marker_pos;
        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5f;
        if (marker_pos.x > layout_r.Min.x)
        {
            RenderBullet(window->DrawList, marker_pos, GetColorU32(ImGuiCol_Text));
            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (int)(marker_size_x * 0.5f));
        }
    }


    RenderTextClipped(layout_r.Min, layout_r.Max, name, 
# 6248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                       __null
# 6248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                           , &text_size, style.WindowTitleAlign, &clip_r);
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowPopupTree = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        window->RootWindow = parent_window->RootWindow;
    if (parent_window && (flags & ImGuiWindowFlags_Popup))
        window->RootWindowPopupTree = parent_window->RootWindowPopupTree;
    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
    {
        
# 6263 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 6263 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       window->RootWindowForNav->ParentWindow != 
# 6263 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       __null) ? void (0) : __assert_fail (
# 6263 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "window->RootWindowForNav->ParentWindow != __null"
# 6263 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6263, __extension__ __PRETTY_FUNCTION__))
# 6263 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                ;
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
    }
}
# 6277 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static ImGuiWindow* ImGui::FindBlockingModal(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= 0)
        return 
# 6281 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 6281 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;


    for (int i = g.OpenPopupStack.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* popup_window = g.OpenPopupStack.Data[i].Window;
        if (popup_window == 
# 6287 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                           __null 
# 6287 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                || !(popup_window->Flags & ImGuiWindowFlags_Modal))
            continue;
        if (!popup_window->Active && !popup_window->WasActive)
            continue;
        if (IsWindowWithinBeginStackOf(window, popup_window))
            break;
        for (ImGuiWindow* parent = popup_window->ParentWindowInBeginStack->RootWindow; parent != 
# 6293 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                __null
# 6293 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                    ; parent = parent->ParentWindowInBeginStack->RootWindow)
            if (IsWindowWithinBeginStackOf(window, parent))
                return popup_window;
    }
    return 
# 6297 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 6297 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}
# 6307 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   name != 
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && name[0] != '\0'
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "name != __null && name[0] != '\\0'"
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6311, __extension__ __PRETTY_FUNCTION__))
# 6311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                             ;
    
# 6312 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 6312 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WithinFrameScope
# 6312 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 6312 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WithinFrameScope"
# 6312 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6312, __extension__ __PRETTY_FUNCTION__))
# 6312 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                ;
    
# 6313 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 6313 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.FrameCountEnded != g.FrameCount
# 6313 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 6313 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.FrameCountEnded != g.FrameCount"
# 6313 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6313, __extension__ __PRETTY_FUNCTION__))
# 6313 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;


    ImGuiWindow* window = FindWindowByName(name);
    const bool window_just_created = (window == 
# 6317 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                               __null
# 6317 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   );
    if (window_just_created)
        window = CreateNewWindow(name, flags);


    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs)
        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

    if (flags & ImGuiWindowFlags_NavFlattened)
        
# 6326 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 6326 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       flags & ImGuiWindowFlags_ChildWindow
# 6326 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 6326 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "flags & ImGuiWindowFlags_ChildWindow"
# 6326 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6326, __extension__ __PRETTY_FUNCTION__))
# 6326 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      ;

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
    window->IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow);


    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId);
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = window_just_activated_by_user;
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);


    if (first_begin_of_the_frame)
    {
        UpdateWindowInFocusOrderList(window, window_just_created, flags);
        window->Flags = (ImGuiWindowFlags)flags;
        window->LastFrameActive = current_frame;
        window->LastTimeActive = (float)g.Time;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
    }
    else
    {
        flags = window->Flags;
    }


    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? 
# 6360 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                        __null 
# 6360 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                             : g.CurrentWindowStack.back().Window;
    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : 
# 6361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                                                         __null
# 6361 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                             ) : window->ParentWindow;
    
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   parent_window != 
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   || !(flags & ImGuiWindowFlags_ChildWindow)
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "parent_window != __null || !(flags & ImGuiWindowFlags_ChildWindow)"
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6362, __extension__ __PRETTY_FUNCTION__))
# 6362 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                              ;


    if (window->IDStack.Size == 0)
        window->IDStack.push_back(window->ID);



    g.CurrentWindow = window;
    ImGuiWindowStackData window_stack_data;
    window_stack_data.Window = window;
    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
    window_stack_data.StackSizesOnBegin.SetToCurrentState();
    g.CurrentWindowStack.push_back(window_stack_data);
    if (flags & ImGuiWindowFlags_ChildMenu)
        g.BeginMenuCount++;


    if (first_begin_of_the_frame)
    {
        UpdateWindowParentAndRootLinks(window, flags, parent_window);
        window->ParentWindowInBeginStack = parent_window_in_stack;
    }


    PushFocusScope(window->ID);
    window->NavRootFocusScopeId = g.CurrentFocusScopeId;
    g.CurrentWindow = 
# 6389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                     __null
# 6389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         ;


    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupData& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        popup_ref.Window = window;
        popup_ref.ParentNavLayer = parent_window_in_stack->DC.NavLayerCurrent;
        g.BeginPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }



    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {


            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasScroll)
    {
        if (g.NextWindowData.ScrollVal.x >= 0.0f)
        {
            window->ScrollTarget.x = g.NextWindowData.ScrollVal.x;
            window->ScrollTargetCenterRatio.x = 0.0f;
        }
        if (g.NextWindowData.ScrollVal.y >= 0.0f)
        {
            window->ScrollTarget.y = g.NextWindowData.ScrollVal.y;
            window->ScrollTargetCenterRatio.y = 0.0f;
        }
    }
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasContentSize)
        window->ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
    else if (first_begin_of_the_frame)
        window->ContentSizeExplicit = ImVec2(0.0f, 0.0f);
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasCollapsed)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasFocus)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);


    if (first_begin_of_the_frame)
    {

        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip);
        const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
        window->Active = true;
        window->HasCloseButton = (p_open != 
# 6458 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                           __null
# 6458 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               );
        window->ClipRect = ImVec4(-3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F, +3.40282346638528859811704183484516925e+38F, +3.40282346638528859811704183484516925e+38F);
        window->IDStack.resize(1);
        window->DrawList->_ResetForNewFrame();
        window->DC.CurrentTableIdx = -1;


        if (window->MemoryCompacted)
            GcAwakeTransientWindowBuffers(window);



        bool window_title_visible_elsewhere = false;
        if (g.NavWindowingListWindow != 
# 6471 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                       __null 
# 6471 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            && (window->Flags & ImGuiWindowFlags_NoNavFocus) == 0)
            window_title_visible_elsewhere = true;
        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
        {
            size_t buf_len = (size_t)window->NameBufLen;
            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
            window->NameBufLen = (int)buf_len;
        }




        CalcWindowContentSizes(window, &window->ContentSize, &window->ContentSizeIdeal);
        if (window->HiddenFramesCanSkipItems > 0)
            window->HiddenFramesCanSkipItems--;
        if (window->HiddenFramesCannotSkipItems > 0)
            window->HiddenFramesCannotSkipItems--;
        if (window->HiddenFramesForRenderOnly > 0)
            window->HiddenFramesForRenderOnly--;


        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesCannotSkipItems = 1;



        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesCannotSkipItems = 1;
            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->ContentSize = window->ContentSizeIdeal = ImVec2(0.f, 0.f);
            }
        }




        ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)GetMainViewport();
        SetWindowViewport(window, viewport);
        SetCurrentWindow(window);



        if (flags & ImGuiWindowFlags_ChildWindow)
            window->WindowBorderSize = style.ChildBorderSize;
        else
            window->WindowBorderSize = ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        window->WindowPadding = style.WindowPadding;
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);


        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        bool use_current_size_for_scrollbar_x = window_just_created;
        bool use_current_size_for_scrollbar_y = window_just_created;



        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))
        {

            ImRect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseClickedCount[0] == 2)
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                if (!window->Collapsed)
                    use_current_size_for_scrollbar_y = true;
                MarkIniSettingsDirty(window);
            }
        }
        else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;




        const ImVec2 size_auto_fit = CalcWindowAutoFitSize(window, window->ContentSizeIdeal);
        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {

            if (!window_size_x_set_by_api)
            {
                window->SizeFull.x = size_auto_fit.x;
                use_current_size_for_scrollbar_x = true;
            }
            if (!window_size_y_set_by_api)
            {
                window->SizeFull.y = size_auto_fit.y;
                use_current_size_for_scrollbar_y = true;
            }
        }
        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {


            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
            {
                window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
                use_current_size_for_scrollbar_x = true;
            }
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
            {
                window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
                use_current_size_for_scrollbar_y = true;
            }
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }


        window->SizeFull = CalcWindowSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;


        const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();




        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = ImGuiDir_None;
            if ((flags & ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api)
                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        }


        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            
# 6612 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 6612 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           parent_window && parent_window->Active
# 6612 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 6612 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "parent_window && parent_window->Active"
# 6612 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6612, __extension__ __PRETTY_FUNCTION__))
# 6612 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            ;
            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != 3.40282346638528859811704183484516925e+38F && window->HiddenFramesCannotSkipItems == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, window->SetWindowPosVal - window->Size * window->SetWindowPosPivot, 0);
        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);



        ImRect viewport_rect(viewport->GetMainRect());
        ImRect viewport_work_rect(viewport->GetWorkRect());
        ImVec2 visibility_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
        ImRect visibility_rect(viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding);



        if (!window_pos_set_by_api && !(flags & ImGuiWindowFlags_ChildWindow))
            if (viewport_rect.GetWidth() > 0.0f && viewport_rect.GetHeight() > 0.0f)
                ClampWindowPos(window, visibility_rect);
        window->Pos = ImFloor(window->Pos);



        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;






        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
        {
            if (flags & ImGuiWindowFlags_Popup)
                want_focus = true;
            else if ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) == 0)
                want_focus = true;

            ImGuiWindow* modal = GetTopMostPopupModal();
            if (modal != 
# 6661 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        __null 
# 6661 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             && !IsWindowWithinBeginStackOf(window, modal))
            {




                want_focus = false;
                if (window == window->RootWindow)
                {
                    ImGuiWindow* blocking_modal = FindBlockingModal(window);
                    
# 6671 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   (static_cast <bool> (
# 6671 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   blocking_modal != 
# 6671 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   __null) ? void (0) : __assert_fail (
# 6671 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   "blocking_modal != __null"
# 6671 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6671, __extension__ __PRETTY_FUNCTION__))
# 6671 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                    ;
                    BringWindowToDisplayBehind(window, blocking_modal);
                }
            }
        }
# 6690 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        int border_held = -1;
        ImU32 resize_grip_col[4] = {};
        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1;
        const float resize_grip_draw_size = ((float)(int)(ImMax(g.FontSize * 1.10f, window->WindowRounding + 1.0f + g.FontSize * 0.2f)));
        if (!window->Collapsed)
            if (UpdateWindowManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect))
                use_current_size_for_scrollbar_x = use_current_size_for_scrollbar_y = true;
        window->ResizeBorderHeld = (signed char)border_held;




        if (!window->Collapsed)
        {


            ImVec2 avail_size_from_current_frame = ImVec2(window->SizeFull.x, window->SizeFull.y - decoration_up_height);
            ImVec2 avail_size_from_last_frame = window->InnerRect.GetSize() + window->ScrollbarSizes;
            ImVec2 needed_size_from_last_frame = window_just_created ? ImVec2(0, 0) : window->ContentSize + window->WindowPadding * 2.0f;
            float size_x_for_scrollbars = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
            float size_y_for_scrollbars = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;

            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar);
            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }
# 6728 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        const ImRect host_rect = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window->ClipRect : viewport_rect;
        const ImRect outer_rect = window->Rect();
        const ImRect title_bar_rect = window->TitleBarRect();
        window->OuterRectClipped = outer_rect;
        window->OuterRectClipped.ClipWith(host_rect);







        window->InnerRect.Min.x = window->Pos.x;
        window->InnerRect.Min.y = window->Pos.y + decoration_up_height;
        window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x;
        window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y;
# 6752 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        float top_border_size = (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + top_border_size);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(ImFloor(window->WindowPadding.x * 0.5f), window->WindowBorderSize));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y - window->WindowBorderSize);
        window->InnerClipRect.ClipWithFull(host_rect);


        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = ImFloor(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = ImFloor(g.FontSize * 16.0f);






        window->ScrollMax.x = ImMax(0.0f, window->ContentSize.x + window->WindowPadding.x * 2.0f - window->InnerRect.GetWidth());
        window->ScrollMax.y = ImMax(0.0f, window->ContentSize.y + window->WindowPadding.y * 2.0f - window->InnerRect.GetHeight());


        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
        window->ScrollTarget = ImVec2(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F);




        
# 6780 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 6780 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0
# 6780 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 6780 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "window->DrawList->CmdBuffer.Size == 1 && window->DrawList->CmdBuffer[0].ElemCount == 0"
# 6780 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6780, __extension__ __PRETTY_FUNCTION__))
# 6780 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                        ;
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        PushClipRect(host_rect.Min, host_rect.Max, false);




        {
            bool render_decorations_in_parent = false;
            if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
            {


                ImGuiWindow* previous_child = parent_window->DC.ChildWindows.Size >= 2 ? parent_window->DC.ChildWindows[parent_window->DC.ChildWindows.Size - 2] : 
# 6793 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                                                                  __null
# 6793 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                      ;
                bool previous_child_overlapping = previous_child ? previous_child->Rect().Overlaps(window->Rect()) : false;
                bool parent_is_empty = parent_window->DrawList->VtxBuffer.Size > 0;
                if (window->DrawList->CmdBuffer.back().ElemCount == 0 && parent_is_empty && !previous_child_overlapping)
                    render_decorations_in_parent = true;
            }
            if (render_decorations_in_parent)
                window->DrawList = parent_window->DrawList;


            const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
            const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, resize_grip_count, resize_grip_col, resize_grip_draw_size);

            if (render_decorations_in_parent)
                window->DrawList = &window->DrawListInst;
        }
# 6818 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        const bool allow_scrollbar_x = !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar);
        const bool allow_scrollbar_y = !(flags & ImGuiWindowFlags_NoScrollbar);
        const float work_rect_size_x = (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window->ContentSize.x : 0.0f, window->Size.x - window->WindowPadding.x * 2.0f - window->ScrollbarSizes.x));
        const float work_rect_size_y = (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window->ContentSize.y : 0.0f, window->Size.y - window->WindowPadding.y * 2.0f - decoration_up_height - window->ScrollbarSizes.y));
        window->WorkRect.Min.x = ImFloor(window->InnerRect.Min.x - window->Scroll.x + ImMax(window->WindowPadding.x, window->WindowBorderSize));
        window->WorkRect.Min.y = ImFloor(window->InnerRect.Min.y - window->Scroll.y + ImMax(window->WindowPadding.y, window->WindowBorderSize));
        window->WorkRect.Max.x = window->WorkRect.Min.x + work_rect_size_x;
        window->WorkRect.Max.y = window->WorkRect.Min.y + work_rect_size_y;
        window->ParentWorkRect = window->WorkRect;





        window->ContentRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + decoration_up_height;
        window->ContentRegionRect.Max.x = window->ContentRegionRect.Min.x + (window->ContentSizeExplicit.x != 0.0f ? window->ContentSizeExplicit.x : (window->Size.x - window->WindowPadding.x * 2.0f - window->ScrollbarSizes.x));
        window->ContentRegionRect.Max.y = window->ContentRegionRect.Min.y + (window->ContentSizeExplicit.y != 0.0f ? window->ContentSizeExplicit.y : (window->Size.y - window->WindowPadding.y * 2.0f - decoration_up_height - window->ScrollbarSizes.y));



        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;



        double start_pos_highp_x = (double)window->Pos.x + window->WindowPadding.x - (double)window->Scroll.x + window->DC.ColumnsOffset.x;
        double start_pos_highp_y = (double)window->Pos.y + window->WindowPadding.y - (double)window->Scroll.y + decoration_up_height;
        window->DC.CursorStartPos = ImVec2((float)start_pos_highp_x, (float)start_pos_highp_y);
        window->DC.CursorStartPosLossyness = ImVec2((float)(start_pos_highp_x - window->DC.CursorStartPos.x), (float)(start_pos_highp_y - window->DC.CursorStartPos.y));
        window->DC.CursorPos = window->DC.CursorStartPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorStartPos;
        window->DC.IdealMaxPos = window->DC.CursorStartPos;
        window->DC.CurrLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
        window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
        window->DC.IsSameLine = window->DC.IsSetPos = false;

        window->DC.NavLayerCurrent = ImGuiNavLayer_Main;
        window->DC.NavLayersActiveMask = window->DC.NavLayersActiveMaskNext;
        window->DC.NavLayersActiveMaskNext = 0x00;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (window->ScrollMax.y > 0.0f);

        window->DC.MenuBarAppending = false;
        window->DC.MenuColumns.Update(style.ItemSpacing.x, window_just_activated_by_user);
        window->DC.TreeDepth = 0;
        window->DC.TreeJumpToParentOnPopMask = 0x00;
        window->DC.ChildWindows.resize(0);
        window->DC.StateStorage = &window->StateStorage;
        window->DC.CurrentColumns = 
# 6869 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                   __null
# 6869 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       ;
        window->DC.LayoutType = ImGuiLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;

        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f;
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;


        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false);
        }


        if (!(flags & ImGuiWindowFlags_NoTitleBar))
            RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window->WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window->WindowBorderSize, title_bar_rect.Max.y), name, p_open);


        window->HitTestHoleSize.x = window->HitTestHoleSize.y = 0;
# 6909 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        SetLastItemData(window->MoveId, g.CurrentItemFlags, IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0, title_bar_rect);



        if (g.DebugLocateId != 0 && (window->ID == g.DebugLocateId || window->MoveId == g.DebugLocateId))
            DebugLocateItemResolveWithLastItem();







    }
    else
    {

        SetCurrentWindow(window);
    }

    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);


    window->WriteAccessed = false;
    window->BeginCount++;
    g.NextWindowData.ClearFlags();


    if (first_begin_of_the_frame)
    {
        if (flags & ImGuiWindowFlags_ChildWindow)
        {


            
# 6943 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 6943 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           (flags & ImGuiWindowFlags_NoTitleBar) != 0
# 6943 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 6943 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "(flags & ImGuiWindowFlags_NoTitleBar) != 0"
# 6943 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6943, __extension__ __PRETTY_FUNCTION__))
# 6943 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                ;
            if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            {
                const bool nav_request = (flags & ImGuiWindowFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow->RootWindowForNav == window->RootWindowForNav);
                if (!g.LogEnabled && !nav_request)
                    if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                        window->HiddenFramesCanSkipItems = 1;
            }


            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCanSkipItems > 0))
                window->HiddenFramesCanSkipItems = 1;
            if (parent_window && (parent_window->Collapsed || parent_window->HiddenFramesCannotSkipItems > 0))
                window->HiddenFramesCannotSkipItems = 1;
        }


        if (style.Alpha <= 0.0f)
            window->HiddenFramesCanSkipItems = 1;


        bool hidden_regular = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);
        window->Hidden = hidden_regular || (window->HiddenFramesForRenderOnly > 0);


        if (window->DisableInputsFrames > 0)
        {
            window->DisableInputsFrames--;
            window->Flags |= ImGuiWindowFlags_NoInputs;
        }


        bool skip_items = false;
        if (window->Collapsed || !window->Active || hidden_regular)
            if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
                skip_items = true;
        window->SkipItems = skip_items;
    }

    return !window->SkipItems;
}

void ImGui::End()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;


    if (g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow)
    {
        
# 6993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 6993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (g.CurrentWindowStack.Size > 1) && "Calling End() too many times!"
# 6993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 6993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(g.CurrentWindowStack.Size > 1) && \"Calling End() too many times!\""
# 6993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6993, __extension__ __PRETTY_FUNCTION__))
# 6993 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                           ;
        return;
    }
    
# 6996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 6996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.CurrentWindowStack.Size > 0
# 6996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 6996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.CurrentWindowStack.Size > 0"
# 6996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 6996, __extension__ __PRETTY_FUNCTION__))
# 6996 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;


    if (window->Flags & ImGuiWindowFlags_ChildWindow)
        
# 7000 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 7000 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (g.WithinEndChild) && "Must call EndChild() and not End()!"
# 7000 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 7000 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(g.WithinEndChild) && \"Must call EndChild() and not End()!\""
# 7000 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7000, __extension__ __PRETTY_FUNCTION__))
# 7000 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                    ;


    if (window->DC.CurrentColumns)
        EndColumns();
    PopClipRect();
    PopFocusScope();


    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))
        LogFinish();

    if (window->DC.IsSetPos)
        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();


    g.LastItemData = g.CurrentWindowStack.back().ParentLastItemDataBackup;
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
        g.BeginMenuCount--;
    if (window->Flags & ImGuiWindowFlags_Popup)
        g.BeginPopupStack.pop_back();
    g.CurrentWindowStack.back().StackSizesOnBegin.CompareWithCurrentState();
    g.CurrentWindowStack.pop_back();
    SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? 
# 7023 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                     __null 
# 7023 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                          : g.CurrentWindowStack.back().Window);
}

void ImGui::BringWindowToFocusFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    
# 7029 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7029 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window == window->RootWindow
# 7029 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7029 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window == window->RootWindow"
# 7029 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7029, __extension__ __PRETTY_FUNCTION__))
# 7029 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          ;

    const int cur_order = window->FocusOrder;
    
# 7032 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7032 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WindowsFocusOrder[cur_order] == window
# 7032 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7032 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WindowsFocusOrder[cur_order] == window"
# 7032 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7032, __extension__ __PRETTY_FUNCTION__))
# 7032 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      ;
    if (g.WindowsFocusOrder.back() == window)
        return;

    const int new_order = g.WindowsFocusOrder.Size - 1;
    for (int n = cur_order; n < new_order; n++)
    {
        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
        g.WindowsFocusOrder[n]->FocusOrder--;
        
# 7041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 7041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.WindowsFocusOrder[n]->FocusOrder == n
# 7041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 7041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.WindowsFocusOrder[n]->FocusOrder == n"
# 7041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7041, __extension__ __PRETTY_FUNCTION__))
# 7041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                         ;
    }
    g.WindowsFocusOrder[new_order] = window;
    window->FocusOrder = (short)new_order;
}

void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindow == window)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(ImGuiWindow*));
            g.Windows[g.Windows.Size - 1] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
            g.Windows[0] = window;
            break;
        }
}

void ImGui::BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* behind_window)
{
    
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window != 
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && behind_window != 
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window != __null && behind_window != __null"
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7078, __extension__ __PRETTY_FUNCTION__))
# 7078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                     ;
    ImGuiContext& g = *GImGui;
    window = window->RootWindow;
    behind_window = behind_window->RootWindow;
    int pos_wnd = FindWindowDisplayIndex(window);
    int pos_beh = FindWindowDisplayIndex(behind_window);
    if (pos_wnd < pos_beh)
    {
        size_t copy_bytes = (pos_beh - pos_wnd - 1) * sizeof(ImGuiWindow*);
        memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes);
        g.Windows[pos_beh - 1] = window;
    }
    else
    {
        size_t copy_bytes = (pos_wnd - pos_beh) * sizeof(ImGuiWindow*);
        memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes);
        g.Windows[pos_beh] = window;
    }
}

int ImGui::FindWindowDisplayIndex(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    return g.Windows.index_from_ptr(g.Windows.find(window));
}


void ImGui::FocusWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    if (g.NavWindow != window)
    {
        SetNavWindow(window);
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavId = window ? window->NavLastIds[0] : 0;
        g.NavLayer = ImGuiNavLayer_Main;
        g.NavFocusScopeId = window ? window->NavRootFocusScopeId : 0;
        g.NavIdIsAlive = false;


        ClosePopupsOverWindow(window, false);
    }


    
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window == 
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   || window->RootWindow != 
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window == __null || window->RootWindow != __null"
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7124, __extension__ __PRETTY_FUNCTION__))
# 7124 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                          ;
    ImGuiWindow* focus_front_window = window ? window->RootWindow : 
# 7125 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                   __null
# 7125 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                       ;
    ImGuiWindow* display_front_window = window ? window->RootWindow : 
# 7126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                     __null
# 7126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         ;




    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != focus_front_window)
        if (!g.ActiveIdNoClearOnFocusLoss)
            ClearActiveID();


    if (!window)
        return;


    BringWindowToFocusFront(focus_front_window);
    if (((window->Flags | display_front_window->Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0)
        BringWindowToDisplayFront(display_front_window);
}

void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window)
{
    ImGuiContext& g = *GImGui;
    int start_idx = g.WindowsFocusOrder.Size - 1;
    if (under_this_window != 
# 7149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                            __null
# 7149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                )
    {

        int offset = -1;
        while (under_this_window->Flags & ImGuiWindowFlags_ChildWindow)
        {
            under_this_window = under_this_window->ParentWindow;
            offset = 0;
        }
        start_idx = FindWindowFocusIndex(under_this_window) + offset;
    }
    for (int i = start_idx; i >= 0; i--)
    {

        ImGuiWindow* window = g.WindowsFocusOrder[i];
        
# 7164 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 7164 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       window == window->RootWindow
# 7164 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 7164 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "window == window->RootWindow"
# 7164 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7164, __extension__ __PRETTY_FUNCTION__))
# 7164 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                              ;
        if (window != ignore_window && window->WasActive)
            if ((window->Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
            {
                ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(window);
                FocusWindow(focus_window);
                return;
            }
    }
    FocusWindow(
# 7173 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               __null
# 7173 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   );
}


void ImGui::SetCurrentFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    
# 7180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   font && font->IsLoaded()
# 7180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "font && font->IsLoaded()"
# 7180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7180, __extension__ __PRETTY_FUNCTION__))
# 7180 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                      ;
    
# 7181 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7181 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   font->Scale > 0.0f
# 7181 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7181 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "font->Scale > 0.0f"
# 7181 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7181, __extension__ __PRETTY_FUNCTION__))
# 7181 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                ;
    g.Font = font;
    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.TexUvLines = atlas->TexUvLines;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void ImGui::PopFont()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
    ImGuiContext& g = *GImGui;
    ImGuiItemFlags item_flags = g.CurrentItemFlags;
    
# 7215 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7215 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   item_flags == g.ItemFlagsStack.back()
# 7215 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7215 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "item_flags == g.ItemFlagsStack.back()"
# 7215 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7215, __extension__ __PRETTY_FUNCTION__))
# 7215 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   ;
    if (enabled)
        item_flags |= option;
    else
        item_flags &= ~option;
    g.CurrentItemFlags = item_flags;
    g.ItemFlagsStack.push_back(item_flags);
}

void ImGui::PopItemFlag()
{
    ImGuiContext& g = *GImGui;
    
# 7227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.ItemFlagsStack.Size > 1
# 7227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.ItemFlagsStack.Size > 1"
# 7227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7227, __extension__ __PRETTY_FUNCTION__))
# 7227 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       ;
    g.ItemFlagsStack.pop_back();
    g.CurrentItemFlags = g.ItemFlagsStack.back();
}







void ImGui::BeginDisabled(bool disabled)
{
    ImGuiContext& g = *GImGui;
    bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;
    if (!was_disabled && disabled)
    {
        g.DisabledAlphaBackup = g.Style.Alpha;
        g.Style.Alpha *= g.Style.DisabledAlpha;
    }
    if (was_disabled || disabled)
        g.CurrentItemFlags |= ImGuiItemFlags_Disabled;
    g.ItemFlagsStack.push_back(g.CurrentItemFlags);
    g.DisabledStackSize++;
}

void ImGui::EndDisabled()
{
    ImGuiContext& g = *GImGui;
    
# 7256 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7256 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DisabledStackSize > 0
# 7256 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7256 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DisabledStackSize > 0"
# 7256 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7256, __extension__ __PRETTY_FUNCTION__))
# 7256 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                     ;
    g.DisabledStackSize--;
    bool was_disabled = (g.CurrentItemFlags & ImGuiItemFlags_Disabled) != 0;

    g.ItemFlagsStack.pop_back();
    g.CurrentItemFlags = g.ItemFlagsStack.back();
    if (was_disabled && (g.CurrentItemFlags & ImGuiItemFlags_Disabled) == 0)
        g.Style.Alpha = g.DisabledAlphaBackup;
}


void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(ImGuiItemFlags_NoTabStop, !allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
    PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.push_back(window->DC.TextWrapPos);
    window->DC.TextWrapPos = wrap_pos_x;
}

void ImGui::PopTextWrapPos()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.back();
    window->DC.TextWrapPosStack.pop_back();
}

static ImGuiWindow* GetCombinedRootWindow(ImGuiWindow* window, bool popup_hierarchy)
{
    ImGuiWindow* last_window = 
# 7303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                              __null
# 7303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  ;
    while (last_window != window)
    {
        last_window = window;
        window = window->RootWindow;
        if (popup_hierarchy)
            window = window->RootWindowPopupTree;
    }
    return window;
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy)
{
    ImGuiWindow* window_root = GetCombinedRootWindow(window, popup_hierarchy);
    if (window_root == potential_parent)
        return true;
    while (window != 
# 7319 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                    __null
# 7319 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        )
    {
        if (window == potential_parent)
            return true;
        if (window == window_root)
            return false;
        window = window->ParentWindow;
    }
    return false;
}

bool ImGui::IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
    if (window->RootWindow == potential_parent)
        return true;
    while (window != 
# 7334 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                    __null
# 7334 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        )
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindowInBeginStack;
    }
    return false;
}

bool ImGui::IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below)
{
    ImGuiContext& g = *GImGui;


    const int display_layer_delta = GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below);
    if (display_layer_delta != 0)
        return display_layer_delta > 0;

    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        ImGuiWindow* candidate_window = g.Windows[i];
        if (candidate_window == potential_above)
            return true;
        if (candidate_window == potential_below)
            return false;
    }
    return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
    
# 7365 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7365 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & (ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_AllowWhenDisabled)) == 0
# 7365 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7365 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & (ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_AllowWhenDisabled)) == 0"
# 7365 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7365, __extension__ __PRETTY_FUNCTION__))
# 7365 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                          ;
    ImGuiContext& g = *GImGui;
    ImGuiWindow* ref_window = g.HoveredWindow;
    ImGuiWindow* cur_window = g.CurrentWindow;
    if (ref_window == 
# 7369 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                     __null
# 7369 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         )
        return false;

    if ((flags & ImGuiHoveredFlags_AnyWindow) == 0)
    {
        
# 7374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 7374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       cur_window
# 7374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 7374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "cur_window"
# 7374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7374, __extension__ __PRETTY_FUNCTION__))
# 7374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            ;
        const bool popup_hierarchy = (flags & ImGuiHoveredFlags_NoPopupHierarchy) == 0;
        if (flags & ImGuiHoveredFlags_RootWindow)
            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);

        bool result;
        if (flags & ImGuiHoveredFlags_ChildWindows)
            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy);
        else
            result = (ref_window == cur_window);
        if (!result)
            return false;
    }

    if (!IsWindowContentHoverable(ref_window, flags))
        return false;
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window->MoveId)
            return false;
    return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* ref_window = g.NavWindow;
    ImGuiWindow* cur_window = g.CurrentWindow;

    if (ref_window == 
# 7402 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                     __null
# 7402 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         )
        return false;
    if (flags & ImGuiFocusedFlags_AnyWindow)
        return true;

    
# 7407 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7407 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cur_window
# 7407 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7407 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cur_window"
# 7407 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7407, __extension__ __PRETTY_FUNCTION__))
# 7407 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        ;
    const bool popup_hierarchy = (flags & ImGuiFocusedFlags_NoPopupHierarchy) == 0;
    if (flags & ImGuiHoveredFlags_RootWindow)
        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy);

    if (flags & ImGuiHoveredFlags_ChildWindows)
        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy);
    else
        return (ref_window == cur_window);
}




bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
    return window->WasActive && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.x;
}

float ImGui::GetWindowHeight()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return window->Pos;
}

void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{

    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    
# 7451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cond == 0 || ImIsPowerOfTwo(cond)
# 7451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cond == 0 || ImIsPowerOfTwo(cond)"
# 7451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7451, __extension__ __PRETTY_FUNCTION__))
# 7451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;
    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window->SetWindowPosVal = ImVec2(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F);


    const ImVec2 old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    ImVec2 offset = window->Pos - old_pos;
    if (offset.x == 0.0f && offset.y == 0.0f)
        return;
    MarkIniSettingsDirty(window);
    window->DC.CursorPos += offset;
    window->DC.CursorMaxPos += offset;
    window->DC.IdealMaxPos += offset;
    window->DC.CursorStartPos += offset;
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Size;
}

void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{

    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    
# 7492 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7492 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cond == 0 || ImIsPowerOfTwo(cond)
# 7492 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7492 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cond == 0 || ImIsPowerOfTwo(cond)"
# 7492 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7492, __extension__ __PRETTY_FUNCTION__))
# 7492 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;
    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);


    ImVec2 old_size = window->SizeFull;
    window->AutoFitFramesX = (size.x <= 0.0f) ? 2 : 0;
    window->AutoFitFramesY = (size.y <= 0.0f) ? 2 : 0;
    if (size.x <= 0.0f)
        window->AutoFitOnlyGrows = false;
    else
        window->SizeFull.x = ((float)(int)(size.x));
    if (size.y <= 0.0f)
        window->AutoFitOnlyGrows = false;
    else
        window->SizeFull.y = ((float)(int)(size.y));
    if (old_size.x != window->SizeFull.x || old_size.y != window->SizeFull.y)
        MarkIniSettingsDirty(window);
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
    SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{

    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);


    window->Collapsed = collapsed;
}

void ImGui::SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size)
{
    
# 7535 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7535 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->HitTestHoleSize.x == 0
# 7535 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7535 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->HitTestHoleSize.x == 0"
# 7535 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7535, __extension__ __PRETTY_FUNCTION__))
# 7535 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            ;
    window->HitTestHoleSize = ImVec2ih(size);
    window->HitTestHoleOffset = ImVec2ih(pos - window->Pos);
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
    FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (ImGuiWindow* window = FindWindowByName(name))
            FocusWindow(window);
    }
    else
    {
        FocusWindow(
# 7577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   __null
# 7577 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                       );
    }
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
    ImGuiContext& g = *GImGui;
    
# 7584 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7584 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cond == 0 || ImIsPowerOfTwo(cond)
# 7584 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7584 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cond == 0 || ImIsPowerOfTwo(cond)"
# 7584 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7584, __extension__ __PRETTY_FUNCTION__))
# 7584 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    
# 7594 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7594 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cond == 0 || ImIsPowerOfTwo(cond)
# 7594 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7594 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cond == 0 || ImIsPowerOfTwo(cond)"
# 7594 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7594, __extension__ __PRETTY_FUNCTION__))
# 7594 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}



void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;
    g.NextWindowData.ContentSizeVal = ImFloor(size);
}

void ImGui::SetNextWindowScroll(const ImVec2& scroll)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;
    g.NextWindowData.ScrollVal = scroll;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    
# 7628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cond == 0 || ImIsPowerOfTwo(cond)
# 7628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cond == 0 || ImIsPowerOfTwo(cond)"
# 7628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7628, __extension__ __PRETTY_FUNCTION__))
# 7628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasFocus;
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
    g.NextWindowData.BgAlphaVal = alpha;
}

ImDrawList* ImGui::GetWindowDrawList()
{
    ImGuiWindow* window = GetCurrentWindow();
    return window->DrawList;
}

ImFont* ImGui::GetFont()
{
    return GImGui->Font;
}

float ImGui::GetFontSize()
{
    return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
    return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
    
# 7670 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7670 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   scale > 0.0f
# 7670 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7670 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "scale > 0.0f"
# 7670 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7670, __extension__ __PRETTY_FUNCTION__))
# 7670 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          ;
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::ActivateItem(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NavNextActivateId = id;
    g.NavNextActivateFlags = ImGuiActivateFlags_None;
}

void ImGui::PushFocusScope(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.FocusScopeStack.push_back(id);
    g.CurrentFocusScopeId = id;
}

void ImGui::PopFocusScope()
{
    ImGuiContext& g = *GImGui;
    
# 7694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.FocusScopeStack.Size > 0
# 7694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.FocusScopeStack.Size > 0"
# 7694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7694, __extension__ __PRETTY_FUNCTION__))
# 7694 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                        ;
    g.FocusScopeStack.pop_back();
    g.CurrentFocusScopeId = g.FocusScopeStack.Size ? g.FocusScopeStack.back() : 0;
}


void ImGui::SetKeyboardFocusHere(int offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    
# 7704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   offset >= -1
# 7704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "offset >= -1"
# 7704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7704, __extension__ __PRETTY_FUNCTION__))
# 7704 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          ;
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) ImGui::DebugLog("SetKeyboardFocusHere(%d) in window \"%s\"\n", offset, window->Name); } while (0);





    if (g.DragDropActive || g.MovingWindow != 
# 7711 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                             __null
# 7711 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                 )
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) ImGui::DebugLog("SetKeyboardFocusHere() ignored while DragDropActive!\n"); } while (0);
        return;
    }

    SetNavWindow(window);

    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    NavMoveRequestSubmit(ImGuiDir_None, offset < 0 ? ImGuiDir_Up : ImGuiDir_Down, ImGuiNavMoveFlags_Tabbing | ImGuiNavMoveFlags_FocusApi, scroll_flags);
    if (offset == -1)
    {
        NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
    }
    else
    {
        g.NavTabbingDir = 1;
        g.NavTabbingCounter = offset + 1;
    }
}

void ImGui::SetItemDefaultFocus()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow != window->RootWindowForNav || (!g.NavInitRequest && g.NavInitResultId == 0) || g.NavLayer != window->DC.NavLayerCurrent)
        return;

    g.NavInitRequest = false;
    g.NavInitResultId = g.LastItemData.ID;
    g.NavInitResultRectRel = WindowRectAbsToRel(window, g.LastItemData.Rect);
    NavUpdateAnyRequestFlag();


    if (!IsItemVisible())
        ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_None);
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->DC.StateStorage;
}

void ImGui::PushID(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetID(str_id);
    window->IDStack.push_back(id);
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetID(str_id_begin, str_id_end);
    window->IDStack.push_back(id);
}

void ImGui::PushID(const void* ptr_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetID(ptr_id);
    window->IDStack.push_back(id);
}

void ImGui::PushID(int int_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiID id = window->GetID(int_id);
    window->IDStack.push_back(id);
}


void ImGui::PushOverrideID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.DebugHookIdInfo == id)
        DebugHookIdInfo(id, ImGuiDataType_ID, 
# 7801 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                             __null
# 7801 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                 , 
# 7801 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                   __null
# 7801 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                       );
    window->IDStack.push_back(id);
}




ImGuiID ImGui::GetIDWithSeed(const char* str, const char* str_end, ImGuiID seed)
{
    ImGuiID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    ImGuiContext& g = *GImGui;
    if (g.DebugHookIdInfo == id)
        DebugHookIdInfo(id, ImGuiDataType_String, str, str_end);
    return id;
}

void ImGui::PopID()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    
# 7820 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7820 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->IDStack.Size > 1
# 7820 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7820 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->IDStack.Size > 1"
# 7820 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7820, __extension__ __PRETTY_FUNCTION__))
# 7820 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                      ;
    window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->GetID(ptr_id);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}
# 7862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
    ImGuiContext& g = *GImGui;


    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);


    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    if (!rect_for_touch.Contains(g.IO.MousePos))
        return false;
    return true;
}

ImGuiKeyData* ImGui::GetKeyData(ImGuiKey key)
{
    ImGuiContext& g = *GImGui;


    if (key & ImGuiMod_Mask_)
        key = ConvertSingleModFlagToKey(key);

    int index;

    
# 7888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   key >= 0 && key < ImGuiKey_NamedKey_END
# 7888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "key >= 0 && key < ImGuiKey_NamedKey_END"
# 7888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7888, __extension__ __PRETTY_FUNCTION__))
# 7888 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                  ;
    if (IsLegacyKey(key))
        index = (g.IO.KeyMap[key] != -1) ? g.IO.KeyMap[key] : key;
    else
        index = key;




    return &g.IO.KeysData[index];
}


ImGuiKey ImGui::GetKeyIndex(ImGuiKey key)
{
    ImGuiContext& g = *GImGui;
    
# 7904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 7904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   IsNamedKey(key)
# 7904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 7904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "IsNamedKey(key)"
# 7904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7904, __extension__ __PRETTY_FUNCTION__))
# 7904 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             ;
    const ImGuiKeyData* key_data = GetKeyData(key);
    return (ImGuiKey)(key_data - g.IO.KeysData);
}



static const char* const GKeyNames[] =
{
    "Tab", "LeftArrow", "RightArrow", "UpArrow", "DownArrow", "PageUp", "PageDown",
    "Home", "End", "Insert", "Delete", "Backspace", "Space", "Enter", "Escape",
    "LeftCtrl", "LeftShift", "LeftAlt", "LeftSuper", "RightCtrl", "RightShift", "RightAlt", "RightSuper", "Menu",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H",
    "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
    "Apostrophe", "Comma", "Minus", "Period", "Slash", "Semicolon", "Equal", "LeftBracket",
    "Backslash", "RightBracket", "GraveAccent", "CapsLock", "ScrollLock", "NumLock", "PrintScreen",
    "Pause", "Keypad0", "Keypad1", "Keypad2", "Keypad3", "Keypad4", "Keypad5", "Keypad6",
    "Keypad7", "Keypad8", "Keypad9", "KeypadDecimal", "KeypadDivide", "KeypadMultiply",
    "KeypadSubtract", "KeypadAdd", "KeypadEnter", "KeypadEqual",
    "GamepadStart", "GamepadBack",
    "GamepadFaceLeft", "GamepadFaceRight", "GamepadFaceUp", "GamepadFaceDown",
    "GamepadDpadLeft", "GamepadDpadRight", "GamepadDpadUp", "GamepadDpadDown",
    "GamepadL1", "GamepadR1", "GamepadL2", "GamepadR2", "GamepadL3", "GamepadR3",
    "GamepadLStickLeft", "GamepadLStickRight", "GamepadLStickUp", "GamepadLStickDown",
    "GamepadRStickLeft", "GamepadRStickRight", "GamepadRStickUp", "GamepadRStickDown",
    "MouseLeft", "MouseRight", "MouseMiddle", "MouseX1", "MouseX2", "MouseWheelX", "MouseWheelY",
    "ModCtrl", "ModShift", "ModAlt", "ModSuper",
};
static_assert(ImGuiKey_NamedKey_COUNT == ((int)(sizeof(GKeyNames) / sizeof(*(GKeyNames)))), "");

const char* ImGui::GetKeyName(ImGuiKey key)
{



    if (IsLegacyKey(key))
    {
        ImGuiIO& io = GetIO();
        if (io.KeyMap[key] == -1)
            return "N/A";
        
# 7945 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 7945 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       IsNamedKey((ImGuiKey)io.KeyMap[key])
# 7945 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 7945 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "IsNamedKey((ImGuiKey)io.KeyMap[key])"
# 7945 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 7945, __extension__ __PRETTY_FUNCTION__))
# 7945 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      ;
        key = (ImGuiKey)io.KeyMap[key];
    }

    if (key == ImGuiKey_None)
        return "None";
    if (key & ImGuiMod_Mask_)
        key = ConvertSingleModFlagToKey(key);
    if (!IsNamedKey(key))
        return "Unknown";

    return GKeyNames[key - ImGuiKey_NamedKey_BEGIN];
}

void ImGui::GetKeyChordName(ImGuiKeyChord key_chord, char* out_buf, int out_buf_size)
{
    ImGuiContext& g = *GImGui;
    ImFormatString(out_buf, (size_t)out_buf_size, "%s%s%s%s%s",
        (key_chord & ImGuiMod_Ctrl) ? "Ctrl+" : "",
        (key_chord & ImGuiMod_Shift) ? "Shift+" : "",
        (key_chord & ImGuiMod_Alt) ? "Alt+" : "",
        (key_chord & ImGuiMod_Super) ? (g.IO.ConfigMacOSXBehaviors ? "Cmd+" : "Super+") : "",
        GetKeyName((ImGuiKey)(key_chord & ~ImGuiMod_Mask_)));
}





int ImGui::CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)
{
    if (t1 == 0.0f)
        return 1;
    if (t0 >= t1)
        return 0;
    if (repeat_rate <= 0.0f)
        return (t0 < repeat_delay) && (t1 >= repeat_delay);
    const int count_t0 = (t0 < repeat_delay) ? -1 : (int)((t0 - repeat_delay) / repeat_rate);
    const int count_t1 = (t1 < repeat_delay) ? -1 : (int)((t1 - repeat_delay) / repeat_rate);
    const int count = count_t1 - count_t0;
    return count;
}

void ImGui::GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeat_delay, float* repeat_rate)
{
    ImGuiContext& g = *GImGui;
    switch (flags & ImGuiInputFlags_RepeatRateMask_)
    {
    case ImGuiInputFlags_RepeatRateNavMove: *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.80f; return;
    case ImGuiInputFlags_RepeatRateNavTweak: *repeat_delay = g.IO.KeyRepeatDelay * 0.72f; *repeat_rate = g.IO.KeyRepeatRate * 0.30f; return;
    case ImGuiInputFlags_RepeatRateDefault: default: *repeat_delay = g.IO.KeyRepeatDelay * 1.00f; *repeat_rate = g.IO.KeyRepeatRate * 1.00f; return;
    }
}



int ImGui::GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float repeat_rate)
{
    ImGuiContext& g = *GImGui;
    const ImGuiKeyData* key_data = GetKeyData(key);
    if (!key_data->Down)
        return 0;
    const float t = key_data->DownDuration;
    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
}


ImVec2 ImGui::GetKeyVector2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down)
{
    return ImVec2(
        GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,
        GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
}


static inline ImGuiID GetRoutingIdFromOwnerId(ImGuiID owner_id)
{
    ImGuiContext& g = *GImGui;
    return (owner_id != ((ImGuiID)-1) && owner_id != ((ImGuiID)0)) ? owner_id : g.CurrentFocusScopeId;
}

ImGuiKeyRoutingData* ImGui::GetShortcutRoutingData(ImGuiKeyChord key_chord)
{






    ImGuiContext& g = *GImGui;
    ImGuiKeyRoutingTable* rt = &g.KeysRoutingTable;
    ImGuiKeyRoutingData* routing_data;
    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
    if (key == ImGuiKey_None)
        key = ConvertSingleModFlagToKey(mods);
    
# 8041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   IsNamedKey(key)
# 8041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "IsNamedKey(key)"
# 8041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8041, __extension__ __PRETTY_FUNCTION__))
# 8041 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             ;



    for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1; idx = routing_data->NextEntryIndex)
    {
        routing_data = &rt->Entries[idx];
        if (routing_data->Mods == mods)
            return routing_data;
    }


    ImGuiKeyRoutingIndex routing_data_idx = (ImGuiKeyRoutingIndex)rt->Entries.Size;
    rt->Entries.push_back(ImGuiKeyRoutingData());
    routing_data = &rt->Entries[routing_data_idx];
    routing_data->Mods = (ImU16)mods;
    routing_data->NextEntryIndex = rt->Index[key - ImGuiKey_NamedKey_BEGIN];
    rt->Index[key - ImGuiKey_NamedKey_BEGIN] = routing_data_idx;
    return routing_data;
}
# 8070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static int CalcRoutingScore(ImGuiWindow* location, ImGuiID owner_id, ImGuiInputFlags flags)
{
    if (flags & ImGuiInputFlags_RouteFocused)
    {
        ImGuiContext& g = *GImGui;
        ImGuiWindow* focused = g.NavWindow;



        if (owner_id != 0 && g.ActiveId == owner_id)
            return 1;







        if (focused != 
# 8088 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                      __null 
# 8088 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           && focused->RootWindow == location->RootWindow)
            for (int next_score = 3; focused != 
# 8089 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                               __null
# 8089 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                   ; next_score++)
            {
                if (focused == location)
                {
                    
# 8093 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   (static_cast <bool> (
# 8093 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   next_score < 255
# 8093 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   ) ? void (0) : __assert_fail (
# 8093 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   "next_score < 255"
# 8093 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8093, __extension__ __PRETTY_FUNCTION__))
# 8093 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                              ;
                    return next_score;
                }
                focused = (focused->RootWindow != focused) ? focused->ParentWindow : 
# 8096 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                    __null
# 8096 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                        ;
            }
        return 255;
    }


    if (flags & ImGuiInputFlags_RouteGlobal)
        return 2;
    if (flags & ImGuiInputFlags_RouteGlobalLow)
        return 254;
    return 0;
}
# 8116 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
bool ImGui::SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
{
    ImGuiContext& g = *GImGui;
    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
        flags |= ImGuiInputFlags_RouteGlobalHigh;
    else
        
# 8122 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 8122 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)
# 8122 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 8122 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "ImIsPowerOfTwo(flags & ImGuiInputFlags_RouteMask_)"
# 8122 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8122, __extension__ __PRETTY_FUNCTION__))
# 8122 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                    ;

    if (flags & ImGuiInputFlags_RouteUnlessBgFocused)
        if (g.NavWindow == 
# 8125 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                          __null
# 8125 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              )
            return false;
    if (flags & ImGuiInputFlags_RouteAlways)
        return true;

    const int score = CalcRoutingScore(g.CurrentWindow, owner_id, flags);
    if (score == 255)
        return false;



    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);

    if (score < routing_data->RoutingNextScore)
    {
        routing_data->RoutingNext = routing_id;
        routing_data->RoutingNextScore = (ImU8)score;
    }


    return routing_data->RoutingCurr == routing_id;
}



bool ImGui::TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id)
{
    const ImGuiID routing_id = GetRoutingIdFromOwnerId(owner_id);
    ImGuiKeyRoutingData* routing_data = GetShortcutRoutingData(key_chord);
    return routing_data->RoutingCurr == routing_id;
}



bool ImGui::IsKeyDown(ImGuiKey key)
{
    return IsKeyDown(key, ((ImGuiID)0));
}

bool ImGui::IsKeyDown(ImGuiKey key, ImGuiID owner_id)
{
    const ImGuiKeyData* key_data = GetKeyData(key);
    if (!key_data->Down)
        return false;
    if (!TestKeyOwner(key, owner_id))
        return false;
    return true;
}

bool ImGui::IsKeyPressed(ImGuiKey key, bool repeat)
{
    return IsKeyPressed(key, ((ImGuiID)0), repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
}


bool ImGui::IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
{
    const ImGuiKeyData* key_data = GetKeyData(key);
    if (!key_data->Down)
        return false;
    const float t = key_data->DownDuration;
    if (t < 0.0f)
        return false;
    
# 8189 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8189 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0
# 8189 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8189 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0"
# 8189 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8189, __extension__ __PRETTY_FUNCTION__))
# 8189 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                     ;

    bool pressed = (t == 0.0f);
    if (!pressed && ((flags & ImGuiInputFlags_Repeat) != 0))
    {
        float repeat_delay, repeat_rate;
        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
    }
    if (!pressed)
        return false;
    if (!TestKeyOwner(key, owner_id))
        return false;
    return true;
}

bool ImGui::IsKeyReleased(ImGuiKey key)
{
    return IsKeyReleased(key, ((ImGuiID)0));
}

bool ImGui::IsKeyReleased(ImGuiKey key, ImGuiID owner_id)
{
    const ImGuiKeyData* key_data = GetKeyData(key);
    if (key_data->DownDurationPrev < 0.0f || key_data->Down)
        return false;
    if (!TestKeyOwner(key, owner_id))
        return false;
    return true;
}

bool ImGui::IsMouseDown(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    
# 8223 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8223 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8223 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8223 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8223 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8223, __extension__ __PRETTY_FUNCTION__))
# 8223 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ((ImGuiID)0));
}

bool ImGui::IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id)
{
    ImGuiContext& g = *GImGui;
    
# 8230 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8230 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8230 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8230 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8230 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8230, __extension__ __PRETTY_FUNCTION__))
# 8230 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id);
}

bool ImGui::IsMouseClicked(ImGuiMouseButton button, bool repeat)
{
    return IsMouseClicked(button, ((ImGuiID)0), repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None);
}

bool ImGui::IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags)
{
    ImGuiContext& g = *GImGui;
    
# 8242 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8242 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8242 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8242 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8242 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8242, __extension__ __PRETTY_FUNCTION__))
# 8242 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    if (!g.IO.MouseDown[button])
        return false;
    const float t = g.IO.MouseDownDuration[button];
    if (t < 0.0f)
        return false;
    
# 8248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0
# 8248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0"
# 8248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8248, __extension__ __PRETTY_FUNCTION__))
# 8248 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                     ;

    const bool repeat = (flags & ImGuiInputFlags_Repeat) != 0;
    const bool pressed = (t == 0.0f) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
    if (!pressed)
        return false;

    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))
        return false;

    return true;
}

bool ImGui::IsMouseReleased(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    
# 8264 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8264 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8264 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8264 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8264 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8264, __extension__ __PRETTY_FUNCTION__))
# 8264 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ((ImGuiID)0));
}

bool ImGui::IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id)
{
    ImGuiContext& g = *GImGui;
    
# 8271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8271, __extension__ __PRETTY_FUNCTION__))
# 8271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id);
}

bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    
# 8278 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8278 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8278 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8278 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8278 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8278, __extension__ __PRETTY_FUNCTION__))
# 8278 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ((ImGuiID)0));
}

int ImGui::GetMouseClickedCount(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    
# 8285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8285, __extension__ __PRETTY_FUNCTION__))
# 8285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    return g.IO.MouseClickedCount[button];
}



bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    
# 8294 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8294 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8294 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8294 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8294 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8294, __extension__ __PRETTY_FUNCTION__))
# 8294 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

bool ImGui::IsMouseDragging(ImGuiMouseButton button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    
# 8303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8303, __extension__ __PRETTY_FUNCTION__))
# 8303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    if (!g.IO.MouseDown[button])
        return false;
    return IsMouseDragPastThreshold(button, lock_threshold);
}

ImVec2 ImGui::GetMousePos()
{
    ImGuiContext& g = *GImGui;
    return g.IO.MousePos;
}


ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    if (g.BeginPopupStack.Size > 0)
        return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
    return g.IO.MousePos;
}


bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{


    
# 8329 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8329 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   GImGui != 
# 8329 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 8329 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "GImGui != __null"
# 8329 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8329, __extension__ __PRETTY_FUNCTION__))
# 8329 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            ;
    const float MOUSE_INVALID = -256000.0f;
    ImVec2 p = mouse_pos ? *mouse_pos : GImGui->IO.MousePos;
    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}


bool ImGui::IsAnyMouseDown()
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown)))); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}




ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    
# 8351 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8351 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8351 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8351 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8351 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8351, __extension__ __PRETTY_FUNCTION__))
# 8351 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))
                return g.IO.MousePos - g.IO.MouseClickedPos[button];
    return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(ImGuiMouseButton button)
{
    ImGuiContext& g = *GImGui;
    
# 8364 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8364 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))
# 8364 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8364 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "button >= 0 && button < ((int)(sizeof(g.IO.MouseDown) / sizeof(*(g.IO.MouseDown))))"
# 8364 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8364, __extension__ __PRETTY_FUNCTION__))
# 8364 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                  ;

    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}





ImGuiMouseCursor ImGui::GetMouseCursor()
{
    ImGuiContext& g = *GImGui;
    return g.MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
    ImGuiContext& g = *GImGui;
    g.MouseCursor = cursor_type;
}

void ImGui::SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard)
{
    ImGuiContext& g = *GImGui;
    g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
}

void ImGui::SetNextFrameWantCaptureMouse(bool want_capture_mouse)
{
    ImGuiContext& g = *GImGui;
    g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0;
}


static const char* GetInputSourceName(ImGuiInputSource source)
{
    const char* input_source_names[] = { "None", "Mouse", "Keyboard", "Gamepad", "Nav", "Clipboard" };
    
# 8401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   ((int)(sizeof(input_source_names) / sizeof(*(input_source_names)))) == ImGuiInputSource_COUNT && source >= 0 && source < ImGuiInputSource_COUNT
# 8401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "((int)(sizeof(input_source_names) / sizeof(*(input_source_names)))) == ImGuiInputSource_COUNT && source >= 0 && source < ImGuiInputSource_COUNT"
# 8401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8401, __extension__ __PRETTY_FUNCTION__))
# 8401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                          ;
    return input_source_names[source];
}
static void DebugPrintInputEvent(const char* prefix, const ImGuiInputEvent* e)
{
    ImGuiContext& g = *GImGui;
    if (e->Type == ImGuiInputEventType_MousePos) { if (e->MousePos.PosX == -3.40282346638528859811704183484516925e+38F && e->MousePos.PosY == -3.40282346638528859811704183484516925e+38F) do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: MousePos (-FLT_MAX, -FLT_MAX)\n", prefix); } while (0); else do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: MousePos (%.1f, %.1f)\n", prefix, e->MousePos.PosX, e->MousePos.PosY); } while (0); return; }
    if (e->Type == ImGuiInputEventType_MouseButton) { do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: MouseButton %d %s\n", prefix, e->MouseButton.Button, e->MouseButton.Down ? "Down" : "Up"); } while (0); return; }
    if (e->Type == ImGuiInputEventType_MouseWheel) { do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: MouseWheel (%.1f, %.1f)\n", prefix, e->MouseWheel.WheelX, e->MouseWheel.WheelY); } while (0); return; }
    if (e->Type == ImGuiInputEventType_Key) { do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: Key \"%s\" %s\n", prefix, ImGui::GetKeyName(e->Key.Key), e->Key.Down ? "Down" : "Up"); } while (0); return; }
    if (e->Type == ImGuiInputEventType_Text) { do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: Text: %c (U+%08X)\n", prefix, e->Text.Char, e->Text.Char); } while (0); return; }
    if (e->Type == ImGuiInputEventType_Focus) { do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO) ImGui::DebugLog("%s: AppFocused %d\n", prefix, e->AppFocused.Focused); } while (0); return; }
}






void ImGui::UpdateInputEvents(bool trickle_fast_inputs)
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;




    const bool trickle_interleaved_keys_and_text = (trickle_fast_inputs && g.WantTextInputNextFrame == 1);

    bool mouse_moved = false, mouse_wheeled = false, key_changed = false, text_inputted = false;
    int mouse_button_changed = 0x00;
    ImBitArray<ImGuiKey_KeysData_SIZE> key_changed_mask;

    int event_n = 0;
    for (; event_n < g.InputEventsQueue.Size; event_n++)
    {
        ImGuiInputEvent* e = &g.InputEventsQueue[event_n];
        if (e->Type == ImGuiInputEventType_MousePos)
        {

            ImVec2 event_pos(e->MousePos.PosX, e->MousePos.PosY);
            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))
                break;
            io.MousePos = event_pos;
            mouse_moved = true;
        }
        else if (e->Type == ImGuiInputEventType_MouseButton)
        {

            const ImGuiMouseButton button = e->MouseButton.Button;
            
# 8451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 8451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           button >= 0 && button < ImGuiMouseButton_COUNT
# 8451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 8451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "button >= 0 && button < ImGuiMouseButton_COUNT"
# 8451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8451, __extension__ __PRETTY_FUNCTION__))
# 8451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                    ;
            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))
                break;
            io.MouseDown[button] = e->MouseButton.Down;
            mouse_button_changed |= (1 << button);
        }
        else if (e->Type == ImGuiInputEventType_MouseWheel)
        {

            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))
                break;
            io.MouseWheelH += e->MouseWheel.WheelX;
            io.MouseWheel += e->MouseWheel.WheelY;
            mouse_wheeled = true;
        }
        else if (e->Type == ImGuiInputEventType_Key)
        {

            ImGuiKey key = e->Key.Key;
            
# 8470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 8470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           key != ImGuiKey_None
# 8470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 8470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "key != ImGuiKey_None"
# 8470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8470, __extension__ __PRETTY_FUNCTION__))
# 8470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          ;
            ImGuiKeyData* key_data = GetKeyData(key);
            const int key_data_index = (int)(key_data - g.IO.KeysData);
            if (trickle_fast_inputs && key_data->Down != e->Key.Down && (key_changed_mask.TestBit(key_data_index) || text_inputted || mouse_button_changed != 0))
                break;
            key_data->Down = e->Key.Down;
            key_data->AnalogValue = e->Key.AnalogValue;
            key_changed = true;
            key_changed_mask.SetBit(key_data_index);

            if (key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super)
            {
                if (key == ImGuiMod_Ctrl) { io.KeyCtrl = key_data->Down; }
                if (key == ImGuiMod_Shift) { io.KeyShift = key_data->Down; }
                if (key == ImGuiMod_Alt) { io.KeyAlt = key_data->Down; }
                if (key == ImGuiMod_Super) { io.KeySuper = key_data->Down; }
                io.KeyMods = GetMergedModsFromBools();
            }



            io.KeysDown[key_data_index] = key_data->Down;
            if (io.KeyMap[key_data_index] != -1)
                io.KeysDown[io.KeyMap[key_data_index]] = key_data->Down;

        }
        else if (e->Type == ImGuiInputEventType_Text)
        {

            if (trickle_fast_inputs && ((key_changed && trickle_interleaved_keys_and_text) || mouse_button_changed != 0 || mouse_moved || mouse_wheeled))
                break;
            unsigned int c = e->Text.Char;
            io.InputQueueCharacters.push_back(c <= 0xFFFF ? (ImWchar)c : 0xFFFD);
            if (trickle_interleaved_keys_and_text)
                text_inputted = true;
        }
        else if (e->Type == ImGuiInputEventType_Focus)
        {


            const bool focus_lost = !e->AppFocused.Focused;
            io.AppFocusLost = focus_lost;
        }
        else
        {
            
# 8515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 8515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           0 && "Unknown event!"
# 8515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 8515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "0 && \"Unknown event!\""
# 8515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8515, __extension__ __PRETTY_FUNCTION__))
# 8515 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;
        }
    }



    for (int n = 0; n < event_n; n++)
        g.InputEventsTrail.push_back(g.InputEventsQueue[n]);



    if (event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO))
        for (int n = 0; n < g.InputEventsQueue.Size; n++)
            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);



    if (event_n == g.InputEventsQueue.Size)
        g.InputEventsQueue.resize(0);
    else
        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);





    if (g.IO.AppFocusLost)
        g.IO.ClearInputKeys();
}

ImGuiID ImGui::GetKeyOwner(ImGuiKey key)
{
    if (!IsNamedKeyOrModKey(key))
        return ((ImGuiID)-1);

    ImGuiContext& g = *GImGui;
    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
    ImGuiID owner_id = owner_data->OwnerCurr;

    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ((ImGuiID)0))
        if (key >= (ImGuiKey_NamedKey_BEGIN) && key < (ImGuiKey_GamepadStart))
            return ((ImGuiID)-1);

    return owner_id;
}





bool ImGui::TestKeyOwner(ImGuiKey key, ImGuiID owner_id)
{
    if (!IsNamedKeyOrModKey(key))
        return true;

    ImGuiContext& g = *GImGui;
    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ((ImGuiID)0))
        if (key >= (ImGuiKey_NamedKey_BEGIN) && key < (ImGuiKey_GamepadStart))
            return false;

    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
    if (owner_id == ((ImGuiID)0))
        return (owner_data->LockThisFrame == false);




    if (owner_data->OwnerCurr != owner_id)
    {
        if (owner_data->LockThisFrame)
            return false;
        if (owner_data->OwnerCurr != ((ImGuiID)-1))
            return false;
    }

    return true;
}






void ImGui::SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags)
{
    
# 8600 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8600 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   IsNamedKeyOrModKey(key) && (owner_id != ((ImGuiID)0) || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))
# 8600 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8600 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "IsNamedKeyOrModKey(key) && (owner_id != ((ImGuiID)0) || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))"
# 8600 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8600, __extension__ __PRETTY_FUNCTION__))
# 8600 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                        ;
    
# 8601 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8601 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0
# 8601 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8601 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0"
# 8601 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8601, __extension__ __PRETTY_FUNCTION__))
# 8601 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                    ;

    ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
    owner_data->OwnerCurr = owner_data->OwnerNext = owner_id;



    owner_data->LockUntilRelease = (flags & ImGuiInputFlags_LockUntilRelease) != 0;
    owner_data->LockThisFrame = (flags & ImGuiInputFlags_LockThisFrame) != 0 || (owner_data->LockUntilRelease);
}







void ImGui::SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = g.LastItemData.ID;
    if (id == 0 || (g.HoveredId != id && g.ActiveId != id))
        return;
    if ((flags & ImGuiInputFlags_CondMask_) == 0)
        flags |= ImGuiInputFlags_CondDefault_;
    if ((g.HoveredId == id && (flags & ImGuiInputFlags_CondHovered)) || (g.ActiveId == id && (flags & ImGuiInputFlags_CondActive)))
    {
        
# 8628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 8628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (flags & ~ImGuiInputFlags_SupportedBySetItemKeyOwner) == 0
# 8628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 8628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(flags & ~ImGuiInputFlags_SupportedBySetItemKeyOwner) == 0"
# 8628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8628, __extension__ __PRETTY_FUNCTION__))
# 8628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                            ;
        SetKeyOwner(key, id, flags & ~ImGuiInputFlags_CondMask_);
    }
}



bool ImGui::Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id, ImGuiInputFlags flags)
{
    ImGuiContext& g = *GImGui;


    if ((flags & ImGuiInputFlags_RouteMask_) == 0)
        flags |= ImGuiInputFlags_RouteFocused;
    if (!SetShortcutRouting(key_chord, owner_id, flags))
        return false;

    ImGuiKey key = (ImGuiKey)(key_chord & ~ImGuiMod_Mask_);
    ImGuiKey mods = (ImGuiKey)(key_chord & ImGuiMod_Mask_);
    if (g.IO.KeyMods != mods)
        return false;


    if (key == ImGuiKey_None)
        key = ConvertSingleModFlagToKey(mods);

    if (!IsKeyPressed(key, owner_id, (flags & (ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_))))
        return false;
    
# 8656 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8656 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & ~ImGuiInputFlags_SupportedByShortcut) == 0
# 8656 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8656 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & ~ImGuiInputFlags_SupportedByShortcut) == 0"
# 8656 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8656, __extension__ __PRETTY_FUNCTION__))
# 8656 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                 ;

    return true;
}
# 8674 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)
{
    bool error = false;
    if (strcmp(version, "1.89.1 WIP") != 0) { error = true; 
# 8677 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                            (static_cast <bool> (
# 8677 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            strcmp(version, "1.89.1 WIP") == 0 && "Mismatched version string!"
# 8677 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                            ) ? void (0) : __assert_fail (
# 8677 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            "strcmp(version, \"1.89.1 WIP\") == 0 && \"Mismatched version string!\""
# 8677 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                            , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8677, __extension__ __PRETTY_FUNCTION__))
# 8677 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                          ; }
    if (sz_io != sizeof(ImGuiIO)) { error = true; 
# 8678 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                 (static_cast <bool> (
# 8678 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                 sz_io == sizeof(ImGuiIO) && "Mismatched struct layout!"
# 8678 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                 ) ? void (0) : __assert_fail (
# 8678 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                 "sz_io == sizeof(ImGuiIO) && \"Mismatched struct layout!\""
# 8678 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                 , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8678, __extension__ __PRETTY_FUNCTION__))
# 8678 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                   ; }
    if (sz_style != sizeof(ImGuiStyle)) { error = true; 
# 8679 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                       (static_cast <bool> (
# 8679 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                       sz_style == sizeof(ImGuiStyle) && "Mismatched struct layout!"
# 8679 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                       ) ? void (0) : __assert_fail (
# 8679 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                       "sz_style == sizeof(ImGuiStyle) && \"Mismatched struct layout!\""
# 8679 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8679, __extension__ __PRETTY_FUNCTION__))
# 8679 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                               ; }
    if (sz_vec2 != sizeof(ImVec2)) { error = true; 
# 8680 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  (static_cast <bool> (
# 8680 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  sz_vec2 == sizeof(ImVec2) && "Mismatched struct layout!"
# 8680 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  ) ? void (0) : __assert_fail (
# 8680 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  "sz_vec2 == sizeof(ImVec2) && \"Mismatched struct layout!\""
# 8680 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8680, __extension__ __PRETTY_FUNCTION__))
# 8680 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                     ; }
    if (sz_vec4 != sizeof(ImVec4)) { error = true; 
# 8681 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  (static_cast <bool> (
# 8681 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  sz_vec4 == sizeof(ImVec4) && "Mismatched struct layout!"
# 8681 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  ) ? void (0) : __assert_fail (
# 8681 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  "sz_vec4 == sizeof(ImVec4) && \"Mismatched struct layout!\""
# 8681 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8681, __extension__ __PRETTY_FUNCTION__))
# 8681 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                     ; }
    if (sz_vert != sizeof(ImDrawVert)) { error = true; 
# 8682 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      (static_cast <bool> (
# 8682 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"
# 8682 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      ) ? void (0) : __assert_fail (
# 8682 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      "sz_vert == sizeof(ImDrawVert) && \"Mismatched struct layout!\""
# 8682 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                      , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8682, __extension__ __PRETTY_FUNCTION__))
# 8682 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                             ; }
    if (sz_idx != sizeof(ImDrawIdx)) { error = true; 
# 8683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                    (static_cast <bool> (
# 8683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                    sz_idx == sizeof(ImDrawIdx) && "Mismatched struct layout!"
# 8683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                    ) ? void (0) : __assert_fail (
# 8683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                    "sz_idx == sizeof(ImDrawIdx) && \"Mismatched struct layout!\""
# 8683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                    , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8683, __extension__ __PRETTY_FUNCTION__))
# 8683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                         ; }
    return !error;
}
# 8702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    
# 8706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->DC.IsSetPos
# 8706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->DC.IsSetPos"
# 8706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8706, __extension__ __PRETTY_FUNCTION__))
# 8706 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 ;
    window->DC.IsSetPos = false;







    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

}

static void ImGui::ErrorCheckNewFrameSanityChecks()
{
    ImGuiContext& g = *GImGui;







    if (true) 
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
             (static_cast <bool> (
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
             1
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
             ) ? void (0) : __assert_fail (
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
             "1"
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
             , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8729, __extension__ __PRETTY_FUNCTION__))
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         ; else 
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                (static_cast <bool> (
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                0
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                ) ? void (0) : __assert_fail (
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                "0"
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8729, __extension__ __PRETTY_FUNCTION__))
# 8729 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            ;



    
# 8733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Initialized
# 8733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Initialized"
# 8733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8733, __extension__ __PRETTY_FUNCTION__))
# 8733 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;
    
# 8734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (g.IO.DeltaTime > 0.0f || g.FrameCount == 0) && "Need a positive DeltaTime!"
# 8734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(g.IO.DeltaTime > 0.0f || g.FrameCount == 0) && \"Need a positive DeltaTime!\""
# 8734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8734, __extension__ __PRETTY_FUNCTION__))
# 8734 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
    
# 8735 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8735 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && "Forgot to call Render() or EndFrame() at the end of the previous frame?"
# 8735 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8735 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && \"Forgot to call Render() or EndFrame() at the end of the previous frame?\""
# 8735 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8735, __extension__ __PRETTY_FUNCTION__))
# 8735 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                    ;
    
# 8736 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8736 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && "Invalid DisplaySize value!"
# 8736 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8736 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && \"Invalid DisplaySize value!\""
# 8736 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8736, __extension__ __PRETTY_FUNCTION__))
# 8736 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
    
# 8737 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8737 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.IO.Fonts->IsBuilt() && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()"
# 8737 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8737 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.IO.Fonts->IsBuilt() && \"Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()\""
# 8737 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8737, __extension__ __PRETTY_FUNCTION__))
# 8737 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                                                                                                        ;
    
# 8738 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8738 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Style.CurveTessellationTol > 0.0f && "Invalid style setting!"
# 8738 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8738 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Style.CurveTessellationTol > 0.0f && \"Invalid style setting!\""
# 8738 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8738, __extension__ __PRETTY_FUNCTION__))
# 8738 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                   ;
    
# 8739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Style.CircleTessellationMaxError > 0.0f && "Invalid style setting!"
# 8739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Style.CircleTessellationMaxError > 0.0f && \"Invalid style setting!\""
# 8739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8739, __extension__ __PRETTY_FUNCTION__))
# 8739 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                   ;
    
# 8740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && "Invalid style setting!"
# 8740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && \"Invalid style setting!\""
# 8740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8740, __extension__ __PRETTY_FUNCTION__))
# 8740 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                   ;
    
# 8741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting."
# 8741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && \"Invalid style setting.\""
# 8741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8741, __extension__ __PRETTY_FUNCTION__))
# 8741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                            ;
    
# 8742 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8742 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right
# 8742 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8742 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Style.WindowMenuButtonPosition == ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir_Right"
# 8742 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8742, __extension__ __PRETTY_FUNCTION__))
# 8742 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                          ;
    
# 8743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right
# 8743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Style.ColorButtonPosition == ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir_Right"
# 8743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8743, __extension__ __PRETTY_FUNCTION__))
# 8743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                           ;

    for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_COUNT; n++)
        
# 8746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 8746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < 512 && "io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)"
# 8746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 8746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < 512 && \"io.KeyMap[] contains an out of bound value (need to be 0..511, or -1 for unmapped key)\""
# 8746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8746, __extension__ __PRETTY_FUNCTION__))
# 8746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                                   ;


    if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && g.IO.BackendUsingLegacyKeyArrays == 1)
        
# 8750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 8750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation."
# 8750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 8750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.IO.KeyMap[ImGuiKey_Space] != -1 && \"ImGuiKey_Space is not mapped, required for keyboard navigation.\""
# 8750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8750, __extension__ __PRETTY_FUNCTION__))
# 8750 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                        ;



    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        g.IO.ConfigWindowsResizeFromEdges = false;
}

static void ImGui::ErrorCheckEndFrameSanityChecks()
{
    ImGuiContext& g = *GImGui;







    const ImGuiKeyChord key_mods = GetMergedModsFromBools();
    
# 8769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods"
# 8769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(key_mods == 0 || g.IO.KeyMods == key_mods) && \"Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods\""
# 8769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8769, __extension__ __PRETTY_FUNCTION__))
# 8769 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                     ;
    ((void)(key_mods));






    if (g.CurrentWindowStack.Size != 1)
    {
        if (g.CurrentWindowStack.Size > 1)
        {
            
# 8781 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 8781 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           (g.CurrentWindowStack.Size == 1) && "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?"
# 8781 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 8781 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "(g.CurrentWindowStack.Size == 1) && \"Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?\""
# 8781 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8781, __extension__ __PRETTY_FUNCTION__))
# 8781 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                          ;
            while (g.CurrentWindowStack.Size > 1)
                End();
        }
        else
        {
            
# 8787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 8787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           (g.CurrentWindowStack.Size == 1) && "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?"
# 8787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 8787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "(g.CurrentWindowStack.Size == 1) && \"Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?\""
# 8787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8787, __extension__ __PRETTY_FUNCTION__))
# 8787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                         ;
        }
    }

    
# 8791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (g.GroupStack.Size == 0) && "Missing EndGroup call!"
# 8791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(g.GroupStack.Size == 0) && \"Missing EndGroup call!\""
# 8791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8791, __extension__ __PRETTY_FUNCTION__))
# 8791 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         ;
}






void ImGui::ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data)
{

    ImGuiContext& g = *GImGui;
    while (g.CurrentWindowStack.Size > 0)
    {
        ErrorCheckEndWindowRecover(log_callback, user_data);
        ImGuiWindow* window = g.CurrentWindow;
        if (g.CurrentWindowStack.Size == 1)
        {
            
# 8809 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 8809 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           window->IsFallbackWindow
# 8809 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 8809 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "window->IsFallbackWindow"
# 8809 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8809, __extension__ __PRETTY_FUNCTION__))
# 8809 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                              ;
            break;
        }
        if (window->Flags & ImGuiWindowFlags_ChildWindow)
        {
            if (log_callback) log_callback(user_data, "Recovered from missing EndChild() for '%s'", window->Name);
            EndChild();
        }
        else
        {
            if (log_callback) log_callback(user_data, "Recovered from missing End() for '%s'", window->Name);
            End();
        }
    }
}


void ImGui::ErrorCheckEndWindowRecover(ImGuiErrorLogCallback log_callback, void* user_data)
{
    ImGuiContext& g = *GImGui;
    while (g.CurrentTable && (g.CurrentTable->OuterWindow == g.CurrentWindow || g.CurrentTable->InnerWindow == g.CurrentWindow))
    {
        if (log_callback) log_callback(user_data, "Recovered from missing EndTable() in '%s'", g.CurrentTable->OuterWindow->Name);
        EndTable();
    }

    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStackSizes* stack_sizes = &g.CurrentWindowStack.back().StackSizesOnBegin;
    
# 8837 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8837 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window != 
# 8837 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 8837 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window != __null"
# 8837 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8837, __extension__ __PRETTY_FUNCTION__))
# 8837 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            ;
    while (g.CurrentTabBar != 
# 8838 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                             __null
# 8838 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 )
    {
        if (log_callback) log_callback(user_data, "Recovered from missing EndTabBar() in '%s'", window->Name);
        EndTabBar();
    }
    while (window->DC.TreeDepth > 0)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing TreePop() in '%s'", window->Name);
        TreePop();
    }
    while (g.GroupStack.Size > stack_sizes->SizeOfGroupStack)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing EndGroup() in '%s'", window->Name);
        EndGroup();
    }
    while (window->IDStack.Size > 1)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing PopID() in '%s'", window->Name);
        PopID();
    }
    while (g.DisabledStackSize > stack_sizes->SizeOfDisabledStack)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing EndDisabled() in '%s'", window->Name);
        EndDisabled();
    }
    while (g.ColorStack.Size > stack_sizes->SizeOfColorStack)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing PopStyleColor() in '%s' for ImGuiCol_%s", window->Name, GetStyleColorName(g.ColorStack.back().Col));
        PopStyleColor();
    }
    while (g.ItemFlagsStack.Size > stack_sizes->SizeOfItemFlagsStack)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing PopItemFlag() in '%s'", window->Name);
        PopItemFlag();
    }
    while (g.StyleVarStack.Size > stack_sizes->SizeOfStyleVarStack)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing PopStyleVar() in '%s'", window->Name);
        PopStyleVar();
    }
    while (g.FocusScopeStack.Size > stack_sizes->SizeOfFocusScopeStack + 1)
    {
        if (log_callback) log_callback(user_data, "Recovered from missing PopFocusScope() in '%s'", window->Name);
        PopFocusScope();
    }
}


void ImGuiStackSizes::SetToCurrentState()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    SizeOfIDStack = (short)window->IDStack.Size;
    SizeOfColorStack = (short)g.ColorStack.Size;
    SizeOfStyleVarStack = (short)g.StyleVarStack.Size;
    SizeOfFontStack = (short)g.FontStack.Size;
    SizeOfFocusScopeStack = (short)g.FocusScopeStack.Size;
    SizeOfGroupStack = (short)g.GroupStack.Size;
    SizeOfItemFlagsStack = (short)g.ItemFlagsStack.Size;
    SizeOfBeginPopupStack = (short)g.BeginPopupStack.Size;
    SizeOfDisabledStack = (short)g.DisabledStackSize;
}


void ImGuiStackSizes::CompareWithCurrentState()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ((void)(window));



    
# 8910 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8910 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfIDStack == window->IDStack.Size && "PushID/PopID or TreeNode/TreePop Mismatch!"
# 8910 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8910 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfIDStack == window->IDStack.Size && \"PushID/PopID or TreeNode/TreePop Mismatch!\""
# 8910 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8910, __extension__ __PRETTY_FUNCTION__))
# 8910 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                               ;



    
# 8914 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8914 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfGroupStack == g.GroupStack.Size && "BeginGroup/EndGroup Mismatch!"
# 8914 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8914 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfGroupStack == g.GroupStack.Size && \"BeginGroup/EndGroup Mismatch!\""
# 8914 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8914, __extension__ __PRETTY_FUNCTION__))
# 8914 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                  ;
    
# 8915 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8915 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfBeginPopupStack == g.BeginPopupStack.Size && "BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!"
# 8915 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8915 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfBeginPopupStack == g.BeginPopupStack.Size && \"BeginPopup/EndPopup or BeginMenu/EndMenu Mismatch!\""
# 8915 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8915, __extension__ __PRETTY_FUNCTION__))
# 8915 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                       ;
    
# 8916 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8916 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfDisabledStack == g.DisabledStackSize && "BeginDisabled/EndDisabled Mismatch!"
# 8916 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8916 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfDisabledStack == g.DisabledStackSize && \"BeginDisabled/EndDisabled Mismatch!\""
# 8916 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8916, __extension__ __PRETTY_FUNCTION__))
# 8916 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                        ;
    
# 8917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfItemFlagsStack >= g.ItemFlagsStack.Size && "PushItemFlag/PopItemFlag Mismatch!"
# 8917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfItemFlagsStack >= g.ItemFlagsStack.Size && \"PushItemFlag/PopItemFlag Mismatch!\""
# 8917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8917, __extension__ __PRETTY_FUNCTION__))
# 8917 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
    
# 8918 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8918 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfColorStack >= g.ColorStack.Size && "PushStyleColor/PopStyleColor Mismatch!"
# 8918 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8918 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfColorStack >= g.ColorStack.Size && \"PushStyleColor/PopStyleColor Mismatch!\""
# 8918 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8918, __extension__ __PRETTY_FUNCTION__))
# 8918 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                           ;
    
# 8919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfStyleVarStack >= g.StyleVarStack.Size && "PushStyleVar/PopStyleVar Mismatch!"
# 8919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfStyleVarStack >= g.StyleVarStack.Size && \"PushStyleVar/PopStyleVar Mismatch!\""
# 8919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8919, __extension__ __PRETTY_FUNCTION__))
# 8919 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
    
# 8920 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8920 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfFontStack >= g.FontStack.Size && "PushFont/PopFont Mismatch!"
# 8920 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8920 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfFontStack >= g.FontStack.Size && \"PushFont/PopFont Mismatch!\""
# 8920 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8920, __extension__ __PRETTY_FUNCTION__))
# 8920 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                               ;
    
# 8921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 8921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   SizeOfFocusScopeStack == g.FocusScopeStack.Size && "PushFocusScope/PopFocusScope Mismatch!"
# 8921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 8921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "SizeOfFocusScopeStack == g.FocusScopeStack.Size && \"PushFocusScope/PopFocusScope Mismatch!\""
# 8921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 8921, __extension__ __PRETTY_FUNCTION__))
# 8921 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                           ;
}
# 8960 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::ItemSize(const ImVec2& size, float text_baseline_y)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;




    const float offset_to_match_baseline_y = (text_baseline_y >= 0) ? ImMax(0.0f, window->DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0f;

    const float line_y1 = window->DC.IsSameLine ? window->DC.CursorPosPrevLine.y : window->DC.CursorPos.y;
    const float line_height = ImMax(window->DC.CurrLineSize.y, window->DC.CursorPos.y - line_y1 + size.y + offset_to_match_baseline_y);



    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x + size.x;
    window->DC.CursorPosPrevLine.y = line_y1;
    window->DC.CursorPos.x = ((float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x));
    window->DC.CursorPos.y = ((float)(int)(line_y1 + line_height + g.Style.ItemSpacing.y));
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);


    window->DC.PrevLineSize.y = line_height;
    window->DC.CurrLineSize.y = 0.0f;
    window->DC.PrevLineTextBaseOffset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);
    window->DC.CurrLineTextBaseOffset = 0.0f;
    window->DC.IsSameLine = window->DC.IsSetPos = false;


    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        SameLine();
}




bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg, ImGuiItemFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;



    g.LastItemData.ID = id;
    g.LastItemData.Rect = bb;
    g.LastItemData.NavRect = nav_bb_arg ? *nav_bb_arg : bb;
    g.LastItemData.InFlags = g.CurrentItemFlags | extra_flags;
    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;


    if (id != 0)
    {
        KeepAliveID(id);
# 9026 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        if (!(g.LastItemData.InFlags & ImGuiItemFlags_NoNav))
        {
            window->DC.NavLayersActiveMaskNext |= (1 << window->DC.NavLayerCurrent);
            if (g.NavId == id || g.NavAnyRequest)
                if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                    if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
                        NavProcessItem();
        }




        
# 9038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 9038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       id != window->ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!"
# 9038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 9038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "id != window->ID && \"Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!\""
# 9038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9038, __extension__ __PRETTY_FUNCTION__))
# 9038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                                          ;
    }
    g.NextItemData.Flags = ImGuiNextItemDataFlags_None;
# 9052 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    const bool is_rect_visible = bb.Overlaps(window->ClipRect);
    if (!is_rect_visible)
        if (id == 0 || (id != g.ActiveId && id != g.NavId))
            if (!g.LogEnabled)
                return false;



    if (id != 0 && id == g.DebugLocateId)
        DebugLocateItemResolveWithLastItem();




    if (is_rect_visible)
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    return true;
}






void ImGui::SameLine(float offset_from_start_x, float spacing_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    if (offset_from_start_x != 0.0f)
    {
        if (spacing_w < 0.0f)
            spacing_w = 0.0f;
        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0f)
            spacing_w = g.Style.ItemSpacing.x;
        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    window->DC.CurrLineSize = window->DC.PrevLineSize;
    window->DC.CurrLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
    window->DC.IsSameLine = true;
}

ImVec2 ImGui::GetCursorScreenPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}




void ImGui::SetCursorScreenPos(const ImVec2& pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = pos;

    window->DC.IsSetPos = true;
}



ImVec2 ImGui::GetCursorPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;

    window->DC.IsSetPos = true;
}

void ImGui::SetCursorPosX(float x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

    window->DC.IsSetPos = true;
}

void ImGui::SetCursorPosY(float y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;

    window->DC.IsSetPos = true;
}

ImVec2 ImGui::GetCursorStartPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorStartPos - window->Pos;
}

void ImGui::Indent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}


void ImGui::SetNextItemWidth(float item_width)
{
    ImGuiContext& g = *GImGui;
    g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasWidth;
    g.NextItemData.Width = item_width;
}


void ImGui::PushItemWidth(float item_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiStyle& style = g.Style;
    const float w_item_one = ImMax(1.0f, ((float)(int)((w_full - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components)));
    const float w_item_last = ImMax(1.0f, ((float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components - 1))));
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components - 2; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = (components == 1) ? w_item_last : w_item_one;
    g.NextItemData.Flags &= ~ImGuiNextItemDataFlags_HasWidth;
}

void ImGui::PopItemWidth()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
    window->DC.ItemWidthStack.pop_back();
}



float ImGui::CalcItemWidth()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float w;
    if (g.NextItemData.Flags & ImGuiNextItemDataFlags_HasWidth)
        w = g.NextItemData.Width;
    else
        w = window->DC.ItemWidth;
    if (w < 0.0f)
    {
        float region_max_x = GetContentRegionMaxAbs().x;
        w = ImMax(1.0f, region_max_x - window->DC.CursorPos.x + w);
    }
    w = ((float)(int)(w));
    return w;
}





ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImVec2 region_max;
    if (size.x < 0.0f || size.y < 0.0f)
        region_max = GetContentRegionMaxAbs();

    if (size.x == 0.0f)
        size.x = default_w;
    else if (size.x < 0.0f)
        size.x = ImMax(4.0f, region_max.x - window->DC.CursorPos.x + size.x);

    if (size.y == 0.0f)
        size.y = default_h;
    else if (size.y < 0.0f)
        size.y = ImMax(4.0f, region_max.y - window->DC.CursorPos.y + size.y);

    return size;
}

float ImGui::GetTextLineHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}




ImVec2 ImGui::GetContentRegionMax()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImVec2 mx = window->ContentRegionRect.Max - window->Pos;
    if (window->DC.CurrentColumns || g.CurrentTable)
        mx.x = window->WorkRect.Max.x - window->Pos.x;
    return mx;
}


ImVec2 ImGui::GetContentRegionMaxAbs()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImVec2 mx = window->ContentRegionRect.Max;
    if (window->DC.CurrentColumns || g.CurrentTable)
        mx.x = window->WorkRect.Max.x;
    return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return GetContentRegionMaxAbs() - window->DC.CursorPos;
}


ImVec2 ImGui::GetWindowContentRegionMin()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ContentRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ContentRegionRect.Max - window->Pos;
}




void ImGui::BeginGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    g.GroupStack.resize(g.GroupStack.Size + 1);
    ImGuiGroupData& group_data = g.GroupStack.back();
    group_data.WindowID = window->ID;
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrLineSize = window->DC.CurrLineSize;
    group_data.BackupCurrLineTextBaseOffset = window->DC.CurrLineTextBaseOffset;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.EmitItem = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    if (g.LogEnabled)
        g.LogLinePosY = -3.40282346638528859811704183484516925e+38F;
}

void ImGui::EndGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    
# 9374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.GroupStack.Size > 0
# 9374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.GroupStack.Size > 0"
# 9374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9374, __extension__ __PRETTY_FUNCTION__))
# 9374 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;

    ImGuiGroupData& group_data = g.GroupStack.back();
    
# 9377 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9377 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   group_data.WindowID == window->ID
# 9377 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9377 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "group_data.WindowID == window->ID"
# 9377 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9377, __extension__ __PRETTY_FUNCTION__))
# 9377 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               ;

    if (window->DC.IsSetPos)
        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

    ImRect group_bb(group_data.BackupCursorPos, ImMax(window->DC.CursorMaxPos, group_data.BackupCursorPos));

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrLineSize = group_data.BackupCurrLineSize;
    window->DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
    if (g.LogEnabled)
        g.LogLinePosY = -3.40282346638528859811704183484516925e+38F;

    if (!group_data.EmitItem)
    {
        g.GroupStack.pop_back();
        return;
    }

    window->DC.CurrLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset);
    ItemSize(group_bb.GetSize());
    ItemAdd(group_bb, 0, 
# 9401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        __null
# 9401 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                            , ImGuiItemFlags_NoTabStop);





    const bool group_contains_curr_active_id = (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId;
    const bool group_contains_prev_active_id = (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true);
    if (group_contains_curr_active_id)
        g.LastItemData.ID = g.ActiveId;
    else if (group_contains_prev_active_id)
        g.LastItemData.ID = g.ActiveIdPreviousFrame;
    g.LastItemData.Rect = group_bb;


    const bool group_contains_curr_hovered_id = (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0;
    if (group_contains_curr_hovered_id)
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;


    if (group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame)
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;


    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
    if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame)
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Deactivated;

    g.GroupStack.pop_back();

}
# 9442 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static float CalcScrollEdgeSnap(float target, float snap_min, float snap_max, float snap_threshold, float center_ratio)
{
    if (target <= snap_min + snap_threshold)
        return ImLerp(snap_min, target, center_ratio);
    if (target >= snap_max - snap_threshold)
        return ImLerp(target, snap_max, center_ratio);
    return target;
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)
{
    ImVec2 scroll = window->Scroll;
    if (window->ScrollTarget.x < 3.40282346638528859811704183484516925e+38F)
    {
        float decoration_total_width = window->ScrollbarSizes.x;
        float center_x_ratio = window->ScrollTargetCenterRatio.x;
        float scroll_target_x = window->ScrollTarget.x;
        if (window->ScrollTargetEdgeSnapDist.x > 0.0f)
        {
            float snap_x_min = 0.0f;
            float snap_x_max = window->ScrollMax.x + window->SizeFull.x - decoration_total_width;
            scroll_target_x = CalcScrollEdgeSnap(scroll_target_x, snap_x_min, snap_x_max, window->ScrollTargetEdgeSnapDist.x, center_x_ratio);
        }
        scroll.x = scroll_target_x - center_x_ratio * (window->SizeFull.x - decoration_total_width);
    }
    if (window->ScrollTarget.y < 3.40282346638528859811704183484516925e+38F)
    {
        float decoration_total_height = window->TitleBarHeight() + window->MenuBarHeight() + window->ScrollbarSizes.y;
        float center_y_ratio = window->ScrollTargetCenterRatio.y;
        float scroll_target_y = window->ScrollTarget.y;
        if (window->ScrollTargetEdgeSnapDist.y > 0.0f)
        {
            float snap_y_min = 0.0f;
            float snap_y_max = window->ScrollMax.y + window->SizeFull.y - decoration_total_height;
            scroll_target_y = CalcScrollEdgeSnap(scroll_target_y, snap_y_min, snap_y_max, window->ScrollTargetEdgeSnapDist.y, center_y_ratio);
        }
        scroll.y = scroll_target_y - center_y_ratio * (window->SizeFull.y - decoration_total_height);
    }
    scroll.x = ((float)(int)(ImMax(scroll.x, 0.0f)));
    scroll.y = ((float)(int)(ImMax(scroll.y, 0.0f)));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, window->ScrollMax.x);
        scroll.y = ImMin(scroll.y, window->ScrollMax.y);
    }
    return scroll;
}

void ImGui::ScrollToItem(ImGuiScrollFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ScrollToRectEx(window, g.LastItemData.NavRect, flags);
}

void ImGui::ScrollToRect(ImGuiWindow* window, const ImRect& item_rect, ImGuiScrollFlags flags)
{
    ScrollToRectEx(window, item_rect, flags);
}


ImVec2 ImGui::ScrollToRectEx(ImGuiWindow* window, const ImRect& item_rect, ImGuiScrollFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImRect window_rect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1));



    
# 9510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskX_)
# 9510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskX_)"
# 9510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9510, __extension__ __PRETTY_FUNCTION__))
# 9510 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
    
# 9511 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9511 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (flags & ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskY_)
# 9511 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9511 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(flags & ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_MaskY_)"
# 9511 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9511, __extension__ __PRETTY_FUNCTION__))
# 9511 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;


    ImGuiScrollFlags in_flags = flags;
    if ((flags & ImGuiScrollFlags_MaskX_) == 0 && window->ScrollbarX)
        flags |= ImGuiScrollFlags_KeepVisibleEdgeX;
    if ((flags & ImGuiScrollFlags_MaskY_) == 0)
        flags |= window->Appearing ? ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeY;

    const bool fully_visible_x = item_rect.Min.x >= window_rect.Min.x && item_rect.Max.x <= window_rect.Max.x;
    const bool fully_visible_y = item_rect.Min.y >= window_rect.Min.y && item_rect.Max.y <= window_rect.Max.y;
    const bool can_be_fully_visible_x = (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0f) <= window_rect.GetWidth();
    const bool can_be_fully_visible_y = (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0f) <= window_rect.GetHeight();

    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeX) && !fully_visible_x)
    {
        if (item_rect.Min.x < window_rect.Min.x || !can_be_fully_visible_x)
            SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window->Pos.x, 0.0f);
        else if (item_rect.Max.x >= window_rect.Max.x)
            SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window->Pos.x, 1.0f);
    }
    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterX) && !fully_visible_x) || (flags & ImGuiScrollFlags_AlwaysCenterX))
    {
        float target_x = can_be_fully_visible_x ? ImFloor((item_rect.Min.x + item_rect.Max.x - window->InnerRect.GetWidth()) * 0.5f) : item_rect.Min.x;
        SetScrollFromPosX(window, target_x - window->Pos.x, 0.0f);
    }

    if ((flags & ImGuiScrollFlags_KeepVisibleEdgeY) && !fully_visible_y)
    {
        if (item_rect.Min.y < window_rect.Min.y || !can_be_fully_visible_y)
            SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window->Pos.y, 0.0f);
        else if (item_rect.Max.y >= window_rect.Max.y)
            SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window->Pos.y, 1.0f);
    }
    else if (((flags & ImGuiScrollFlags_KeepVisibleCenterY) && !fully_visible_y) || (flags & ImGuiScrollFlags_AlwaysCenterY))
    {
        float target_y = can_be_fully_visible_y ? ImFloor((item_rect.Min.y + item_rect.Max.y - window->InnerRect.GetHeight()) * 0.5f) : item_rect.Min.y;
        SetScrollFromPosY(window, target_y - window->Pos.y, 0.0f);
    }

    ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
    ImVec2 delta_scroll = next_scroll - window->Scroll;


    if (!(flags & ImGuiScrollFlags_NoScrollParent) && (window->Flags & ImGuiWindowFlags_ChildWindow))
    {

        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_KeepVisibleCenterX)) != 0)
            in_flags = (in_flags & ~ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_KeepVisibleEdgeX;
        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_KeepVisibleCenterY)) != 0)
            in_flags = (in_flags & ~ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_KeepVisibleEdgeY;
        delta_scroll += ScrollToRectEx(window->ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll), in_flags);
    }

    return delta_scroll;
}

float ImGui::GetScrollX()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Scroll.x;
}

float ImGui::GetScrollY()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ScrollMax.x;
}

float ImGui::GetScrollMaxY()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->ScrollMax.y;
}

void ImGui::SetScrollX(ImGuiWindow* window, float scroll_x)
{
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
    window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

void ImGui::SetScrollY(ImGuiWindow* window, float scroll_y)
{
    window->ScrollTarget.y = scroll_y;
    window->ScrollTargetCenterRatio.y = 0.0f;
    window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

void ImGui::SetScrollX(float scroll_x)
{
    ImGuiContext& g = *GImGui;
    SetScrollX(g.CurrentWindow, scroll_x);
}

void ImGui::SetScrollY(float scroll_y)
{
    ImGuiContext& g = *GImGui;
    SetScrollY(g.CurrentWindow, scroll_y);
}
# 9628 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio)
{
    
# 9630 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9630 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   center_x_ratio >= 0.0f && center_x_ratio <= 1.0f
# 9630 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9630 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "center_x_ratio >= 0.0f && center_x_ratio <= 1.0f"
# 9630 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9630, __extension__ __PRETTY_FUNCTION__))
# 9630 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                              ;
    window->ScrollTarget.x = ((float)(int)(local_x + window->Scroll.x));
    window->ScrollTargetCenterRatio.x = center_x_ratio;
    window->ScrollTargetEdgeSnapDist.x = 0.0f;
}

void ImGui::SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio)
{
    
# 9638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   center_y_ratio >= 0.0f && center_y_ratio <= 1.0f
# 9638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "center_y_ratio >= 0.0f && center_y_ratio <= 1.0f"
# 9638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9638, __extension__ __PRETTY_FUNCTION__))
# 9638 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                              ;
    const float decoration_up_height = window->TitleBarHeight() + window->MenuBarHeight();
    local_y -= decoration_up_height;
    window->ScrollTarget.y = ((float)(int)(local_y + window->Scroll.y));
    window->ScrollTargetCenterRatio.y = center_y_ratio;
    window->ScrollTargetEdgeSnapDist.y = 0.0f;
}

void ImGui::SetScrollFromPosX(float local_x, float center_x_ratio)
{
    ImGuiContext& g = *GImGui;
    SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio);
}

void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)
{
    ImGuiContext& g = *GImGui;
    SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio);
}


void ImGui::SetScrollHereX(float center_x_ratio)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float spacing_x = ImMax(window->WindowPadding.x, g.Style.ItemSpacing.x);
    float target_pos_x = ImLerp(g.LastItemData.Rect.Min.x - spacing_x, g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio);
    SetScrollFromPosX(window, target_pos_x - window->Pos.x, center_x_ratio);


    window->ScrollTargetEdgeSnapDist.x = ImMax(0.0f, window->WindowPadding.x - spacing_x);
}


void ImGui::SetScrollHereY(float center_y_ratio)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    float spacing_y = ImMax(window->WindowPadding.y, g.Style.ItemSpacing.y);
    float target_pos_y = ImLerp(window->DC.CursorPosPrevLine.y - spacing_y, window->DC.CursorPosPrevLine.y + window->DC.PrevLineSize.y + spacing_y, center_y_ratio);
    SetScrollFromPosY(window, target_pos_y - window->Pos.y, center_y_ratio);


    window->ScrollTargetEdgeSnapDist.y = ImMax(0.0f, window->WindowPadding.y - spacing_y);
}





void ImGui::BeginTooltip()
{
    BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
}

void ImGui::BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags)
{
    ImGuiContext& g = *GImGui;

    if (g.DragDropWithinSource || g.DragDropWithinTarget)
    {




        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);

        tooltip_flags |= ImGuiTooltipFlags_OverridePreviousTooltip;
    }

    char window_name[16];
    ImFormatString(window_name, ((int)(sizeof(window_name) / sizeof(*(window_name)))), "##Tooltip_%02d", g.TooltipOverrideCount);
    if (tooltip_flags & ImGuiTooltipFlags_OverridePreviousTooltip)
        if (ImGuiWindow* window = FindWindowByName(window_name))
            if (window->Active)
            {

                window->Hidden = true;
                window->HiddenFramesCanSkipItems = 1;
                ImFormatString(window_name, ((int)(sizeof(window_name) / sizeof(*(window_name)))), "##Tooltip_%02d", ++g.TooltipOverrideCount);
            }
    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize;
    Begin(window_name, 
# 9722 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                      __null
# 9722 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          , flags | extra_window_flags);
}

void ImGui::EndTooltip()
{
    
# 9727 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9727 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip
# 9727 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9727 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip"
# 9727 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9727, __extension__ __PRETTY_FUNCTION__))
# 9727 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                      ;
    End();
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
    BeginTooltipEx(ImGuiTooltipFlags_OverridePreviousTooltip, ImGuiWindowFlags_None);
    TextV(fmt, args);
    EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
    va_list args;
    
# 9741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_start(
# 9741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 9741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 9741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   fmt
# 9741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 9741 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;
    SetTooltipV(fmt, args);
    
# 9743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 9743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 9743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 9743 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
}






bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    if (popup_flags & ImGuiPopupFlags_AnyPopupId)
    {


        
# 9758 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 9758 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       id == 0
# 9758 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 9758 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "id == 0"
# 9758 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9758, __extension__ __PRETTY_FUNCTION__))
# 9758 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         ;
        if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
            return g.OpenPopupStack.Size > 0;
        else
            return g.OpenPopupStack.Size > g.BeginPopupStack.Size;
    }
    else
    {
        if (popup_flags & ImGuiPopupFlags_AnyPopupLevel)
        {

            for (int n = 0; n < g.OpenPopupStack.Size; n++)
                if (g.OpenPopupStack[n].PopupId == id)
                    return true;
            return false;
        }
        else
        {

            return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
        }
    }
}

bool ImGui::IsPopupOpen(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = (popup_flags & ImGuiPopupFlags_AnyPopupId) ? 0 : g.CurrentWindow->GetID(str_id);
    if ((popup_flags & ImGuiPopupFlags_AnyPopupLevel) && id != 0)
        
# 9787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 9787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."
# 9787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 9787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "0 && \"Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel.\""
# 9787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9787, __extension__ __PRETTY_FUNCTION__))
# 9787 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                     ;
    return IsPopupOpen(id, popup_flags);
}

ImGuiWindow* ImGui::GetTopMostPopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & ImGuiWindowFlags_Modal)
                return popup;
    return 
# 9798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 9798 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}

ImGuiWindow* ImGui::GetTopMostAndVisiblePopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if ((popup->Flags & ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup))
                return popup;
    return 
# 9808 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 9808 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}

void ImGui::OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = g.CurrentWindow->GetID(str_id);
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup) ImGui::DebugLog("[popup] OpenPopup(\"%s\" -> 0x%08X\n", str_id, id); } while (0);
    OpenPopupEx(id, popup_flags);
}

void ImGui::OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags)
{
    OpenPopupEx(id, popup_flags);
}





void ImGui::OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;
    const int current_stack_size = g.BeginPopupStack.Size;

    if (popup_flags & ImGuiPopupFlags_NoOpenOverExistingPopup)
        if (IsPopupOpen(0u, ImGuiPopupFlags_AnyPopupId))
            return;

    ImGuiPopupData popup_ref;
    popup_ref.PopupId = id;
    popup_ref.Window = 
# 9840 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                      __null
# 9840 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          ;
    popup_ref.BackupNavWindow = g.NavWindow;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup) ImGui::DebugLog("[popup] OpenPopupEx(0x%08X)\n", id); } while (0);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    }
    else
    {



        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {

            ClosePopupToLevel(current_stack_size, false);
            g.OpenPopupStack.push_back(popup_ref);
        }





    }
}



void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size == 0)
        return;


    int popup_count_to_keep = 0;
    if (ref_window)
    {

        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
        {
            ImGuiPopupData& popup = g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)
                continue;
            
# 9893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 9893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           (popup.Window->Flags & ImGuiWindowFlags_Popup) != 0
# 9893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 9893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "(popup.Window->Flags & ImGuiWindowFlags_Popup) != 0"
# 9893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9893, __extension__ __PRETTY_FUNCTION__))
# 9893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                         ;
            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
                continue;






            bool ref_window_is_descendent_of_popup = false;
            for (int n = popup_count_to_keep; n < g.OpenPopupStack.Size; n++)
                if (ImGuiWindow* popup_window = g.OpenPopupStack[n].Window)
                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
                    {
                        ref_window_is_descendent_of_popup = true;
                        break;
                    }
            if (!ref_window_is_descendent_of_popup)
                break;
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup) ImGui::DebugLog("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window->Name : "<NULL>"); } while (0);
        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
    }
}

void ImGui::ClosePopupsExceptModals()
{
    ImGuiContext& g = *GImGui;

    int popup_count_to_keep;
    for (popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; popup_count_to_keep--)
    {
        ImGuiWindow* window = g.OpenPopupStack[popup_count_to_keep - 1].Window;
        if (!window || window->Flags & ImGuiWindowFlags_Modal)
            break;
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size)
        ClosePopupToLevel(popup_count_to_keep, true);
}

void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
{
    ImGuiContext& g = *GImGui;
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup) ImGui::DebugLog("[popup] ClosePopupToLevel(%d), restore_focus_to_window_under_popup=%d\n", remaining, restore_focus_to_window_under_popup); } while (0);
    
# 9940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 9940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   remaining >= 0 && remaining < g.OpenPopupStack.Size
# 9940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 9940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "remaining >= 0 && remaining < g.OpenPopupStack.Size"
# 9940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 9940, __extension__ __PRETTY_FUNCTION__))
# 9940 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                 ;


    ImGuiWindow* popup_window = g.OpenPopupStack[remaining].Window;
    ImGuiWindow* popup_backup_nav_window = g.OpenPopupStack[remaining].BackupNavWindow;
    g.OpenPopupStack.resize(remaining);

    if (restore_focus_to_window_under_popup)
    {
        ImGuiWindow* focus_window = (popup_window && popup_window->Flags & ImGuiWindowFlags_ChildMenu) ? popup_window->ParentWindow : popup_backup_nav_window;
        if (focus_window && !focus_window->WasActive && popup_window)
        {

            FocusTopMostWindowUnderOne(popup_window, 
# 9953 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                    __null
# 9953 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                        );
        }
        else
        {
            if (g.NavLayer == ImGuiNavLayer_Main && focus_window)
                focus_window = NavRestoreLastChildNavWindow(focus_window);
            FocusWindow(focus_window);
        }
    }
}


void ImGui::CloseCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    int popup_idx = g.BeginPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;


    while (popup_idx > 0)
    {
        ImGuiWindow* popup_window = g.OpenPopupStack[popup_idx].Window;
        ImGuiWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
        bool close_parent = false;
        if (popup_window && (popup_window->Flags & ImGuiWindowFlags_ChildMenu))
            if (parent_popup_window && !(parent_popup_window->Flags & ImGuiWindowFlags_MenuBar))
                close_parent = true;
        if (!close_parent)
            break;
        popup_idx--;
    }
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup) ImGui::DebugLog("[popup] CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx); } while (0);
    ClosePopupToLevel(popup_idx, true);




    if (ImGuiWindow* window = g.NavWindow)
        window->DC.NavHideHighlightOneFrame = true;
}


bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    {
        g.NextWindowData.ClearFlags();
        return false;
    }

    char name[20];
    if (flags & ImGuiWindowFlags_ChildMenu)
        ImFormatString(name, ((int)(sizeof(name) / sizeof(*(name)))), "##Menu_%02d", g.BeginMenuCount);
    else
        ImFormatString(name, ((int)(sizeof(name) / sizeof(*(name)))), "##Popup_%08x", id);

    flags |= ImGuiWindowFlags_Popup;
    bool is_open = Begin(name, 
# 10012 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                              __null
# 10012 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  , flags);
    if (!is_open)
        EndPopup();

    return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size)
    {
        g.NextWindowData.ClearFlags();
        return false;
    }
    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    ImGuiID id = g.CurrentWindow->GetID(str_id);
    return BeginPopupEx(id, flags);
}



bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = window->GetID(name);
    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    {
        g.NextWindowData.ClearFlags();
        return false;
    }




    if ((g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasPos) == 0)
    {
        const ImGuiViewport* viewport = GetMainViewport();
        SetNextWindowPos(viewport->GetCenter(), ImGuiCond_FirstUseEver, ImVec2(0.5f, 0.5f));
    }

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse;
    const bool is_open = Begin(name, p_open, flags);
    if (!is_open || (p_open && !*p_open))
    {
        EndPopup();
        if (is_open)
            ClosePopupToLevel(g.BeginPopupStack.Size, true);
        return false;
    }
    return is_open;
}

void ImGui::EndPopup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    
# 10070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->Flags & ImGuiWindowFlags_Popup
# 10070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->Flags & ImGuiWindowFlags_Popup"
# 10070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10070, __extension__ __PRETTY_FUNCTION__))
# 10070 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                    ;
    
# 10071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.BeginPopupStack.Size > 0
# 10071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.BeginPopupStack.Size > 0"
# 10071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10071, __extension__ __PRETTY_FUNCTION__))
# 10071 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                        ;


    if (g.NavWindow == window)
        NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_LoopY);


    
# 10078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WithinEndChild == false
# 10078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WithinEndChild == false"
# 10078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10078, __extension__ __PRETTY_FUNCTION__))
# 10078 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       ;
    if (window->Flags & ImGuiWindowFlags_ChildWindow)
        g.WithinEndChild = true;
    End();
    g.WithinEndChild = false;
}



void ImGui::OpenPopupOnItemClick(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;
        
# 10095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 10095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       id != 0
# 10095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 10095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "id != 0"
# 10095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10095, __extension__ __PRETTY_FUNCTION__))
# 10095 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                         ;
        OpenPopupEx(id, popup_flags);
    }
}
# 10116 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
bool ImGui::BeginPopupContextItem(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return false;
    ImGuiID id = str_id ? window->GetID(str_id) : g.LastItemData.ID;
    
# 10123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   id != 0
# 10123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "id != 0"
# 10123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10123, __extension__ __PRETTY_FUNCTION__))
# 10123 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id, popup_flags);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!str_id)
        str_id = "window_context";
    ImGuiID id = window->GetID(str_id);
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        if (!(popup_flags & ImGuiPopupFlags_NoOpenOverItems) || !IsAnyItemHovered())
            OpenPopupEx(id, popup_flags);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, ImGuiPopupFlags popup_flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!str_id)
        str_id = "void_context";
    ImGuiID id = window->GetID(str_id);
    int mouse_button = (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
        if (GetTopMostPopupModal() == 
# 10153 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                     __null
# 10153 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                         )
            OpenPopupEx(id, popup_flags);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}






ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
{
    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);




    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir)
                continue;
            ImVec2 pos;
            if (dir == ImGuiDir_Down) pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);
            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y);
            if (dir == ImGuiDir_Left) pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y);
            if (dir == ImGuiDir_Up) pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y);
            if (!r_outer.Contains(ImRect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }



    if (policy == ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy_Default)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir)
                continue;

            const float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
            const float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);


            if (avail_w < size.x && (dir == ImGuiDir_Left || dir == ImGuiDir_Right))
                continue;
            if (avail_h < size.y && (dir == ImGuiDir_Up || dir == ImGuiDir_Down))
                continue;

            ImVec2 pos;
            pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
            pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;


            pos.x = ImMax(pos.x, r_outer.Min.x);
            pos.y = ImMax(pos.y, r_outer.Min.y);

            *last_dir = dir;
            return pos;
        }
    }


    *last_dir = ImGuiDir_None;


    if (policy == ImGuiPopupPositionPolicy_Tooltip)
        return ref_pos + ImVec2(2, 2);


    ImVec2 pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}


ImRect ImGui::GetPopupAllowedExtentRect(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ((void)(window));
    ImRect r_screen = ((ImGuiViewportP*)(void*)GetMainViewport())->GetMainRect();
    ImVec2 padding = g.Style.DisplaySafeAreaPadding;
    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    ImRect r_outer = GetPopupAllowedExtentRect(window);
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    {


        
# 10257 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 10257 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.CurrentWindow == window
# 10257 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 10257 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.CurrentWindow == window"
# 10257 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10257, __extension__ __PRETTY_FUNCTION__))
# 10257 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;
        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2].Window;
        float horizontal_overlap = g.Style.ItemInnerSpacing.x;
        ImRect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = ImRect(-3.40282346638528859811704183484516925e+38F, parent_window->ClipRect.Min.y, 3.40282346638528859811704183484516925e+38F, parent_window->ClipRect.Max.y);
        else
            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -3.40282346638528859811704183484516925e+38F, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, 3.40282346638528859811704183484516925e+38F);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
    }
    if (window->Flags & ImGuiWindowFlags_Popup)
    {
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, ImRect(window->Pos, window->Pos), ImGuiPopupPositionPolicy_Default);
    }
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {

        float sc = g.Style.MouseCursorScale;
        ImVec2 ref_pos = NavCalcPreferredRefPos();
        ImRect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc);
        return FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Tooltip);
    }
    
# 10283 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10283 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   0
# 10283 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10283 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "0"
# 10283 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10283, __extension__ __PRETTY_FUNCTION__))
# 10283 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
    return window->Pos;
}
# 10295 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::SetNavWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.NavWindow != window)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus) ImGui::DebugLog("[focus] SetNavWindow(\"%s\")\n", window ? window->Name : "<NULL>"); } while (0);
        g.NavWindow = window;
    }
    g.NavInitRequest = g.NavMoveSubmitted = g.NavMoveScoringItems = false;
    NavUpdateAnyRequestFlag();
}

void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel)
{
    ImGuiContext& g = *GImGui;
    
# 10310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavWindow != 
# 10310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 10310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavWindow != __null"
# 10310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10310, __extension__ __PRETTY_FUNCTION__))
# 10310 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 ;
    
# 10311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu
# 10311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu"
# 10311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10311, __extension__ __PRETTY_FUNCTION__))
# 10311 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                ;
    g.NavId = id;
    g.NavLayer = nav_layer;
    g.NavFocusScopeId = focus_scope_id;
    g.NavWindow->NavLastIds[nav_layer] = id;
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
}

void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    
# 10322 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10322 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   id != 0
# 10322 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10322 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "id != 0"
# 10322 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10322, __extension__ __PRETTY_FUNCTION__))
# 10322 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;

    if (g.NavWindow != window)
       SetNavWindow(window);



    const ImGuiNavLayer nav_layer = window->DC.NavLayerCurrent;
    g.NavId = id;
    g.NavLayer = nav_layer;
    g.NavFocusScopeId = g.CurrentFocusScopeId;
    window->NavLastIds[nav_layer] = id;
    if (g.LastItemData.ID == id)
        window->NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);

    if (g.ActiveIdSource == ImGuiInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)
{
    if (fabsf(dx) > fabsf(dy))
        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)
{
    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    }
    else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}


static bool ImGui::NavScoreItem(ImGuiNavItemData* result)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;


    ImRect cand = g.LastItemData.NavRect;
    const ImRect curr = g.NavScoringRect;
    g.NavScoringDebugCount++;


    if (window->ParentWindow == g.NavWindow)
    {
        
# 10389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 10389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       (window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened
# 10389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 10389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "(window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened"
# 10389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10389, __extension__ __PRETTY_FUNCTION__))
# 10389 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                      ;
        if (!window->ClipRect.Overlaps(cand))
            return false;
        cand.ClipWithFull(window->ClipRect);
    }



    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);



    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f));
    if (dby != 0.0f && dbx != 0.0f)
        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = fabsf(dbx) + fabsf(dby);


    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = fabsf(dcx) + fabsf(dcy);


    ImGuiDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {

        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    }
    else if (dcx != 0.0f || dcy != 0.0f)
    {

        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    }
    else
    {

        quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    }
# 10461 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    bool new_best = false;
    const ImGuiDir move_dir = g.NavMoveDir;
    if (quadrant == move_dir)
    {

        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {

            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result->DistCenter)
            {



                if (((move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down) ? dby : dbx) < 0.0f)
                    new_best = true;
            }
        }
    }






    if (result->DistBox == 3.40282346638528859811704183484516925e+38F && dist_axial < result->DistAxial)
        if (g.NavLayer == ImGuiNavLayer_Menu && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
            if ((move_dir == ImGuiDir_Left && dax < 0.0f) || (move_dir == ImGuiDir_Right && dax > 0.0f) || (move_dir == ImGuiDir_Up && day < 0.0f) || (move_dir == ImGuiDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

static void ImGui::NavApplyItemToResult(ImGuiNavItemData* result)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    result->Window = window;
    result->ID = g.LastItemData.ID;
    result->FocusScopeId = g.CurrentFocusScopeId;
    result->InFlags = g.LastItemData.InFlags;
    result->RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
}



static void ImGui::NavProcessItem()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = g.LastItemData.ID;
    const ImRect nav_bb = g.LastItemData.NavRect;
    const ImGuiItemFlags item_flags = g.LastItemData.InFlags;


    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent && (item_flags & ImGuiItemFlags_Disabled) == 0)
    {

        const bool candidate_for_nav_default_focus = (item_flags & ImGuiItemFlags_NoNavDefaultFocus) == 0;
        if (candidate_for_nav_default_focus || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = WindowRectAbsToRel(window, nav_bb);
        }
        if (candidate_for_nav_default_focus)
        {
            g.NavInitRequest = false;
            NavUpdateAnyRequestFlag();
        }
    }



    if (g.NavMoveScoringItems)
    {
        const bool is_tab_stop = (item_flags & ImGuiItemFlags_Inputable) && (item_flags & (ImGuiItemFlags_NoTabStop | ImGuiItemFlags_Disabled)) == 0;
        const bool is_tabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) != 0;
        if (is_tabbing)
        {
            if (is_tab_stop || (g.NavMoveFlags & ImGuiNavMoveFlags_FocusApi))
                NavProcessItemForTabbingRequest(id);
        }
        else if ((g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_Disabled))
        {
            ImGuiNavItemData* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
            if (!is_tabbing)
            {
                if (NavScoreItem(result))
                    NavApplyItemToResult(result);


                const float VISIBLE_RATIO = 0.70f;
                if ((g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
                    if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                        if (NavScoreItem(&g.NavMoveResultLocalVisible))
                            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
            }
        }
    }


    if (g.NavId == id)
    {
        if (g.NavWindow != window)
            SetNavWindow(window);
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavFocusScopeId = g.CurrentFocusScopeId;
        g.NavIdIsAlive = true;
        window->NavRectRel[window->DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb);
    }
}
# 10593 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::NavProcessItemForTabbingRequest(ImGuiID id)
{
    ImGuiContext& g = *GImGui;


    ImGuiNavItemData* result = &g.NavMoveResultLocal;
    if (g.NavTabbingDir == +1)
    {

        if (g.NavTabbingResultFirst.ID == 0)
            NavApplyItemToResult(&g.NavTabbingResultFirst);
        if (--g.NavTabbingCounter == 0)
            NavMoveRequestResolveWithLastItem(result);
        else if (g.NavId == id)
            g.NavTabbingCounter = 1;
    }
    else if (g.NavTabbingDir == -1)
    {

        if (g.NavId == id)
        {
            if (result->ID)
            {
                g.NavMoveScoringItems = false;
                NavUpdateAnyRequestFlag();
            }
        }
        else
        {
            NavApplyItemToResult(result);
        }
    }
    else if (g.NavTabbingDir == 0)
    {

        if (g.NavTabbingResultFirst.ID == 0)
            NavMoveRequestResolveWithLastItem(&g.NavTabbingResultFirst);
    }
}

bool ImGui::NavMoveRequestButNoResultYet()
{
    ImGuiContext& g = *GImGui;
    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}


void ImGui::NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
{
    ImGuiContext& g = *GImGui;
    
# 10643 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10643 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavWindow != 
# 10643 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 10643 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavWindow != __null"
# 10643 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10643, __extension__ __PRETTY_FUNCTION__))
# 10643 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 ;

    if (move_flags & ImGuiNavMoveFlags_Tabbing)
        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;

    g.NavMoveSubmitted = g.NavMoveScoringItems = true;
    g.NavMoveDir = move_dir;
    g.NavMoveDirForDebug = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveFlags = move_flags;
    g.NavMoveScrollFlags = scroll_flags;
    g.NavMoveForwardToNextFrame = false;
    g.NavMoveKeyMods = g.IO.KeyMods;
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisible.Clear();
    g.NavMoveResultOther.Clear();
    g.NavTabbingCounter = 0;
    g.NavTabbingResultFirst.Clear();
    NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result)
{
    ImGuiContext& g = *GImGui;
    g.NavMoveScoringItems = false;
    NavApplyItemToResult(result);
    NavUpdateAnyRequestFlag();
}

void ImGui::NavMoveRequestCancel()
{
    ImGuiContext& g = *GImGui;
    g.NavMoveSubmitted = g.NavMoveScoringItems = false;
    NavUpdateAnyRequestFlag();
}


void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags)
{
    ImGuiContext& g = *GImGui;
    
# 10683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavMoveForwardToNextFrame == false
# 10683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavMoveForwardToNextFrame == false"
# 10683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10683, __extension__ __PRETTY_FUNCTION__))
# 10683 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  ;
    NavMoveRequestCancel();
    g.NavMoveForwardToNextFrame = true;
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_Forwarded;
    g.NavMoveScrollFlags = scroll_flags;
}



void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags wrap_flags)
{
    ImGuiContext& g = *GImGui;
    
# 10697 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10697 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   wrap_flags != 0
# 10697 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10697 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "wrap_flags != 0"
# 10697 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10697, __extension__ __PRETTY_FUNCTION__))
# 10697 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             ;

    if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main)
        g.NavMoveFlags |= wrap_flags;
}



static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)
{
    ImGuiWindow* parent = nav_window;
    while (parent && parent->RootWindow != parent && (parent->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        parent = parent->ParentWindow;
    if (parent && parent != nav_window)
        parent->NavLastChildNavWindow = nav_window;
}



static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
    if (window->NavLastChildNavWindow && window->NavLastChildNavWindow->WasActive)
        return window->NavLastChildNavWindow;
    return window;
}

void ImGui::NavRestoreLayer(ImGuiNavLayer layer)
{
    ImGuiContext& g = *GImGui;
    if (layer == ImGuiNavLayer_Main)
    {
        ImGuiWindow* prev_nav_window = g.NavWindow;
        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);
        if (prev_nav_window)
            do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus) ImGui::DebugLog("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window->Name, g.NavWindow->Name); } while (0);
    }
    ImGuiWindow* window = g.NavWindow;
    if (window->NavLastIds[layer] != 0)
    {
        SetNavID(window->NavLastIds[layer], layer, 0, window->NavRectRel[layer]);
    }
    else
    {
        g.NavLayer = layer;
        NavInitWindow(window, true);
    }
}

void ImGui::NavRestoreHighlightAfterMove()
{
    ImGuiContext& g = *GImGui;
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = g.NavMousePosDirty = true;
}

static inline void ImGui::NavUpdateAnyRequestFlag()
{
    ImGuiContext& g = *GImGui;
    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (0 && g.NavWindow != 
# 10755 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                             __null
# 10755 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                 );
    if (g.NavAnyRequest)
        
# 10757 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 10757 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.NavWindow != 
# 10757 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       __null) ? void (0) : __assert_fail (
# 10757 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.NavWindow != __null"
# 10757 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10757, __extension__ __PRETTY_FUNCTION__))
# 10757 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                     ;
}


void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
    ImGuiContext& g = *GImGui;
    
# 10764 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10764 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window == g.NavWindow
# 10764 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10764 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window == g.NavWindow"
# 10764 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10764, __extension__ __PRETTY_FUNCTION__))
# 10764 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;

    if (window->Flags & ImGuiWindowFlags_NoNavInputs)
    {
        g.NavId = 0;
        g.NavFocusScopeId = window->NavRootFocusScopeId;
        return;
    }

    bool init_for_nav = false;
    if (window == window->RootWindow || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
        init_for_nav = true;
    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) ImGui::DebugLog("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window->Name, g.NavLayer); } while (0);
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer, window->NavRootFocusScopeId, ImRect());
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = ImRect();
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window->NavLastIds[0];
        g.NavFocusScopeId = window->NavRootFocusScopeId;
    }
}

static ImVec2 ImGui::NavCalcPreferredRefPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.NavWindow;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !window)
    {



        ImVec2 p = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos;
        return ImVec2(p.x + 1.0f, p.y);
    }
    else
    {


        ImRect rect_rel = WindowRectRelToAbs(window, window->NavRectRel[g.NavLayer]);
        if (window->LastFrameActive != g.FrameCount && (window->ScrollTarget.x != 3.40282346638528859811704183484516925e+38F || window->ScrollTarget.y != 3.40282346638528859811704183484516925e+38F))
        {
            ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
            rect_rel.Translate(window->Scroll - next_scroll);
        }
        ImVec2 pos = ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
        ImGuiViewport* viewport = GetMainViewport();
        return ImFloor(ImClamp(pos, viewport->Pos, viewport->Pos + viewport->Size));
    }
}

float ImGui::GetNavTweakPressedAmount(ImGuiAxis axis)
{
    ImGuiContext& g = *GImGui;
    float repeat_delay, repeat_rate;
    GetTypematicRepeatRate(ImGuiInputFlags_RepeatRateNavTweak, &repeat_delay, &repeat_rate);

    ImGuiKey key_less, key_more;
    if (g.NavInputSource == ImGuiInputSource_Gamepad)
    {
        key_less = (axis == ImGuiAxis_X) ? ImGuiKey_GamepadDpadLeft : ImGuiKey_GamepadDpadUp;
        key_more = (axis == ImGuiAxis_X) ? ImGuiKey_GamepadDpadRight : ImGuiKey_GamepadDpadDown;
    }
    else
    {
        key_less = (axis == ImGuiAxis_X) ? ImGuiKey_LeftArrow : ImGuiKey_UpArrow;
        key_more = (axis == ImGuiAxis_X) ? ImGuiKey_RightArrow : ImGuiKey_DownArrow;
    }
    float amount = (float)GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - (float)GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
    if (amount != 0.0f && IsKeyDown(key_less) && IsKeyDown(key_more))
        amount = 0.0f;
    return amount;
}

static void ImGui::NavUpdate()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;

    io.WantSetMousePos = false;




    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    const ImGuiKey nav_gamepad_keys_to_change_source[] = { ImGuiKey_GamepadFaceRight, ImGuiKey_GamepadFaceLeft, ImGuiKey_GamepadFaceUp, ImGuiKey_GamepadFaceDown, ImGuiKey_GamepadDpadRight, ImGuiKey_GamepadDpadLeft, ImGuiKey_GamepadDpadUp, ImGuiKey_GamepadDpadDown };
    if (nav_gamepad_active)
        for (ImGuiKey key : nav_gamepad_keys_to_change_source)
            if (IsKeyDown(key))
                g.NavInputSource = ImGuiInputSource_Gamepad;
    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    const ImGuiKey nav_keyboard_keys_to_change_source[] = { ImGuiKey_Space, ImGuiKey_Enter, ImGuiKey_Escape, ImGuiKey_RightArrow, ImGuiKey_LeftArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow };
    if (nav_keyboard_active)
        for (ImGuiKey key : nav_keyboard_keys_to_change_source)
            if (IsKeyDown(key))
                g.NavInputSource = ImGuiInputSource_Keyboard;


    if (g.NavInitResultId != 0)
        NavInitRequestApplyResult();
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;


    if (g.NavMoveSubmitted)
        NavMoveRequestApplyResult();
    g.NavTabbingCounter = 0;
    g.NavMoveSubmitted = g.NavMoveScoringItems = false;


    bool set_mouse_pos = false;
    if (g.NavMousePosDirty && g.NavIdIsAlive)
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            set_mouse_pos = true;
    g.NavMousePosDirty = false;
    
# 10887 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 10887 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu
# 10887 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 10887 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu"
# 10887 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10887, __extension__ __PRETTY_FUNCTION__))
# 10887 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                  ;


    if (g.NavWindow)
        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != 
# 10892 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                            __null 
# 10892 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                 && g.NavLayer == ImGuiNavLayer_Main)
        g.NavWindow->NavLastChildNavWindow = 
# 10893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                            __null
# 10893 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                ;


    NavUpdateWindowing();


    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    io.NavVisible = (io.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != 
# 10900 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                        __null
# 10900 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                            );


    NavUpdateCancelRequest();


    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavActivateInputId = 0;
    g.NavActivateFlags = ImGuiActivateFlags_None;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
    {
        const bool activate_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Space)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_GamepadFaceDown));
        const bool activate_pressed = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Space, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadFaceDown, false)));
        const bool input_down = (nav_keyboard_active && IsKeyDown(ImGuiKey_Enter)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_GamepadFaceUp));
        const bool input_pressed = input_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey_Enter, false)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadFaceUp, false)));
        if (g.ActiveId == 0 && activate_pressed)
        {
            g.NavActivateId = g.NavId;
            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
        }
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
        {
            g.NavActivateInputId = g.NavId;
            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
        }
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        
# 10932 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 10932 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.NavActivateDownId == g.NavActivateId
# 10932 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 10932 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.NavActivateDownId == g.NavActivateId"
# 10932 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 10932, __extension__ __PRETTY_FUNCTION__))
# 10932 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                        ;



    if (g.NavNextActivateId != 0)
    {
        if (g.NavNextActivateFlags & ImGuiActivateFlags_PreferInput)
            g.NavActivateInputId = g.NavNextActivateId;
        else
            g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavNextActivateId;
        g.NavActivateFlags = g.NavNextActivateFlags;
    }
    g.NavNextActivateId = 0;


    NavUpdateCreateMoveRequest();
    if (g.NavMoveDir == ImGuiDir_None)
        NavUpdateCreateTabbingRequest();
    NavUpdateAnyRequestFlag();
    g.NavIdIsAlive = false;


    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {

        ImGuiWindow* window = g.NavWindow;
        const float scroll_speed = ((float)(int)((window->CalcFontSize() * 100 * io.DeltaTime) + 0.5f));
        const ImGuiDir move_dir = g.NavMoveDir;
        if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll && move_dir != ImGuiDir_None)
        {
            if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
                SetScrollX(window, ImFloor(window->Scroll.x + ((move_dir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (move_dir == ImGuiDir_Up || move_dir == ImGuiDir_Down)
                SetScrollY(window, ImFloor(window->Scroll.y + ((move_dir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }



        if (nav_gamepad_active)
        {
            const ImVec2 scroll_dir = GetKeyVector2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
            const float tweak_factor = IsKeyDown(ImGuiKey_GamepadL1) ? 1.0f / 10.0f : IsKeyDown(ImGuiKey_GamepadR1) ? 10.0f : 1.0f;
            if (scroll_dir.x != 0.0f && window->ScrollbarX)
                SetScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
            if (scroll_dir.y != 0.0f)
                SetScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
        }
    }


    if (!nav_keyboard_active && !nav_gamepad_active)
    {
        g.NavDisableHighlight = true;
        g.NavDisableMouseHover = set_mouse_pos = false;
    }



    if (set_mouse_pos && (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
    {
        io.MousePos = io.MousePosPrev = NavCalcPreferredRefPos();
        io.WantSetMousePos = true;

    }


    g.NavScoringDebugCount = 0;
# 11007 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
}

void ImGui::NavInitRequestApplyResult()
{

    ImGuiContext& g = *GImGui;
    if (!g.NavWindow)
        return;



    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) ImGui::DebugLog("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", g.NavInitResultId, g.NavLayer, g.NavWindow->Name); } while (0);
    SetNavID(g.NavInitResultId, g.NavLayer, 0, g.NavInitResultRectRel);
    g.NavIdIsAlive = true;
    if (g.NavInitRequestFromMove)
        NavRestoreHighlightAfterMove();
}

void ImGui::NavUpdateCreateMoveRequest()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;
    ImGuiWindow* window = g.NavWindow;
    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;

    if (g.NavMoveForwardToNextFrame && window != 
# 11033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                __null
# 11033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                    )
    {


        
# 11037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 11037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None
# 11037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 11037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None"
# 11037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11037, __extension__ __PRETTY_FUNCTION__))
# 11037 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                    ;
        
# 11038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 11038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded
# 11038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 11038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded"
# 11038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11038, __extension__ __PRETTY_FUNCTION__))
# 11038 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                              ;
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) ImGui::DebugLog("[nav] NavMoveRequestForward %d\n", g.NavMoveDir); } while (0);
    }
    else
    {

        g.NavMoveDir = ImGuiDir_None;
        g.NavMoveFlags = ImGuiNavMoveFlags_None;
        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
        if (window && !g.NavWindowingTarget && !(window->Flags & ImGuiWindowFlags_NoNavInputs))
        {
            const ImGuiInputFlags repeat_mode = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateNavMove;
            if (!IsActiveIdUsingNavDir(ImGuiDir_Left) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadLeft, ((ImGuiID)-1), repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_LeftArrow, ((ImGuiID)-1), repeat_mode)))) { g.NavMoveDir = ImGuiDir_Left; }
            if (!IsActiveIdUsingNavDir(ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadRight, ((ImGuiID)-1), repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_RightArrow, ((ImGuiID)-1), repeat_mode)))) { g.NavMoveDir = ImGuiDir_Right; }
            if (!IsActiveIdUsingNavDir(ImGuiDir_Up) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadUp, ((ImGuiID)-1), repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_UpArrow, ((ImGuiID)-1), repeat_mode)))) { g.NavMoveDir = ImGuiDir_Up; }
            if (!IsActiveIdUsingNavDir(ImGuiDir_Down) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadDpadDown, ((ImGuiID)-1), repeat_mode)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey_DownArrow, ((ImGuiID)-1), repeat_mode)))) { g.NavMoveDir = ImGuiDir_Down; }
        }
        g.NavMoveClipDir = g.NavMoveDir;
        g.NavScoringNoClipRect = ImRect(+3.40282346638528859811704183484516925e+38F, +3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    }



    float scoring_rect_offset_y = 0.0f;
    if (window && g.NavMoveDir == ImGuiDir_None && nav_keyboard_active)
        scoring_rect_offset_y = NavUpdatePageUpPageDown();
    if (scoring_rect_offset_y != 0.0f)
    {
        g.NavScoringNoClipRect = window->InnerRect;
        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
    }
# 11082 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    g.NavMoveForwardToNextFrame = false;
    if (g.NavMoveDir != ImGuiDir_None)
        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);


    if (g.NavMoveSubmitted && g.NavId == 0)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) ImGui::DebugLog("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window->Name : "<NULL>", g.NavLayer); } while (0);
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        g.NavInitResultId = 0;
        g.NavDisableHighlight = false;
    }




    if (g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != 
# 11098 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                           __null
# 11098 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                               )
    {
        bool clamp_x = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
        bool clamp_y = (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
        ImRect inner_rect_rel = WindowRectAbsToRel(window, ImRect(window->InnerRect.Min - ImVec2(1, 1), window->InnerRect.Max + ImVec2(1, 1)));
        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {

            float pad_x = ImMin(inner_rect_rel.GetWidth(), window->CalcFontSize() * 0.5f);
            float pad_y = ImMin(inner_rect_rel.GetHeight(), window->CalcFontSize() * 0.5f);
            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -3.40282346638528859811704183484516925e+38F;
            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +3.40282346638528859811704183484516925e+38F;
            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -3.40282346638528859811704183484516925e+38F;
            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +3.40282346638528859811704183484516925e+38F;
            window->NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
            g.NavId = 0;
        }
    }


    ImRect scoring_rect;
    if (window != 
# 11119 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                 __null
# 11119 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     )
    {
        ImRect nav_rect_rel = !window->NavRectRel[g.NavLayer].IsInverted() ? window->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
        scoring_rect.TranslateY(scoring_rect_offset_y);
        scoring_rect.Min.x = ImMin(scoring_rect.Min.x + 1.0f, scoring_rect.Max.x);
        scoring_rect.Max.x = scoring_rect.Min.x;
        
# 11126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 11126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       !scoring_rect.IsInverted()
# 11126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 11126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "!scoring_rect.IsInverted()"
# 11126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11126, __extension__ __PRETTY_FUNCTION__))
# 11126 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            ;


    }
    g.NavScoringRect = scoring_rect;
    g.NavScoringNoClipRect.Add(scoring_rect);
}

void ImGui::NavUpdateCreateTabbingRequest()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.NavWindow;
    
# 11138 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11138 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavMoveDir == ImGuiDir_None
# 11138 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11138 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavMoveDir == ImGuiDir_None"
# 11138 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11138, __extension__ __PRETTY_FUNCTION__))
# 11138 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;
    if (window == 
# 11139 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                 __null 
# 11139 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      || g.NavWindowingTarget != 
# 11139 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                 __null 
# 11139 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      || (window->Flags & ImGuiWindowFlags_NoNavInputs))
        return;

    const bool tab_pressed = IsKeyPressed(ImGuiKey_Tab, ((ImGuiID)-1), ImGuiInputFlags_Repeat) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
    if (!tab_pressed)
        return;






    g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
    ImGuiScrollFlags scroll_flags = window->Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    ImGuiDir clip_dir = (g.NavTabbingDir < 0) ? ImGuiDir_Up : ImGuiDir_Down;
    NavMoveRequestSubmit(ImGuiDir_None, clip_dir, ImGuiNavMoveFlags_Tabbing, scroll_flags);
    g.NavTabbingCounter = -1;
}


void ImGui::NavMoveRequestApplyResult()
{
    ImGuiContext& g = *GImGui;






    ImGuiNavItemData* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : 
# 11168 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                                                __null
# 11168 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                                                    ;


    if (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing)
        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID)
            result = &g.NavTabbingResultFirst;


    if (result == 
# 11176 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                 __null
# 11176 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     )
    {
        if (g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing)
            g.NavMoveFlags |= ImGuiNavMoveFlags_DontSetNavHighlight;
        if (g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_DontSetNavHighlight) == 0)
            NavRestoreHighlightAfterMove();
        return;
    }


    if (g.NavMoveFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId)
            result = &g.NavMoveResultLocalVisible;


    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
            result = &g.NavMoveResultOther;
    
# 11194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavWindow && result->Window
# 11194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavWindow && result->Window"
# 11194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11194, __extension__ __PRETTY_FUNCTION__))
# 11194 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;


    if (g.NavLayer == ImGuiNavLayer_Main)
    {
        if (g.NavMoveFlags & ImGuiNavMoveFlags_ScrollToEdgeY)
        {

            float scroll_target = (g.NavMoveDir == ImGuiDir_Up) ? result->Window->ScrollMax.y : 0.0f;
            SetScrollY(result->Window, scroll_target);
        }
        else
        {
            ImRect rect_abs = WindowRectRelToAbs(result->Window, result->RectRel);
            ScrollToRectEx(result->Window, rect_abs, g.NavMoveScrollFlags);
        }
    }

    if (g.NavWindow != result->Window)
    {
        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus) ImGui::DebugLog("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result->Window->Name); } while (0);
        g.NavWindow = result->Window;
    }
    if (g.ActiveId != result->ID)
        ClearActiveID();
    if (g.NavId != result->ID)
    {

        g.NavJustMovedToId = result->ID;
        g.NavJustMovedToFocusScopeId = result->FocusScopeId;
        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
    }


    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) ImGui::DebugLog("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result->ID, g.NavLayer, g.NavWindow->Name); } while (0);
    SetNavID(result->ID, g.NavLayer, result->FocusScopeId, result->RectRel);


    if ((g.NavMoveFlags & ImGuiNavMoveFlags_Tabbing) && (result->InFlags & ImGuiItemFlags_Inputable))
    {
        g.NavNextActivateId = result->ID;
        g.NavNextActivateFlags = ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState;
        g.NavMoveFlags |= ImGuiNavMoveFlags_DontSetNavHighlight;
    }


    if (g.NavMoveFlags & ImGuiNavMoveFlags_Activate)
    {
        g.NavNextActivateId = result->ID;
        g.NavNextActivateFlags = ImGuiActivateFlags_None;
    }


    if ((g.NavMoveFlags & ImGuiNavMoveFlags_DontSetNavHighlight) == 0)
        NavRestoreHighlightAfterMove();
}





static void ImGui::NavUpdateCancelRequest()
{
    ImGuiContext& g = *GImGui;
    const bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    const bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey_Escape, ((ImGuiID)-1))) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_GamepadFaceRight, ((ImGuiID)-1))))
        return;

    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav) ImGui::DebugLog("[nav] NavUpdateCancelRequest()\n"); } while (0);
    if (g.ActiveId != 0)
    {
        ClearActiveID();
    }
    else if (g.NavLayer != ImGuiNavLayer_Main)
    {

        NavRestoreLayer(ImGuiNavLayer_Main);
        NavRestoreHighlightAfterMove();
    }
    else if (g.NavWindow && g.NavWindow != g.NavWindow->RootWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
    {

        ImGuiWindow* child_window = g.NavWindow;
        ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
        
# 11279 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 11279 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       child_window->ChildId != 0
# 11279 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 11279 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "child_window->ChildId != 0"
# 11279 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11279, __extension__ __PRETTY_FUNCTION__))
# 11279 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            ;
        ImRect child_rect = child_window->Rect();
        FocusWindow(parent_window);
        SetNavID(child_window->ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_rect));
        NavRestoreHighlightAfterMove();
    }
    else if (g.OpenPopupStack.Size > 0 && g.OpenPopupStack.back().Window != 
# 11285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                           __null 
# 11285 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                && !(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
    {

        ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
    }
    else
    {

        if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
            g.NavWindow->NavLastIds[0] = 0;
        g.NavId = 0;
    }
}





static float ImGui::NavUpdatePageUpPageDown()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.NavWindow;
    if ((window->Flags & ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != 
# 11307 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                 __null
# 11307 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                     )
        return 0.0f;

    const bool page_up_held = IsKeyDown(ImGuiKey_PageUp, ((ImGuiID)-1));
    const bool page_down_held = IsKeyDown(ImGuiKey_PageDown, ((ImGuiID)-1));
    const bool home_pressed = IsKeyPressed(ImGuiKey_Home, ((ImGuiID)-1), ImGuiInputFlags_Repeat);
    const bool end_pressed = IsKeyPressed(ImGuiKey_End, ((ImGuiID)-1), ImGuiInputFlags_Repeat);
    if (page_up_held == page_down_held && home_pressed == end_pressed)
        return 0.0f;

    if (g.NavLayer != ImGuiNavLayer_Main)
        NavRestoreLayer(ImGuiNavLayer_Main);

    if (window->DC.NavLayersActiveMask == 0x00 && window->DC.NavHasScroll)
    {

        if (IsKeyPressed(ImGuiKey_PageUp, ((ImGuiID)-1), ImGuiInputFlags_Repeat))
            SetScrollY(window, window->Scroll.y - window->InnerRect.GetHeight());
        else if (IsKeyPressed(ImGuiKey_PageDown, ((ImGuiID)-1), ImGuiInputFlags_Repeat))
            SetScrollY(window, window->Scroll.y + window->InnerRect.GetHeight());
        else if (home_pressed)
            SetScrollY(window, 0.0f);
        else if (end_pressed)
            SetScrollY(window, window->ScrollMax.y);
    }
    else
    {
        ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
        const float page_offset_y = ImMax(0.0f, window->InnerRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
        float nav_scoring_rect_offset_y = 0.0f;
        if (IsKeyPressed(ImGuiKey_PageUp, true))
        {
            nav_scoring_rect_offset_y = -page_offset_y;
            g.NavMoveDir = ImGuiDir_Down;
            g.NavMoveClipDir = ImGuiDir_Up;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
        }
        else if (IsKeyPressed(ImGuiKey_PageDown, true))
        {
            nav_scoring_rect_offset_y = +page_offset_y;
            g.NavMoveDir = ImGuiDir_Up;
            g.NavMoveClipDir = ImGuiDir_Down;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
        }
        else if (home_pressed)
        {



            nav_rect_rel.Min.y = nav_rect_rel.Max.y = 0.0f;
            if (nav_rect_rel.IsInverted())
                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
            g.NavMoveDir = ImGuiDir_Down;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;

        }
        else if (end_pressed)
        {
            nav_rect_rel.Min.y = nav_rect_rel.Max.y = window->ContentSize.y;
            if (nav_rect_rel.IsInverted())
                nav_rect_rel.Min.x = nav_rect_rel.Max.x = 0.0f;
            g.NavMoveDir = ImGuiDir_Up;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;

        }
        return nav_scoring_rect_offset_y;
    }
    return 0.0f;
}

static void ImGui::NavEndFrame()
{
    ImGuiContext& g = *GImGui;


    if (g.NavWindowingTarget != 
# 11382 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                               __null
# 11382 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   )
        NavUpdateWindowingOverlay();




    const ImGuiNavMoveFlags wanted_flags = ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY;
    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & wanted_flags) && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded) == 0)
        NavUpdateCreateWrappingRequest();
}

static void ImGui::NavUpdateCreateWrappingRequest()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.NavWindow;

    bool do_forward = false;
    ImRect bb_rel = window->NavRectRel[g.NavLayer];
    ImGuiDir clip_dir = g.NavMoveDir;
    const ImGuiNavMoveFlags move_flags = g.NavMoveFlags;
    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = window->ContentSize.x + window->WindowPadding.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX)
        {
            bb_rel.TranslateY(-bb_rel.GetHeight());
            clip_dir = ImGuiDir_Up;
        }
        do_forward = true;
    }
    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = -window->WindowPadding.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX)
        {
            bb_rel.TranslateY(+bb_rel.GetHeight());
            clip_dir = ImGuiDir_Down;
        }
        do_forward = true;
    }
    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = window->ContentSize.y + window->WindowPadding.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY)
        {
            bb_rel.TranslateX(-bb_rel.GetWidth());
            clip_dir = ImGuiDir_Left;
        }
        do_forward = true;
    }
    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = -window->WindowPadding.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY)
        {
            bb_rel.TranslateX(+bb_rel.GetWidth());
            clip_dir = ImGuiDir_Right;
        }
        do_forward = true;
    }
    if (!do_forward)
        return;
    window->NavRectRel[g.NavLayer] = bb_rel;
    NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags, g.NavMoveScrollFlags);
}

static int ImGui::FindWindowFocusIndex(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ((void)(g));
    int order = window->FocusOrder;
    
# 11453 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11453 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   window->RootWindow == window
# 11453 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11453 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "window->RootWindow == window"
# 11453 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11453, __extension__ __PRETTY_FUNCTION__))
# 11453 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          ;
    
# 11454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.WindowsFocusOrder[order] == window
# 11454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.WindowsFocusOrder[order] == window"
# 11454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11454, __extension__ __PRETTY_FUNCTION__))
# 11454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  ;
    return order;
}

static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir)
{
    ImGuiContext& g = *GImGui;
    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
        if (ImGui::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
            return g.WindowsFocusOrder[i];
    return 
# 11464 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 11464 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    ImGuiContext& g = *GImGui;
    
# 11470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavWindowingTarget
# 11470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavWindowingTarget"
# 11470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11470, __extension__ __PRETTY_FUNCTION__))
# 11470 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  ;
    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
        return;

    const int i_current = ImGui::FindWindowFocusIndex(g.NavWindowingTarget);
    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -0x7fffffff, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target)
    {
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
        g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
    }
    g.NavWindowingToggleLayer = false;
}




static void ImGui::NavUpdateWindowing()
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;

    ImGuiWindow* apply_focus_window = 
# 11494 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                     __null
# 11494 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                         ;
    bool apply_toggle_layer = false;

    ImGuiWindow* modal_window = GetTopMostPopupModal();
    bool allow_windowing = (modal_window == 
# 11498 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                           __null
# 11498 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                               );
    if (!allow_windowing)
        g.NavWindowingTarget = 
# 11500 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                              __null
# 11500 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  ;


    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == 
# 11503 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                           __null
# 11503 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                               )
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = 
# 11507 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                      __null
# 11507 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          ;
    }


    const bool nav_gamepad_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
    const bool nav_keyboard_active = (io.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    const bool keyboard_next_window = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ((ImGuiID)-1), ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
    const bool keyboard_prev_window = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ((ImGuiID)-1), ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways);
    const bool start_windowing_with_gamepad = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_GamepadFaceLeft, 0, ImGuiInputFlags_None);
    const bool start_windowing_with_keyboard = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -0x7fffffff, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window->RootWindow;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize = ImVec2(0.0f, 0.0f);
            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false;
            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_Keyboard : ImGuiInputSource_Gamepad;
        }


    g.NavWindowingTimer += io.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Gamepad)
    {

        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));


        const int focus_change_dir = (int)IsKeyPressed(ImGuiKey_GamepadL1) - (int)IsKeyPressed(ImGuiKey_GamepadR1);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }


        if (!IsKeyDown(ImGuiKey_GamepadFaceLeft))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f);
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = 
# 11550 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                  __null
# 11550 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                      ;
        }
    }


    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_Keyboard)
    {

        ImGuiKeyChord shared_mods = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiMod_Mask_)) & ImGuiMod_Mask_;
        
# 11559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 11559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       shared_mods != 0
# 11559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 11559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "shared_mods != 0"
# 11559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11559, __extension__ __PRETTY_FUNCTION__))
# 11559 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  ;
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));
        if (keyboard_next_window || keyboard_prev_window)
            NavUpdateWindowingHighlightWindow(keyboard_next_window ? -1 : +1);
        else if ((io.KeyMods & shared_mods) != shared_mods)
            apply_focus_window = g.NavWindowingTarget;
    }




    if (nav_keyboard_active && IsKeyPressed(ImGuiMod_Alt, ((ImGuiID)-1)))
    {
        g.NavWindowingToggleLayer = true;
        g.NavInputSource = ImGuiInputSource_Keyboard;
    }
    if (g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource_Keyboard)
    {



        if (io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper || TestKeyOwner(ImGuiMod_Alt, ((ImGuiID)-1)) == false)
            g.NavWindowingToggleLayer = false;



        if (IsKeyReleased(ImGuiMod_Alt) && g.NavWindowingToggleLayer)
            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap)
                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))
                    apply_toggle_layer = true;
        if (!IsKeyDown(ImGuiMod_Alt))
            g.NavWindowingToggleLayer = false;
    }


    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
    {
        ImVec2 nav_move_dir;
        if (g.NavInputSource == ImGuiInputSource_Keyboard && !io.KeyShift)
            nav_move_dir = GetKeyVector2d(ImGuiKey_LeftArrow, ImGuiKey_RightArrow, ImGuiKey_UpArrow, ImGuiKey_DownArrow);
        if (g.NavInputSource == ImGuiInputSource_Gamepad)
            nav_move_dir = GetKeyVector2d(ImGuiKey_GamepadLStickLeft, ImGuiKey_GamepadLStickRight, ImGuiKey_GamepadLStickUp, ImGuiKey_GamepadLStickDown);
        if (nav_move_dir.x != 0.0f || nav_move_dir.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_step = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
            g.NavDisableMouseHover = true;
            ImVec2 accum_floored = ImFloor(g.NavWindowingAccumDeltaPos);
            if (accum_floored.x != 0.0f || accum_floored.y != 0.0f)
            {
                ImGuiWindow* moving_window = g.NavWindowingTarget->RootWindow;
                SetWindowPos(moving_window, moving_window->Pos + accum_floored, ImGuiCond_Always);
                g.NavWindowingAccumDeltaPos -= accum_floored;
            }
        }
    }


    if (apply_focus_window && (g.NavWindow == 
# 11618 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                             __null 
# 11618 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                  || apply_focus_window != g.NavWindow->RootWindow))
    {
        ClearActiveID();
        NavRestoreHighlightAfterMove();
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window, false);
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);
# 11635 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
        if (apply_focus_window->DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu))
            g.NavLayer = ImGuiNavLayer_Menu;
    }
    if (apply_focus_window)
        g.NavWindowingTarget = 
# 11639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                              __null
# 11639 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                  ;


    if (apply_toggle_layer && g.NavWindow)
    {
        ClearActiveID();


        ImGuiWindow* new_nav_window = g.NavWindow;
        while (new_nav_window->ParentWindow
            && (new_nav_window->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0
            && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0
            && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;
        if (new_nav_window != g.NavWindow)
        {
            ImGuiWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }


        const ImGuiNavLayer new_nav_layer = (g.NavWindow->DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? (ImGuiNavLayer)((int)g.NavLayer ^ 1) : ImGuiNavLayer_Main;
        if (new_nav_layer != g.NavLayer)
        {

            if (new_nav_layer == ImGuiNavLayer_Menu)
                g.NavWindow->NavLastIds[new_nav_layer] = 0;
            NavRestoreLayer(new_nav_layer);
            NavRestoreHighlightAfterMove();
        }
    }
}


static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
{
    if (window->Flags & ImGuiWindowFlags_Popup)
        return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingPopup);
    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingMainMenuBar);
    return ImGui::LocalizeGetMsg(ImGuiLocKey_WindowingUntitled);
}


void ImGui::NavUpdateWindowingOverlay()
{
    ImGuiContext& g = *GImGui;
    
# 11687 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11687 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.NavWindowingTarget != 
# 11687 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 11687 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.NavWindowingTarget != __null"
# 11687 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11687, __extension__ __PRETTY_FUNCTION__))
# 11687 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          ;

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingListWindow == 
# 11692 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                   __null
# 11692 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       )
        g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
    const ImGuiViewport* viewport = GetMainViewport();
    SetNextWindowSizeConstraints(ImVec2(viewport->Size.x * 0.20f, viewport->Size.y * 0.20f), ImVec2(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F));
    SetNextWindowPos(viewport->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin("###NavWindowingList", 
# 11698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                __null
# 11698 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    , ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    {
        ImGuiWindow* window = g.WindowsFocusOrder[n];
        
# 11702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 11702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       window != 
# 11702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       __null) ? void (0) : __assert_fail (
# 11702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "window != __null"
# 11702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11702, __extension__ __PRETTY_FUNCTION__))
# 11702 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                ;
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}






bool ImGui::IsDragDropActive()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive;
}

void ImGui::ClearDragDrop()
{
    ImGuiContext& g = *GImGui;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = 3.40282346638528859811704183484516925e+38F;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}
# 11746 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;



    ImGuiMouseButton mouse_button = ImGuiMouseButton_Left;

    bool source_drag_active = false;
    ImGuiID source_id = 0;
    ImGuiID source_parent_id = 0;
    if (!(flags & ImGuiDragDropFlags_SourceExtern))
    {
        source_id = g.LastItemData.ID;
        if (source_id != 0)
        {

            if (g.ActiveId != source_id)
                return false;
            if (g.ActiveIdMouseButton != -1)
                mouse_button = g.ActiveIdMouseButton;
            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
                return false;
            g.ActiveIdAllowOverlap = false;
        }
        else
        {

            if (g.IO.MouseDown[mouse_button] == false || window->SkipItems)
                return false;
            if ((g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;



            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
            {
                
# 11784 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               (static_cast <bool> (
# 11784 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               0
# 11784 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               ) ? void (0) : __assert_fail (
# 11784 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               "0"
# 11784 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11784, __extension__ __PRETTY_FUNCTION__))
# 11784 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;
                return false;
            }






            source_id = g.LastItemData.ID = window->GetIDFromRectangle(g.LastItemData.Rect);
            KeepAliveID(source_id);
            bool is_hovered = ItemHoverable(g.LastItemData.Rect, source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id)
                g.ActiveIdAllowOverlap = is_hovered;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);


        SetActiveIdUsingAllKeyboardKeys();
    }
    else
    {
        window = 
# 11814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                __null
# 11814 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                    ;
        source_id = ImHashStr("#SourceExtern");
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            
# 11823 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 11823 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           source_id != 0
# 11823 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 11823 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "source_id != 0"
# 11823 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11823, __extension__ __PRETTY_FUNCTION__))
# 11823 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;
            ClearDragDrop();
            ImGuiPayload& payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
            if (payload.SourceId == g.ActiveId)
                g.ActiveIdNoClearOnFocusLoss = true;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSource = true;

        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        {


            BeginTooltip();
            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
            {
                ImGuiWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->Hidden = tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesCanSkipItems = 1;
            }
        }

        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
            g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void ImGui::EndDragDropSource()
{
    ImGuiContext& g = *GImGui;
    
# 11861 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11861 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropActive
# 11861 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11861 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropActive"
# 11861 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11861, __extension__ __PRETTY_FUNCTION__))
# 11861 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
    
# 11862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropWithinSource && "Not after a BeginDragDropSource()?"
# 11862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropWithinSource && \"Not after a BeginDragDropSource()?\""
# 11862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11862, __extension__ __PRETTY_FUNCTION__))
# 11862 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                            ;

    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();


    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSource = false;
}


bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    ImGuiPayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = ImGuiCond_Always;

    
# 11881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   type != 
# 11881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 11881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "type != __null"
# 11881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11881, __extension__ __PRETTY_FUNCTION__))
# 11881 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          ;
    
# 11882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   strlen(type) < ((int)(sizeof(payload.DataType) / sizeof(*(payload.DataType)))) && "Payload type can be at most 32 characters long"
# 11882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "strlen(type) < ((int)(sizeof(payload.DataType) / sizeof(*(payload.DataType)))) && \"Payload type can be at most 32 characters long\""
# 11882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11882, __extension__ __PRETTY_FUNCTION__))
# 11882 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                               ;
    
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   (data != 
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && data_size > 0) || (data == 
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null 
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   && data_size == 0)
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "(data != __null && data_size > 0) || (data == __null && data_size == 0)"
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11883, __extension__ __PRETTY_FUNCTION__))
# 11883 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                 ;
    
# 11884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   cond == ImGuiCond_Always || cond == ImGuiCond_Once
# 11884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "cond == ImGuiCond_Always || cond == ImGuiCond_Once"
# 11884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11884, __extension__ __PRETTY_FUNCTION__))
# 11884 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                ;
    
# 11885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   payload.SourceId != 0
# 11885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "payload.SourceId != 0"
# 11885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11885, __extension__ __PRETTY_FUNCTION__))
# 11885 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {

        ImStrncpy(payload.DataType, type, ((int)(sizeof(payload.DataType) / sizeof(*(payload.DataType)))));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {

            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {

            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = 
# 11908 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                          __null
# 11908 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;


    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
    if (hovered_window == 
# 11926 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                         __null 
# 11926 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              || window->RootWindow != hovered_window->RootWindow)
        return false;
    
# 11928 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11928 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   id != 0
# 11928 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11928 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "id != 0"
# 11928 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11928, __extension__ __PRETTY_FUNCTION__))
# 11928 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    
# 11934 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11934 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropWithinTarget == false
# 11934 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11934 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropWithinTarget == false"
# 11934 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11934, __extension__ __PRETTY_FUNCTION__))
# 11934 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                             ;
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinTarget = true;
    return true;
}





bool ImGui::BeginDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (!(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    ImGuiWindow* hovered_window = g.HoveredWindowUnderMovingWindow;
    if (hovered_window == 
# 11955 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                         __null 
# 11955 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              || window->RootWindow != hovered_window->RootWindow || window->SkipItems)
        return false;

    const ImRect& display_rect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? g.LastItemData.DisplayRect : g.LastItemData.Rect;
    ImGuiID id = g.LastItemData.ID;
    if (id == 0)
    {
        id = window->GetIDFromRectangle(display_rect);
        KeepAliveID(id);
    }
    if (g.DragDropPayload.SourceId == id)
        return false;

    
# 11968 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11968 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropWithinTarget == false
# 11968 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11968 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropWithinTarget == false"
# 11968 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11968, __extension__ __PRETTY_FUNCTION__))
# 11968 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                             ;
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinTarget = true;
    return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiPayload& payload = g.DragDropPayload;
    
# 11986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropActive
# 11986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropActive"
# 11986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11986, __extension__ __PRETTY_FUNCTION__))
# 11986 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
    
# 11987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 11987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   payload.DataFrameCount != -1
# 11987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 11987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "payload.DataFrameCount != -1"
# 11987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 11987, __extension__ __PRETTY_FUNCTION__))
# 11987 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                          ;
    if (type != 
# 11988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               __null 
# 11988 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                    && !payload.IsDataType(type))
        return 
# 11989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 11989 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;



    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    ImRect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface <= g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }


    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect);
    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
        window->DrawList->AddRect(r.Min - ImVec2(3.5f,3.5f), r.Max + ImVec2(3.5f, 3.5f), GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton);
    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
        return 
# 12012 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
              __null
# 12012 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                  ;

    return &payload;
}


void ImGui::RenderDragDropTargetRect(const ImRect& bb)
{
    GetWindowDrawList()->AddRect(bb.Min - ImVec2(3.5f, 3.5f), bb.Max + ImVec2(3.5f, 3.5f), GetColorU32(ImGuiCol_DragDropTarget), 0.0f, 0, 2.0f);
}

const ImGuiPayload* ImGui::GetDragDropPayload()
{
    ImGuiContext& g = *GImGui;
    return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : 
# 12026 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                              __null
# 12026 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                  ;
}


void ImGui::EndDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    
# 12033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropActive
# 12033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 12033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropActive"
# 12033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12033, __extension__ __PRETTY_FUNCTION__))
# 12033 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                              ;
    
# 12034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.DragDropWithinTarget
# 12034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 12034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.DragDropWithinTarget"
# 12034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12034, __extension__ __PRETTY_FUNCTION__))
# 12034 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;
    g.DragDropWithinTarget = false;
}
# 12046 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static inline void LogTextV(ImGuiContext& g, const char* fmt, va_list args)
{
    if (g.LogFile)
    {
        g.LogBuffer.Buf.resize(0);
        g.LogBuffer.appendfv(fmt, args);
        ImFileWrite(g.LogBuffer.c_str(), sizeof(char), (ImU64)g.LogBuffer.size(), g.LogFile);
    }
    else
    {
        g.LogBuffer.appendfv(fmt, args);
    }
}

void ImGui::LogText(const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    va_list args;
    
# 12067 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_start(
# 12067 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 12067 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 12067 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   fmt
# 12067 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 12067 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;
    LogTextV(g, fmt, args);
    
# 12069 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 12069 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 12069 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 12069 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
}

void ImGui::LogTextV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogTextV(g, fmt, args);
}




void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const char* prefix = g.LogNextPrefix;
    const char* suffix = g.LogNextSuffix;
    g.LogNextPrefix = g.LogNextSuffix = 
# 12091 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                       __null
# 12091 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;

    if (!text_end)
        text_end = FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + g.Style.FramePadding.y + 1);
    if (ref_pos)
        g.LogLinePosY = ref_pos->y;
    if (log_new_line)
    {
        LogText("\n");
        g.LogLineFirstItem = true;
    }

    if (prefix)
        LogRenderedText(ref_pos, prefix, prefix + strlen(prefix));


    if (g.LogDepthRef > window->DC.TreeDepth)
        g.LogDepthRef = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);

    const char* text_remaining = text;
    for (;;)
    {


        const char* line_start = text_remaining;
        const char* line_end = ImStreolRange(line_start, text_end);
        const bool is_last_line = (line_end == text_end);
        if (line_start != line_end || !is_last_line)
        {
            const int line_length = (int)(line_end - line_start);
            const int indentation = g.LogLineFirstItem ? tree_depth * 4 : 1;
            LogText("%*s%.*s", indentation, "", line_length, line_start);
            g.LogLineFirstItem = false;
            if (*line_end == '\n')
            {
                LogText("\n");
                g.LogLineFirstItem = true;
            }
        }
        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }

    if (suffix)
        LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));
}


void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    
# 12147 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12147 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.LogEnabled == false
# 12147 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 12147 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.LogEnabled == false"
# 12147 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12147, __extension__ __PRETTY_FUNCTION__))
# 12147 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;
    
# 12148 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12148 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.LogFile == 
# 12148 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 12148 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.LogFile == __null"
# 12148 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12148, __extension__ __PRETTY_FUNCTION__))
# 12148 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                               ;
    
# 12149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.LogBuffer.empty()
# 12149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 12149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.LogBuffer.empty()"
# 12149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12149, __extension__ __PRETTY_FUNCTION__))
# 12149 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 ;
    g.LogEnabled = true;
    g.LogType = type;
    g.LogNextPrefix = g.LogNextSuffix = 
# 12152 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                       __null
# 12152 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;
    g.LogDepthRef = window->DC.TreeDepth;
    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
    g.LogLinePosY = 3.40282346638528859811704183484516925e+38F;
    g.LogLineFirstItem = true;
}


void ImGui::LogSetNextTextDecoration(const char* prefix, const char* suffix)
{
    ImGuiContext& g = *GImGui;
    g.LogNextPrefix = prefix;
    g.LogNextSuffix = suffix;
}

void ImGui::LogToTTY(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ((void)(auto_open_depth));

    LogBegin(ImGuiLogType_TTY, auto_open_depth);
    g.LogFile = 
# 12175 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               stdout
# 12175 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     ;

}


void ImGui::LogToFile(int auto_open_depth, const char* filename)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;




    if (!filename)
        filename = g.IO.LogFilename;
    if (!filename || !filename[0])
        return;
    ImFileHandle f = ImFileOpen(filename, "ab");
    if (!f)
    {
        
# 12196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 12196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       0
# 12196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 12196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "0"
# 12196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12196, __extension__ __PRETTY_FUNCTION__))
# 12196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   ;
        return;
    }

    LogBegin(ImGuiLogType_File, auto_open_depth);
    g.LogFile = f;
}


void ImGui::LogToClipboard(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_Clipboard, auto_open_depth);
}

void ImGui::LogToBuffer(int auto_open_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    LogBegin(ImGuiLogType_Buffer, auto_open_depth);
}

void ImGui::LogFinish()
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogText("\n");
    switch (g.LogType)
    {
    case ImGuiLogType_TTY:

        fflush(g.LogFile);

        break;
    case ImGuiLogType_File:
        ImFileClose(g.LogFile);
        break;
    case ImGuiLogType_Buffer:
        break;
    case ImGuiLogType_Clipboard:
        if (!g.LogBuffer.empty())
            SetClipboardText(g.LogBuffer.begin());
        break;
    case ImGuiLogType_None:
        
# 12245 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 12245 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       0
# 12245 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 12245 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "0"
# 12245 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12245, __extension__ __PRETTY_FUNCTION__))
# 12245 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   ;
        break;
    }

    g.LogEnabled = false;
    g.LogType = ImGuiLogType_None;
    g.LogFile = 
# 12251 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
               __null
# 12251 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   ;
    g.LogBuffer.clear();
}



void ImGui::LogButtons()
{
    ImGuiContext& g = *GImGui;

    PushID("LogButtons");

    const bool log_to_tty = Button("Log To TTY"); SameLine();



    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushAllowKeyboardFocus(false);
    SetNextItemWidth(80.0f);
    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, 
# 12271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                __null
# 12271 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                    );
    PopAllowKeyboardFocus();
    PopID();


    if (log_to_tty)
        LogToTTY();
    if (log_to_file)
        LogToFile();
    if (log_to_clipboard)
        LogToClipboard();
}
# 12303 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::UpdateSettings()
{

    ImGuiContext& g = *GImGui;
    if (!g.SettingsLoaded)
    {
        
# 12309 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 12309 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       g.SettingsWindows.empty()
# 12309 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 12309 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "g.SettingsWindows.empty()"
# 12309 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12309, __extension__ __PRETTY_FUNCTION__))
# 12309 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                           ;
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }


    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != 
# 12321 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                   __null
# 12321 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                       )
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;
            g.SettingsDirtyTimer = 0.0f;
        }
    }
}

void ImGui::MarkIniSettingsDirty()
{
    ImGuiContext& g = *GImGui;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)
{
    ImGuiContext& g = *GImGui;




    if (const char* p = strstr(name, "###"))
        name = p;

    const size_t name_len = strlen(name);


    const size_t chunk_size = sizeof(ImGuiWindowSettings) + name_len + 1;
    ImGuiWindowSettings* settings = g.SettingsWindows.alloc_chunk(chunk_size);
    new(ImNewWrapper(), settings) ImGuiWindowSettings();
    settings->ID = ImHashStr(name, name_len);
    memcpy(settings->GetName(), name, name_len + 1);

    return settings;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != 
# 12370 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                               __null
# 12370 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                   ; settings = g.SettingsWindows.next_chunk(settings))
        if (settings->ID == id)
            return settings;
    return 
# 12373 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 12373 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}

ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)
{
    if (ImGuiWindowSettings* settings = FindWindowSettings(ImHashStr(name)))
        return settings;
    return CreateNewWindowSettings(name);
}

void ImGui::AddSettingsHandler(const ImGuiSettingsHandler* handler)
{
    ImGuiContext& g = *GImGui;
    
# 12386 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12386 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   FindSettingsHandler(handler->TypeName) == 
# 12386 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __null) ? void (0) : __assert_fail (
# 12386 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "FindSettingsHandler(handler->TypeName) == __null"
# 12386 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12386, __extension__ __PRETTY_FUNCTION__))
# 12386 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            ;
    g.SettingsHandlers.push_back(*handler);
}

void ImGui::RemoveSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    if (ImGuiSettingsHandler* handler = FindSettingsHandler(type_name))
        g.SettingsHandlers.erase(handler);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    const ImGuiID type_hash = ImHashStr(type_name);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return 
# 12404 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
          __null
# 12404 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
              ;
}

void ImGui::ClearIniSettings()
{
    ImGuiContext& g = *GImGui;
    g.SettingsIniData.clear();
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].ClearAllFn)
            g.SettingsHandlers[handler_n].ClearAllFn(&g, &g.SettingsHandlers[handler_n]);
}

void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)
        return;
    if (file_data_size > 0)
        LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    ImGui::MemFree(file_data);
}


void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    ImGuiContext& g = *GImGui;
    
# 12431 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12431 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Initialized
# 12431 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 12431 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Initialized"
# 12431 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12431, __extension__ __PRETTY_FUNCTION__))
# 12431 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                           ;





    if (ini_size == 0)
        ini_size = strlen(ini_data);
    g.SettingsIniData.Buf.resize((int)ini_size + 1);
    char* const buf = g.SettingsIniData.Buf.Data;
    char* const buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf_end[0] = 0;



    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].ReadInitFn)
            g.SettingsHandlers[handler_n].ReadInitFn(&g, &g.SettingsHandlers[handler_n]);

    void* entry_data = 
# 12451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                      __null
# 12451 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                          ;
    ImGuiSettingsHandler* entry_handler = 
# 12452 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                         __null
# 12452 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                             ;

    char* line_end = 
# 12454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                    __null
# 12454 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                        ;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {

        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;
        if (line[0] == ';')
            continue;
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {

            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(void*)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : 
# 12473 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                            __null
# 12473 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                ;
            if (!type_end || !name_start)
                continue;
            *type_end = 0;
            name_start++;
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : 
# 12479 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                   __null
# 12479 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
        }
        else if (entry_handler != 
# 12481 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                 __null 
# 12481 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                      && entry_data != 
# 12481 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                       __null
# 12481 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                           )
        {

            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    g.SettingsLoaded = true;


    memcpy(buf, ini_data, ini_size);


    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].ApplyAllFn)
            g.SettingsHandlers[handler_n].ApplyAllFn(&g, &g.SettingsHandlers[handler_n]);
}

void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    ImFileHandle f = ImFileOpen(ini_filename, "wt");
    if (!f)
        return;
    ImFileWrite(ini_data, sizeof(char), ini_data_size, f);
    ImFileClose(f);
}


const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        *out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

static void WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Windows.Size; i++)
        g.Windows[i]->SettingsOffset = -1;
    g.SettingsWindows.clear();
}

static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiWindowSettings* settings = ImGui::FindOrCreateWindowSettings(name);
    ImGuiID id = settings->ID;
    *settings = ImGuiWindowSettings();
    settings->ID = id;
    settings->WantApply = true;
    return (void*)settings;
}

static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
    int x, y;
    int i;
    if (sscanf(line, "Pos=%i,%i", &x, &y) == 2) { settings->Pos = ImVec2ih((short)x, (short)y); }
    else if (sscanf(line, "Size=%i,%i", &x, &y) == 2) { settings->Size = ImVec2ih((short)x, (short)y); }
    else if (sscanf(line, "Collapsed=%d", &i) == 1) { settings->Collapsed = (i != 0); }
}


static void WindowSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != 
# 12563 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                               __null
# 12563 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                   ; settings = g.SettingsWindows.next_chunk(settings))
        if (settings->WantApply)
        {
            if (ImGuiWindow* window = ImGui::FindWindowByID(settings->ID))
                ApplyWindowSettings(window, settings);
            settings->WantApply = false;
        }
}

static void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{


    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
            continue;

        ImGuiWindowSettings* settings = (window->SettingsOffset != -1) ? g.SettingsWindows.ptr_from_offset(window->SettingsOffset) : ImGui::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = ImGui::CreateNewWindowSettings(window->Name);
            window->SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
        }
        
# 12589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 12589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       settings->ID == window->ID
# 12589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 12589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "settings->ID == window->ID"
# 12589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12589, __extension__ __PRETTY_FUNCTION__))
# 12589 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                            ;
        settings->Pos = ImVec2ih(window->Pos);
        settings->Size = ImVec2ih(window->SizeFull);

        settings->Collapsed = window->Collapsed;
    }


    buf->reserve(buf->size() + g.SettingsWindows.size() * 6);
    for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != 
# 12598 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                               __null
# 12598 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                   ; settings = g.SettingsWindows.next_chunk(settings))
    {
        const char* settings_name = settings->GetName();
        buf->appendf("[%s][%s]\n", handler->TypeName, settings_name);
        buf->appendf("Pos=%d,%d\n", settings->Pos.x, settings->Pos.y);
        buf->appendf("Size=%d,%d\n", settings->Size.x, settings->Size.y);
        buf->appendf("Collapsed=%d\n", settings->Collapsed);
        buf->append("\n");
    }
}






void ImGui::LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count)
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < count; n++)
        g.LocalizationTable[entries[n].Key] = entries[n].Text;
}
# 12631 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
ImGuiViewport* ImGui::GetMainViewport()
{
    ImGuiContext& g = *GImGui;
    return g.Viewports[0];
}

void ImGui::SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport)
{
    window->Viewport = viewport;
}


static void ImGui::UpdateViewportsNewFrame()
{
    ImGuiContext& g = *GImGui;
    
# 12646 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 12646 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   g.Viewports.Size == 1
# 12646 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 12646 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "g.Viewports.Size == 1"
# 12646 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 12646, __extension__ __PRETTY_FUNCTION__))
# 12646 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;



    ImGuiViewportP* main_viewport = g.Viewports[0];
    main_viewport->Flags = ImGuiViewportFlags_IsPlatformWindow | ImGuiViewportFlags_OwnedByApp;
    main_viewport->Pos = ImVec2(0.0f, 0.0f);
    main_viewport->Size = g.IO.DisplaySize;

    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];


        viewport->WorkOffsetMin = viewport->BuildWorkOffsetMin;
        viewport->WorkOffsetMax = viewport->BuildWorkOffsetMax;
        viewport->BuildWorkOffsetMin = viewport->BuildWorkOffsetMax = ImVec2(0.0f, 0.0f);
        viewport->UpdateWorkRect();
    }
}
# 12786 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    return g.ClipboardHandlerData.empty() ? 
# 12789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                           __null 
# 12789 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                : g.ClipboardHandlerData.begin();
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    ImGuiContext& g = *GImGui;
    g.ClipboardHandlerData.clear();
    const char* text_end = text + strlen(text);
    g.ClipboardHandlerData.resize((int)(text_end - text) + 1);
    memcpy(&g.ClipboardHandlerData[0], text, (size_t)(text_end - text));
    g.ClipboardHandlerData[(int)(text_end - text)] = 0;
}
# 12842 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
static void SetPlatformImeDataFn_DefaultImpl(ImGuiViewport*, ImGuiPlatformImeData*) {}
# 12871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
void ImGui::DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImVec2 scale = bb.GetSize() / viewport->Size;
    ImVec2 off = bb.Min - viewport->Pos * scale;
    float alpha_mul = 1.0f;
    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul * 0.40f));
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* thumb_window = g.Windows[i];
        if (!thumb_window->WasActive || (thumb_window->Flags & ImGuiWindowFlags_ChildWindow))
            continue;

        ImRect thumb_r = thumb_window->Rect();
        ImRect title_r = thumb_window->TitleBarRect();
        thumb_r = ImRect(ImFloor(off + thumb_r.Min * scale), ImFloor(off + thumb_r.Max * scale));
        title_r = ImRect(ImFloor(off + title_r.Min * scale), ImFloor(off + ImVec2(title_r.Max.x, title_r.Min.y) * scale) + ImVec2(0,5));
        thumb_r.ClipWithFull(bb);
        title_r.ClipWithFull(bb);
        const bool window_is_focused = (g.NavWindow && thumb_window->RootWindowForTitleBarHighlight == g.NavWindow->RootWindowForTitleBarHighlight);
        window->DrawList->AddRectFilled(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_WindowBg, alpha_mul));
        window->DrawList->AddRectFilled(title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg, alpha_mul));
        window->DrawList->AddRect(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
        window->DrawList->AddText(g.Font, g.FontSize * 1.0f, title_r.Min, GetColorU32(ImGuiCol_Text, alpha_mul), thumb_window->Name, FindRenderedTextEnd(thumb_window->Name));
    }
    draw_list->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_Border, alpha_mul));
}

static void RenderViewportsThumbnails()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;


    float SCALE = 1.0f / 8.0f;
    ImRect bb_full(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    for (int n = 0; n < g.Viewports.Size; n++)
        bb_full.Add(g.Viewports[n]->GetMainRect());
    ImVec2 p = window->DC.CursorPos;
    ImVec2 off = p - bb_full.Min * SCALE;
    for (int n = 0; n < g.Viewports.Size; n++)
    {
        ImGuiViewportP* viewport = g.Viewports[n];
        ImRect viewport_draw_bb(off + (viewport->Pos) * SCALE, off + (viewport->Pos + viewport->Size) * SCALE);
        ImGui::DebugRenderViewportThumbnail(window->DrawList, viewport, viewport_draw_bb);
    }
    ImGui::Dummy(bb_full.GetSize() * SCALE);
}


void ImGui::DebugTextEncoding(const char* str)
{
    Text("Text: \"%s\"", str);
    if (!BeginTable("list", 4, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_SizingFixedFit))
        return;
    TableSetupColumn("Offset");
    TableSetupColumn("UTF-8");
    TableSetupColumn("Glyph");
    TableSetupColumn("Codepoint");
    TableHeadersRow();
    for (const char* p = str; *p != 0; )
    {
        unsigned int c;
        const int c_utf8_len = ImTextCharFromUtf8(&c, p, 
# 12936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                        __null
# 12936 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                            );
        TableNextColumn();
        Text("%d", (int)(p - str));
        TableNextColumn();
        for (int byte_index = 0; byte_index < c_utf8_len; byte_index++)
        {
            if (byte_index > 0)
                SameLine();
            Text("0x%02X", (int)(unsigned char)p[byte_index]);
        }
        TableNextColumn();
        if (GetFont()->FindGlyphNoFallback((ImWchar)c))
            TextUnformatted(p, p + c_utf8_len);
        else
            TextUnformatted((c == 0xFFFD) ? "[invalid]" : "[missing]");
        TableNextColumn();
        Text("U+%04X", (int)c);
        p += c_utf8_len;
    }
    EndTable();
}


static void MetricsHelpMarker(const char* desc)
{
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered(ImGuiHoveredFlags_DelayShort))
    {
        ImGui::BeginTooltip();
        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
        ImGui::TextUnformatted(desc);
        ImGui::PopTextWrapPos();
        ImGui::EndTooltip();
    }
}


void ImGui::ShowFontAtlas(ImFontAtlas* atlas)
{
    for (int i = 0; i < atlas->Fonts.Size; i++)
    {
        ImFont* font = atlas->Fonts[i];
        PushID(font);
        DebugNodeFont(font);
        PopID();
    }
    if (TreeNode("Atlas texture", "Atlas texture (%dx%d pixels)", atlas->TexWidth, atlas->TexHeight))
    {
        ImVec4 tint_col = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        ImVec4 border_col = ImVec4(1.0f, 1.0f, 1.0f, 0.5f);
        Image(atlas->TexID, ImVec2((float)atlas->TexWidth, (float)atlas->TexHeight), ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), tint_col, border_col);
        TreePop();
    }
}

void ImGui::ShowMetricsWindow(bool* p_open)
{
    ImGuiContext& g = *GImGui;
    ImGuiIO& io = g.IO;
    ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;
    if (cfg->ShowDebugLog)
        ShowDebugLogWindow(&cfg->ShowDebugLog);
    if (cfg->ShowStackTool)
        ShowStackToolWindow(&cfg->ShowStackTool);

    if (!Begin("Dear ImGui Metrics/Debugger", p_open) || GetCurrentWindow()->BeginCount > 1)
    {
        End();
        return;
    }


    Text("Dear ImGui %s", GetVersion());
    Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    Text("%d visible windows, %d active allocations", io.MetricsRenderWindows, io.MetricsActiveAllocations);


    Separator();


    enum { WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentIdeal, WRT_ContentRegionRect, WRT_Count };
    const char* wrt_rects_names[WRT_Count] = { "OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect" };
    enum { TRT_OuterRect, TRT_InnerRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsWorkRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersIdeal, TRT_ColumnsContentFrozen, TRT_ColumnsContentUnfrozen, TRT_Count };
    const char* trt_rects_names[TRT_Count] = { "OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen" };
    if (cfg->ShowWindowsRectsType < 0)
        cfg->ShowWindowsRectsType = WRT_WorkRect;
    if (cfg->ShowTablesRectsType < 0)
        cfg->ShowTablesRectsType = TRT_WorkRect;

    struct Funcs
    {
        static ImRect GetTableRect(ImGuiTable* table, int rect_type, int n)
        {
            ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
            if (rect_type == TRT_OuterRect) { return table->OuterRect; }
            else if (rect_type == TRT_InnerRect) { return table->InnerRect; }
            else if (rect_type == TRT_WorkRect) { return table->WorkRect; }
            else if (rect_type == TRT_HostClipRect) { return table->HostClipRect; }
            else if (rect_type == TRT_InnerClipRect) { return table->InnerClipRect; }
            else if (rect_type == TRT_BackgroundClipRect) { return table->BgClipRect; }
            else if (rect_type == TRT_ColumnsRect) { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->MinX, table->InnerClipRect.Min.y, c->MaxX, table->InnerClipRect.Min.y + table_instance->LastOuterHeight); }
            else if (rect_type == TRT_ColumnsWorkRect) { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->WorkRect.Min.y, c->WorkMaxX, table->WorkRect.Max.y); }
            else if (rect_type == TRT_ColumnsClipRect) { ImGuiTableColumn* c = &table->Columns[n]; return c->ClipRect; }
            else if (rect_type == TRT_ColumnsContentHeadersUsed){ ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersUsed, table->InnerClipRect.Min.y + table_instance->LastFirstRowHeight); }
            else if (rect_type == TRT_ColumnsContentHeadersIdeal){ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXHeadersIdeal, table->InnerClipRect.Min.y + table_instance->LastFirstRowHeight); }
            else if (rect_type == TRT_ColumnsContentFrozen) { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y, c->ContentMaxXFrozen, table->InnerClipRect.Min.y + table_instance->LastFirstRowHeight); }
            else if (rect_type == TRT_ColumnsContentUnfrozen) { ImGuiTableColumn* c = &table->Columns[n]; return ImRect(c->WorkMinX, table->InnerClipRect.Min.y + table_instance->LastFirstRowHeight, c->ContentMaxXUnfrozen, table->InnerClipRect.Max.y); }
            
# 13044 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 13044 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           0
# 13044 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 13044 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "0"
# 13044 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 13044, __extension__ __PRETTY_FUNCTION__))
# 13044 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                       ;
            return ImRect();
        }

        static ImRect GetWindowRect(ImGuiWindow* window, int rect_type)
        {
            if (rect_type == WRT_OuterRect) { return window->Rect(); }
            else if (rect_type == WRT_OuterRectClipped) { return window->OuterRectClipped; }
            else if (rect_type == WRT_InnerRect) { return window->InnerRect; }
            else if (rect_type == WRT_InnerClipRect) { return window->InnerClipRect; }
            else if (rect_type == WRT_WorkRect) { return window->WorkRect; }
            else if (rect_type == WRT_Content) { ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect(min, min + window->ContentSize); }
            else if (rect_type == WRT_ContentIdeal) { ImVec2 min = window->InnerRect.Min - window->Scroll + window->WindowPadding; return ImRect(min, min + window->ContentSizeIdeal); }
            else if (rect_type == WRT_ContentRegionRect) { return window->ContentRegionRect; }
            
# 13058 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           (static_cast <bool> (
# 13058 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           0
# 13058 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           ) ? void (0) : __assert_fail (
# 13058 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
           "0"
# 13058 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
           , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 13058, __extension__ __PRETTY_FUNCTION__))
# 13058 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                       ;
            return ImRect();
        }
    };


    if (TreeNode("Tools"))
    {
        bool show_encoding_viewer = TreeNode("UTF-8 Encoding viewer");
        SameLine();
        MetricsHelpMarker("You can also call ImGui::DebugTextEncoding() from your code with a given string to test that your UTF-8 encoding settings are correct.");
        if (show_encoding_viewer)
        {
            static char buf[100] = "";
            SetNextItemWidth(-1.17549435082228750796873653722224568e-38F);
            InputText("##Text", buf, ((int)(sizeof(buf) / sizeof(*(buf)))));
            if (buf[0] != 0)
                DebugTextEncoding(buf);
            TreePop();
        }


        if (Checkbox("Show Item Picker", &g.DebugItemPickerActive) && g.DebugItemPickerActive)
            DebugStartItemPicker();
        SameLine();
        MetricsHelpMarker("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.");


        Checkbox("Show Debug Log", &cfg->ShowDebugLog);
        SameLine();
        MetricsHelpMarker("You can also call ImGui::ShowDebugLogWindow() from your code.");


        Checkbox("Show Stack Tool", &cfg->ShowStackTool);
        SameLine();
        MetricsHelpMarker("You can also call ImGui::ShowStackToolWindow() from your code.");

        Checkbox("Show windows begin order", &cfg->ShowWindowsBeginOrder);
        Checkbox("Show windows rectangles", &cfg->ShowWindowsRects);
        SameLine();
        SetNextItemWidth(GetFontSize() * 12);
        cfg->ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg->ShowWindowsRectsType, wrt_rects_names, WRT_Count, WRT_Count);
        if (cfg->ShowWindowsRects && g.NavWindow != 
# 13100 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                   __null
# 13100 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                       )
        {
            BulletText("'%s':", g.NavWindow->Name);
            Indent();
            for (int rect_n = 0; rect_n < WRT_Count; rect_n++)
            {
                ImRect r = Funcs::GetWindowRect(g.NavWindow, rect_n);
                Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), wrt_rects_names[rect_n]);
            }
            Unindent();
        }

        Checkbox("Show tables rectangles", &cfg->ShowTablesRects);
        SameLine();
        SetNextItemWidth(GetFontSize() * 12);
        cfg->ShowTablesRects |= Combo("##show_table_rects_type", &cfg->ShowTablesRectsType, trt_rects_names, TRT_Count, TRT_Count);
        if (cfg->ShowTablesRects && g.NavWindow != 
# 13116 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                  __null
# 13116 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                      )
        {
            for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++)
            {
                ImGuiTable* table = g.Tables.TryGetMapData(table_n);
                if (table == 
# 13121 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                            __null 
# 13121 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                 || table->LastFrameActive < g.FrameCount - 1 || (table->OuterWindow != g.NavWindow && table->InnerWindow != g.NavWindow))
                    continue;

                BulletText("Table 0x%08X (%d columns, in '%s')", table->ID, table->ColumnsCount, table->OuterWindow->Name);
                if (IsItemHovered())
                    GetForegroundDrawList()->AddRect(table->OuterRect.Min - ImVec2(1, 1), table->OuterRect.Max + ImVec2(1, 1), (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), 0.0f, 0, 2.0f);
                Indent();
                char buf[128];
                for (int rect_n = 0; rect_n < TRT_Count; rect_n++)
                {
                    if (rect_n >= TRT_ColumnsRect)
                    {
                        if (rect_n != TRT_ColumnsRect && rect_n != TRT_ColumnsClipRect)
                            continue;
                        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                        {
                            ImRect r = Funcs::GetTableRect(table, rect_n, column_n);
                            ImFormatString(buf, ((int)(sizeof(buf) / sizeof(*(buf)))), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), column_n, trt_rects_names[rect_n]);
                            Selectable(buf);
                            if (IsItemHovered())
                                GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), 0.0f, 0, 2.0f);
                        }
                    }
                    else
                    {
                        ImRect r = Funcs::GetTableRect(table, rect_n, -1);
                        ImFormatString(buf, ((int)(sizeof(buf) / sizeof(*(buf)))), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), trt_rects_names[rect_n]);
                        Selectable(buf);
                        if (IsItemHovered())
                            GetForegroundDrawList()->AddRect(r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), 0.0f, 0, 2.0f);
                    }
                }
                Unindent();
            }
        }

        TreePop();
    }


    if (TreeNode("Window", "Window (%d)", g.Windows.Size))
    {

        DebugNodeWindowsList(&g.Windows, "By display order");
        DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)");
        if (TreeNode("By submission order (begin stack)"))
        {

            ImVector<ImGuiWindow*>& temp_buffer = g.WindowsTempSortBuffer;
            temp_buffer.resize(0);
            for (int i = 0; i < g.Windows.Size; i++)
                if (g.Windows[i]->LastFrameActive + 1 >= g.FrameCount)
                    temp_buffer.push_back(g.Windows[i]);
            struct Func { static int WindowComparerByBeginOrder(const void* lhs, const void* rhs) { return ((int)(*(const ImGuiWindow* const *)lhs)->BeginOrderWithinContext - (*(const ImGuiWindow* const*)rhs)->BeginOrderWithinContext); } };
            ImQsort(temp_buffer.Data, (size_t)temp_buffer.Size, sizeof(ImGuiWindow*), Func::WindowComparerByBeginOrder);
            DebugNodeWindowsListByBeginStackParent(temp_buffer.Data, temp_buffer.Size, 
# 13176 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                      __null
# 13176 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                          );
            TreePop();
        }

        TreePop();
    }


    int drawlist_count = 0;
    for (int viewport_i = 0; viewport_i < g.Viewports.Size; viewport_i++)
        drawlist_count += g.Viewports[viewport_i]->DrawDataBuilder.GetDrawListCount();
    if (TreeNode("DrawLists", "DrawLists (%d)", drawlist_count))
    {
        Checkbox("Show ImDrawCmd mesh when hovering", &cfg->ShowDrawCmdMesh);
        Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg->ShowDrawCmdBoundingBoxes);
        for (int viewport_i = 0; viewport_i < g.Viewports.Size; viewport_i++)
        {
            ImGuiViewportP* viewport = g.Viewports[viewport_i];
            for (int layer_i = 0; layer_i < ((int)(sizeof(viewport->DrawDataBuilder.Layers) / sizeof(*(viewport->DrawDataBuilder.Layers)))); layer_i++)
                for (int draw_list_i = 0; draw_list_i < viewport->DrawDataBuilder.Layers[layer_i].Size; draw_list_i++)
                    DebugNodeDrawList(
# 13196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                     __null
# 13196 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                         , viewport->DrawDataBuilder.Layers[layer_i][draw_list_i], "DrawList");
        }
        TreePop();
    }


    if (TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size))
    {
        Indent(GetTreeNodeToLabelSpacing());
        RenderViewportsThumbnails();
        Unindent(GetTreeNodeToLabelSpacing());
        for (int i = 0; i < g.Viewports.Size; i++)
            DebugNodeViewport(g.Viewports[i]);
        TreePop();
    }


    if (TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for (int i = 0; i < g.OpenPopupStack.Size; i++)
        {

            const ImGuiPopupData* popup_data = &g.OpenPopupStack[i];
            ImGuiWindow* window = popup_data->Window;
            BulletText("PopupID: %08x, Window: '%s' (%s%s), BackupNavWindow '%s', ParentWindow '%s'",
                popup_data->PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? "Child;" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? "Menu;" : "",
                popup_data->BackupNavWindow ? popup_data->BackupNavWindow->Name : "NULL", window && window->ParentWindow ? window->ParentWindow->Name : "NULL");
        }
        TreePop();
    }


    if (TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.GetAliveCount()))
    {
        for (int n = 0; n < g.TabBars.GetMapSize(); n++)
            if (ImGuiTabBar* tab_bar = g.TabBars.TryGetMapData(n))
            {
                PushID(tab_bar);
                DebugNodeTabBar(tab_bar, "TabBar");
                PopID();
            }
        TreePop();
    }


    if (TreeNode("Tables", "Tables (%d)", g.Tables.GetAliveCount()))
    {
        for (int n = 0; n < g.Tables.GetMapSize(); n++)
            if (ImGuiTable* table = g.Tables.TryGetMapData(n))
                DebugNodeTable(table);
        TreePop();
    }


    ImFontAtlas* atlas = g.IO.Fonts;
    if (TreeNode("Fonts", "Fonts (%d)", atlas->Fonts.Size))
    {
        ShowFontAtlas(atlas);
        TreePop();
    }


    if (TreeNode("InputText"))
    {
        DebugNodeInputTextState(&g.InputTextState);
        TreePop();
    }
# 13273 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    if (TreeNode("Settings"))
    {
        if (SmallButton("Clear"))
            ClearIniSettings();
        SameLine();
        if (SmallButton("Save to memory"))
            SaveIniSettingsToMemory();
        SameLine();
        if (SmallButton("Save to disk"))
            SaveIniSettingsToDisk(g.IO.IniFilename);
        SameLine();
        if (g.IO.IniFilename)
            Text("\"%s\"", g.IO.IniFilename);
        else
            TextUnformatted("<NULL>");
        Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer);
        if (TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size))
        {
            for (int n = 0; n < g.SettingsHandlers.Size; n++)
                BulletText("%s", g.SettingsHandlers[n].TypeName);
            TreePop();
        }
        if (TreeNode("SettingsWindows", "Settings packed data: Window: %d bytes", g.SettingsWindows.size()))
        {
            for (ImGuiWindowSettings* settings = g.SettingsWindows.begin(); settings != 
# 13297 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                       __null
# 13297 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                           ; settings = g.SettingsWindows.next_chunk(settings))
                DebugNodeWindowSettings(settings);
            TreePop();
        }

        if (TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", g.SettingsTables.size()))
        {
            for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != 
# 13304 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                     __null
# 13304 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                         ; settings = g.SettingsTables.next_chunk(settings))
                DebugNodeTableSettings(settings);
            TreePop();
        }




        if (TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", g.SettingsIniData.size()))
        {
            InputTextMultiline("##Ini", (char*)(void*)g.SettingsIniData.c_str(), g.SettingsIniData.Buf.Size, ImVec2(-1.17549435082228750796873653722224568e-38F, GetTextLineHeight() * 20), ImGuiInputTextFlags_ReadOnly);
            TreePop();
        }
        TreePop();
    }

    if (TreeNode("Key Owners & Shortcut Routing"))
    {
        TextUnformatted("Key Owners:");
        if (BeginListBox("##owners", ImVec2(-1.17549435082228750796873653722224568e-38F, GetTextLineHeightWithSpacing() * 8)))
        {
            for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
            {
                ImGuiKeyOwnerData* owner_data = GetKeyOwnerData(key);
                if (owner_data->OwnerCurr == ((ImGuiID)-1))
                    continue;
                Text("%s: 0x%08X%s", GetKeyName(key), owner_data->OwnerCurr,
                    owner_data->LockUntilRelease ? " LockUntilRelease" : owner_data->LockThisFrame ? " LockThisFrame" : "");
                DebugLocateItemOnHover(owner_data->OwnerCurr);
            }
            EndListBox();
        }
        TextUnformatted("Shortcut Routing:");
        if (BeginListBox("##routes", ImVec2(-1.17549435082228750796873653722224568e-38F, GetTextLineHeightWithSpacing() * 8)))
        {
            for (ImGuiKey key = ImGuiKey_NamedKey_BEGIN; key < ImGuiKey_NamedKey_END; key = (ImGuiKey)(key + 1))
            {
                ImGuiKeyRoutingTable* rt = &g.KeysRoutingTable;
                for (ImGuiKeyRoutingIndex idx = rt->Index[key - ImGuiKey_NamedKey_BEGIN]; idx != -1; )
                {
                    char key_chord_name[64];
                    ImGuiKeyRoutingData* routing_data = &rt->Entries[idx];
                    GetKeyChordName(key | routing_data->Mods, key_chord_name, ((int)(sizeof(key_chord_name) / sizeof(*(key_chord_name)))));
                    Text("%s: 0x%08X", key_chord_name, routing_data->RoutingCurr);
                    DebugLocateItemOnHover(routing_data->RoutingCurr);
                    idx = routing_data->NextEntryIndex;
                }
            }
            EndListBox();
        }
        Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
        TreePop();
    }

    if (TreeNode("Internal state"))
    {
        Text("WINDOWING");
        Indent();
        Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
        Text("HoveredWindow->Root: '%s'", g.HoveredWindow ? g.HoveredWindow->RootWindow->Name : "NULL");
        Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow ? g.HoveredWindowUnderMovingWindow->Name : "NULL");
        Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
        Unindent();

        Text("ITEMS");
        Indent();
        Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource));
        DebugLocateItemOnHover(g.ActiveId);
        Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
        Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
        Text("HoveredId: 0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap);
        Text("HoverDelayId: 0x%08X, Timer: %.2f, ClearTimer: %.2f", g.HoverDelayId, g.HoverDelayTimer, g.HoverDelayClearTimer);
        Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        DebugLocateItemOnHover(g.DragDropPayload.SourceId);
        Unindent();

        Text("NAV,FOCUS");
        Indent();
        Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
        Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        DebugLocateItemOnHover(g.NavId);
        Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource));
        Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        Text("NavActivateId/DownId/PressedId/InputId: %08X/%08X/%08X/%08X", g.NavActivateId, g.NavActivateDownId, g.NavActivatePressedId, g.NavActivateInputId);
        Text("NavActivateFlags: %04X", g.NavActivateFlags);
        Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
        Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId);
        Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
        Unindent();

        TreePop();
    }


    if (cfg->ShowWindowsRects || cfg->ShowWindowsBeginOrder)
    {
        for (int n = 0; n < g.Windows.Size; n++)
        {
            ImGuiWindow* window = g.Windows[n];
            if (!window->WasActive)
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(window);
            if (cfg->ShowWindowsRects)
            {
                ImRect r = Funcs::GetWindowRect(window, cfg->ShowWindowsRectsType);
                draw_list->AddRect(r.Min, r.Max, (((ImU32)(255)<<24) | ((ImU32)(128)<<16) | ((ImU32)(0)<<8) | ((ImU32)(255)<<0)));
            }
            if (cfg->ShowWindowsBeginOrder && !(window->Flags & ImGuiWindowFlags_ChildWindow))
            {
                char buf[32];
                ImFormatString(buf, ((int)(sizeof(buf) / sizeof(*(buf)))), "%d", window->BeginOrderWithinContext);
                float font_size = GetFontSize();
                draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), (((ImU32)(255)<<24) | ((ImU32)(100)<<16) | ((ImU32)(100)<<8) | ((ImU32)(200)<<0)));
                draw_list->AddText(window->Pos, (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), buf);
            }
        }
    }


    if (cfg->ShowTablesRects)
    {
        for (int table_n = 0; table_n < g.Tables.GetMapSize(); table_n++)
        {
            ImGuiTable* table = g.Tables.TryGetMapData(table_n);
            if (table == 
# 13428 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                        __null 
# 13428 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                             || table->LastFrameActive < g.FrameCount - 1)
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(table->OuterWindow);
            if (cfg->ShowTablesRectsType >= TRT_ColumnsRect)
            {
                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                {
                    ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, column_n);
                    ImU32 col = (table->HoveredColumnBody == column_n) ? (((ImU32)(255)<<24) | ((ImU32)(128)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)) : (((ImU32)(255)<<24) | ((ImU32)(128)<<16) | ((ImU32)(0)<<8) | ((ImU32)(255)<<0));
                    float thickness = (table->HoveredColumnBody == column_n) ? 3.0f : 1.0f;
                    draw_list->AddRect(r.Min, r.Max, col, 0.0f, 0, thickness);
                }
            }
            else
            {
                ImRect r = Funcs::GetTableRect(table, cfg->ShowTablesRectsType, -1);
                draw_list->AddRect(r.Min, r.Max, (((ImU32)(255)<<24) | ((ImU32)(128)<<16) | ((ImU32)(0)<<8) | ((ImU32)(255)<<0)));
            }
        }
    }
# 13456 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
    End();
}


void ImGui::DebugNodeColumns(ImGuiOldColumns* columns)
{
    if (!TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
        return;
    BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->OffMaxX - columns->OffMinX, columns->OffMinX, columns->OffMaxX);
    for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
        BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, GetColumnOffsetFromNorm(columns, columns->Columns[column_n].OffsetNorm));
    TreePop();
}


void ImGui::DebugNodeDrawList(ImGuiWindow* window, const ImDrawList* draw_list, const char* label)
{
    ImGuiContext& g = *GImGui;
    ImGuiMetricsConfig* cfg = &g.DebugMetricsConfig;
    int cmd_count = draw_list->CmdBuffer.Size;
    if (cmd_count > 0 && draw_list->CmdBuffer.back().ElemCount == 0 && draw_list->CmdBuffer.back().UserCallback == 
# 13476 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                                  __null
# 13476 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                                      )
        cmd_count--;
    bool node_open = TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, cmd_count);
    if (draw_list == GetWindowDrawList())
    {
        SameLine();
        TextColored(ImVec4(1.0f, 0.4f, 0.4f, 1.0f), "CURRENTLY APPENDING");
        if (node_open)
            TreePop();
        return;
    }

    ImDrawList* fg_draw_list = GetForegroundDrawList(window);
    if (window && IsItemHovered() && fg_draw_list)
        fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    if (!node_open)
        return;

    if (window && !window->WasActive)
        TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!");

    for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.Data; pcmd < draw_list->CmdBuffer.Data + cmd_count; pcmd++)
    {
        if (pcmd->UserCallback)
        {
            BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
            continue;
        }

        char buf[300];
        ImFormatString(buf, ((int)(sizeof(buf) / sizeof(*(buf)))), "DrawCmd:%5d tris, Tex 0x%p, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)",
            pcmd->ElemCount / 3, (void*)(intptr_t)pcmd->TextureId,
            pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
        bool pcmd_node_open = TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "%s", buf);
        if (IsItemHovered() && (cfg->ShowDrawCmdMesh || cfg->ShowDrawCmdBoundingBoxes) && fg_draw_list)
            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg->ShowDrawCmdMesh, cfg->ShowDrawCmdBoundingBoxes);
        if (!pcmd_node_open)
            continue;



        const ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : 
# 13517 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                                   __null
# 13517 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                       ;
        const ImDrawVert* vtx_buffer = draw_list->VtxBuffer.Data + pcmd->VtxOffset;
        float total_area = 0.0f;
        for (unsigned int idx_n = pcmd->IdxOffset; idx_n < pcmd->IdxOffset + pcmd->ElemCount; )
        {
            ImVec2 triangle[3];
            for (int n = 0; n < 3; n++, idx_n++)
                triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos;
            total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2]);
        }


        ImFormatString(buf, ((int)(sizeof(buf) / sizeof(*(buf)))), "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd->ElemCount, pcmd->VtxOffset, pcmd->IdxOffset, total_area);
        Selectable(buf);
        if (IsItemHovered() && fg_draw_list)
            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false);


        ImGuiListClipper clipper;
        clipper.Begin(pcmd->ElemCount / 3);
        while (clipper.Step())
            for (int prim = clipper.DisplayStart, idx_i = pcmd->IdxOffset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)
            {
                char* buf_p = buf, * buf_end = buf + ((int)(sizeof(buf) / sizeof(*(buf))));
                ImVec2 triangle[3];
                for (int n = 0; n < 3; n++, idx_i++)
                {
                    const ImDrawVert& v = vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i];
                    triangle[n] = v.pos;
                    buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
                        (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                }

                Selectable(buf, false);
                if (fg_draw_list && IsItemHovered())
                {
                    ImDrawListFlags backup_flags = fg_draw_list->Flags;
                    fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines;
                    fg_draw_list->AddPolyline(triangle, 3, (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), ImDrawFlags_Closed, 1.0f);
                    fg_draw_list->Flags = backup_flags;
                }
            }
        TreePop();
    }
    TreePop();
}


void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb)
{
    
# 13567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 13567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   show_mesh || show_aabb
# 13567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 13567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "show_mesh || show_aabb"
# 13567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 13567, __extension__ __PRETTY_FUNCTION__))
# 13567 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                    ;


    ImRect clip_rect = draw_cmd->ClipRect;
    ImRect vtxs_rect(3.40282346638528859811704183484516925e+38F, 3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F, -3.40282346638528859811704183484516925e+38F);
    ImDrawListFlags backup_flags = out_draw_list->Flags;
    out_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines;
    for (unsigned int idx_n = draw_cmd->IdxOffset, idx_end = draw_cmd->IdxOffset + draw_cmd->ElemCount; idx_n < idx_end; )
    {
        ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : 
# 13576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                             __null
# 13576 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                 ;
        ImDrawVert* vtx_buffer = draw_list->VtxBuffer.Data + draw_cmd->VtxOffset;

        ImVec2 triangle[3];
        for (int n = 0; n < 3; n++, idx_n++)
            vtxs_rect.Add((triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos));
        if (show_mesh)
            out_draw_list->AddPolyline(triangle, 3, (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)), ImDrawFlags_Closed, 1.0f);
    }

    if (show_aabb)
    {
        out_draw_list->AddRect(ImFloor(clip_rect.Min), ImFloor(clip_rect.Max), (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(0)<<8) | ((ImU32)(255)<<0)));
        out_draw_list->AddRect(ImFloor(vtxs_rect.Min), ImFloor(vtxs_rect.Max), (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(0)<<0)));
    }
    out_draw_list->Flags = backup_flags;
}


void ImGui::DebugNodeFont(ImFont* font)
{
    bool opened = TreeNode(font, "Font: \"%s\"\n%.2f px, %d glyphs, %d file(s)",
        font->ConfigData ? font->ConfigData[0].Name : "", font->FontSize, font->Glyphs.Size, font->ConfigDataCount);
    SameLine();
    if (SmallButton("Set as default"))
        GetIO().FontDefault = font;
    if (!opened)
        return;


    PushFont(font);
    Text("The quick brown fox jumps over the lazy dog");
    PopFont();


    SetNextItemWidth(GetFontSize() * 8);
    DragFloat("Font scale", &font->Scale, 0.005f, 0.3f, 2.0f, "%.1f");
    SameLine(); MetricsHelpMarker(
        "Note than the default embedded font is NOT meant to be scaled.\n\n"
        "Font are currently rendered into bitmaps at a given size at the time of building the atlas. "
        "You may oversample them to get some flexibility with scaling. "
        "You can also render at multiple sizes and select which one to use at runtime.\n\n"
        "(Glimmer of hope: the atlas system will be rewritten in the future to make scaling more flexible.)");
    Text("Ascent: %f, Descent: %f, Height: %f", font->Ascent, font->Descent, font->Ascent - font->Descent);
    char c_str[5];
    Text("Fallback character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font->FallbackChar), font->FallbackChar);
    Text("Ellipsis character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font->EllipsisChar), font->EllipsisChar);
    const int surface_sqrt = (int)sqrtf((float)font->MetricsTotalSurface);
    Text("Texture Area: about %d px ~%dx%d px", font->MetricsTotalSurface, surface_sqrt, surface_sqrt);
    for (int config_i = 0; config_i < font->ConfigDataCount; config_i++)
        if (font->ConfigData)
            if (const ImFontConfig* cfg = &font->ConfigData[config_i])
                BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, Offset: (%.1f,%.1f)",
                    config_i, cfg->Name, cfg->OversampleH, cfg->OversampleV, cfg->PixelSnapH, cfg->GlyphOffset.x, cfg->GlyphOffset.y);


    if (TreeNode("Glyphs", "Glyphs (%d)", font->Glyphs.Size))
    {
        ImDrawList* draw_list = GetWindowDrawList();
        const ImU32 glyph_col = GetColorU32(ImGuiCol_Text);
        const float cell_size = font->FontSize * 1;
        const float cell_spacing = GetStyle().ItemSpacing.y;
        for (unsigned int base = 0; base <= 0xFFFF; base += 256)
        {



            if (!(base & 4095) && font->IsGlyphRangeUnused(base, base + 4095))
            {
                base += 4096 - 256;
                continue;
            }

            int count = 0;
            for (unsigned int n = 0; n < 256; n++)
                if (font->FindGlyphNoFallback((ImWchar)(base + n)))
                    count++;
            if (count <= 0)
                continue;
            if (!TreeNode((void*)(intptr_t)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))
                continue;


            ImVec2 base_pos = GetCursorScreenPos();
            for (unsigned int n = 0; n < 256; n++)
            {


                ImVec2 cell_p1(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));
                ImVec2 cell_p2(cell_p1.x + cell_size, cell_p1.y + cell_size);
                const ImFontGlyph* glyph = font->FindGlyphNoFallback((ImWchar)(base + n));
                draw_list->AddRect(cell_p1, cell_p2, glyph ? (((ImU32)(100)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)) : (((ImU32)(50)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
                if (!glyph)
                    continue;
                font->RenderChar(draw_list, cell_size, cell_p1, glyph_col, (ImWchar)(base + n));
                if (IsMouseHoveringRect(cell_p1, cell_p2))
                {
                    BeginTooltip();
                    DebugNodeFontGlyph(font, glyph);
                    EndTooltip();
                }
            }
            Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16));
            TreePop();
        }
        TreePop();
    }
    TreePop();
}

void ImGui::DebugNodeFontGlyph(ImFont*, const ImFontGlyph* glyph)
{
    Text("Codepoint: U+%04X", glyph->Codepoint);
    Separator();
    Text("Visible: %d", glyph->Visible);
    Text("AdvanceX: %.1f", glyph->AdvanceX);
    Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph->X0, glyph->Y0, glyph->X1, glyph->Y1);
    Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph->U0, glyph->V0, glyph->U1, glyph->V1);
}


void ImGui::DebugNodeStorage(ImGuiStorage* storage, const char* label)
{
    if (!TreeNode(label, "%s: %d entries, %d bytes", label, storage->Data.Size, storage->Data.size_in_bytes()))
        return;
    for (int n = 0; n < storage->Data.Size; n++)
    {
        const ImGuiStorage::ImGuiStoragePair& p = storage->Data[n];
        BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i);
    }
    TreePop();
}


void ImGui::DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label)
{

    char buf[256];
    char* p = buf;
    const char* buf_end = buf + ((int)(sizeof(buf) / sizeof(*(buf))));
    const bool is_active = (tab_bar->PrevFrameVisible >= GetFrameCount() - 2);
    p += ImFormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s", label, tab_bar->ID, tab_bar->Tabs.Size, is_active ? "" : " *Inactive*");
    p += ImFormatString(p, buf_end - p, "  { ");
    for (int tab_n = 0; tab_n < ImMin(tab_bar->Tabs.Size, 3); tab_n++)
    {
        ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
        p += ImFormatString(p, buf_end - p, "%s'%s'",
            tab_n > 0 ? ", " : "", (tab->NameOffset != -1) ? tab_bar->GetTabName(tab) : "???");
    }
    p += ImFormatString(p, buf_end - p, (tab_bar->Tabs.Size > 3) ? " ... }" : " } ");
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    bool open = TreeNode(label, "%s", buf);
    if (!is_active) { PopStyleColor(); }
    if (is_active && IsItemHovered())
    {
        ImDrawList* draw_list = GetForegroundDrawList();
        draw_list->AddRect(tab_bar->BarRect.Min, tab_bar->BarRect.Max, (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
        draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMinX, tab_bar->BarRect.Max.y), (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(0)<<0)));
        draw_list->AddLine(ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Min.y), ImVec2(tab_bar->ScrollingRectMaxX, tab_bar->BarRect.Max.y), (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(0)<<0)));
    }
    if (open)
    {
        for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
        {
            const ImGuiTabItem* tab = &tab_bar->Tabs[tab_n];
            PushID(tab);
            if (SmallButton("<")) { TabBarQueueReorder(tab_bar, tab, -1); } SameLine(0, 2);
            if (SmallButton(">")) { TabBarQueueReorder(tab_bar, tab, +1); } SameLine();
            Text("%02d%c Tab 0x%08X '%s' Offset: %.2f, Width: %.2f/%.2f",
                tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID, (tab->NameOffset != -1) ? tab_bar->GetTabName(tab) : "???", tab->Offset, tab->Width, tab->ContentWidth);
            PopID();
        }
        TreePop();
    }
}

void ImGui::DebugNodeViewport(ImGuiViewportP* viewport)
{
    SetNextItemOpen(true, ImGuiCond_Once);
    if (TreeNode("viewport0", "Viewport #%d", 0))
    {
        ImGuiWindowFlags flags = viewport->Flags;
        BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Offset Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f",
            viewport->Pos.x, viewport->Pos.y, viewport->Size.x, viewport->Size.y,
            viewport->WorkOffsetMin.x, viewport->WorkOffsetMin.y, viewport->WorkOffsetMax.x, viewport->WorkOffsetMax.y);
        BulletText("Flags: 0x%04X =%s%s%s", viewport->Flags,
            (flags & ImGuiViewportFlags_IsPlatformWindow) ? " IsPlatformWindow" : "",
            (flags & ImGuiViewportFlags_IsPlatformMonitor) ? " IsPlatformMonitor" : "",
            (flags & ImGuiViewportFlags_OwnedByApp) ? " OwnedByApp" : "");
        for (int layer_i = 0; layer_i < ((int)(sizeof(viewport->DrawDataBuilder.Layers) / sizeof(*(viewport->DrawDataBuilder.Layers)))); layer_i++)
            for (int draw_list_i = 0; draw_list_i < viewport->DrawDataBuilder.Layers[layer_i].Size; draw_list_i++)
                DebugNodeDrawList(
# 13767 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                 __null
# 13767 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                     , viewport->DrawDataBuilder.Layers[layer_i][draw_list_i], "DrawList");
        TreePop();
    }
}

void ImGui::DebugNodeWindow(ImGuiWindow* window, const char* label)
{
    if (window == 
# 13774 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                 __null
# 13774 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                     )
    {
        BulletText("%s: NULL", label);
        return;
    }

    ImGuiContext& g = *GImGui;
    const bool is_active = window->WasActive;
    ImGuiTreeNodeFlags tree_node_flags = (window == g.NavWindow) ? ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_None;
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    const bool open = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window->Name, is_active ? "" : " *Inactive*");
    if (!is_active) { PopStyleColor(); }
    if (IsItemHovered() && is_active)
        GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    if (!open)
        return;

    if (window->MemoryCompacted)
        TextDisabled("Note: some memory buffers have been compacted/freed.");

    ImGuiWindowFlags flags = window->Flags;
    DebugNodeDrawList(window, window->DrawList, "DrawList");
    BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) Ideal (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->ContentSize.x, window->ContentSize.y, window->ContentSizeIdeal.x, window->ContentSizeIdeal.y);
    BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
        (flags & ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_Tooltip) ? "Tooltip " : "", (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
        (flags & ImGuiWindowFlags_Modal) ? "Modal " : "", (flags & ImGuiWindowFlags_ChildMenu) ? "ChildMenu " : "", (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
        (flags & ImGuiWindowFlags_NoMouseInputs)? "NoMouseInputs":"", (flags & ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
    BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window->Scroll.x, window->ScrollMax.x, window->Scroll.y, window->ScrollMax.y, window->ScrollbarX ? "X" : "", window->ScrollbarY ? "Y" : "");
    BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
    BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);
    for (int layer = 0; layer < ImGuiNavLayer_COUNT; layer++)
    {
        ImRect r = window->NavRectRel[layer];
        if (r.Min.x >= r.Max.y && r.Min.y >= r.Max.y)
            BulletText("NavLastIds[%d]: 0x%08X", layer, window->NavLastIds[layer]);
        else
            BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer, window->NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y);
        DebugLocateItemOnHover(window->NavLastIds[layer]);
    }
    BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window->DC.NavLayersActiveMask, window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
    if (window->RootWindow != window) { DebugNodeWindow(window->RootWindow, "RootWindow"); }
    if (window->ParentWindow != 
# 13815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                               __null
# 13815 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ) { DebugNodeWindow(window->ParentWindow, "ParentWindow"); }
    if (window->DC.ChildWindows.Size > 0) { DebugNodeWindowsList(&window->DC.ChildWindows, "ChildWindows"); }
    if (window->ColumnsStorage.Size > 0 && TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
    {
        for (int n = 0; n < window->ColumnsStorage.Size; n++)
            DebugNodeColumns(&window->ColumnsStorage[n]);
        TreePop();
    }
    DebugNodeStorage(&window->StateStorage, "Storage");
    TreePop();
}

void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings* settings)
{
    Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d",
        settings->ID, settings->GetName(), settings->Pos.x, settings->Pos.y, settings->Size.x, settings->Size.y, settings->Collapsed);
}

void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label)
{
    if (!TreeNode(label, "%s (%d)", label, windows->Size))
        return;
    for (int i = windows->Size - 1; i >= 0; i--)
    {
        PushID((*windows)[i]);
        DebugNodeWindow((*windows)[i], "Window");
        PopID();
    }
    TreePop();
}


void ImGui::DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windows_size, ImGuiWindow* parent_in_begin_stack)
{
    for (int i = 0; i < windows_size; i++)
    {
        ImGuiWindow* window = windows[i];
        if (window->ParentWindowInBeginStack != parent_in_begin_stack)
            continue;
        char buf[20];
        ImFormatString(buf, ((int)(sizeof(buf) / sizeof(*(buf)))), "[%04d] Window", window->BeginOrderWithinContext);

        DebugNodeWindow(window, buf);
        Indent();
        DebugNodeWindowsListByBeginStackParent(windows + i + 1, windows_size - i - 1, window);
        Unindent();
    }
}





void ImGui::DebugLog(const char* fmt, ...)
{
    va_list args;
    
# 13871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_start(
# 13871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 13871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ,
# 13871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   fmt
# 13871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 13871 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                      ;
    DebugLogV(fmt, args);
    
# 13873 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   __builtin_va_end(
# 13873 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   args
# 13873 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   )
# 13873 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
               ;
}

void ImGui::DebugLogV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    const int old_size = g.DebugLogBuf.size();
    g.DebugLogBuf.appendf("[%05d] ", g.FrameCount);
    g.DebugLogBuf.appendfv(fmt, args);
    if (g.DebugLogFlags & ImGuiDebugLogFlags_OutputToTTY)
        printf("%s", g.DebugLogBuf.begin() + old_size);
    g.DebugLogIndex.append(g.DebugLogBuf.c_str(), old_size, g.DebugLogBuf.size());
}

void ImGui::ShowDebugLogWindow(bool* p_open)
{
    ImGuiContext& g = *GImGui;
    if (!(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize))
        SetNextWindowSize(ImVec2(0.0f, GetFontSize() * 12.0f), ImGuiCond_FirstUseEver);
    if (!Begin("Dear ImGui Debug Log", p_open) || GetCurrentWindow()->BeginCount > 1)
    {
        End();
        return;
    }

    AlignTextToFramePadding();
    Text("Log events:");
    SameLine(); CheckboxFlags("All", &g.DebugLogFlags, ImGuiDebugLogFlags_EventMask_);
    SameLine(); CheckboxFlags("ActiveId", &g.DebugLogFlags, ImGuiDebugLogFlags_EventActiveId);
    SameLine(); CheckboxFlags("Focus", &g.DebugLogFlags, ImGuiDebugLogFlags_EventFocus);
    SameLine(); CheckboxFlags("Popup", &g.DebugLogFlags, ImGuiDebugLogFlags_EventPopup);
    SameLine(); CheckboxFlags("Nav", &g.DebugLogFlags, ImGuiDebugLogFlags_EventNav);
    SameLine(); CheckboxFlags("Clipper", &g.DebugLogFlags, ImGuiDebugLogFlags_EventClipper);
    SameLine(); CheckboxFlags("IO", &g.DebugLogFlags, ImGuiDebugLogFlags_EventIO);

    if (SmallButton("Clear"))
    {
        g.DebugLogBuf.clear();
        g.DebugLogIndex.clear();
    }
    SameLine();
    if (SmallButton("Copy"))
        SetClipboardText(g.DebugLogBuf.c_str());
    BeginChild("##log", ImVec2(0.0f, 0.0f), true, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);

    ImGuiListClipper clipper;
    clipper.Begin(g.DebugLogIndex.size());
    while (clipper.Step())
        for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)
        {
            const char* line_begin = g.DebugLogIndex.get_line_begin(g.DebugLogBuf.c_str(), line_no);
            const char* line_end = g.DebugLogIndex.get_line_end(g.DebugLogBuf.c_str(), line_no);
            TextUnformatted(line_begin, line_end);
            ImRect text_rect = g.LastItemData.Rect;
            if (IsItemHovered())
                for (const char* p = line_begin; p < line_end - 10; p++)
                {
                    ImGuiID id = 0;
                    if (p[0] != '0' || (p[1] != 'x' && p[1] != 'X') || sscanf(p + 2, "%X", &id) != 1)
                        continue;
                    ImVec2 p0 = CalcTextSize(line_begin, p);
                    ImVec2 p1 = CalcTextSize(p, p + 10);
                    g.LastItemData.Rect = ImRect(text_rect.Min + ImVec2(p0.x, 0.0f), text_rect.Min + ImVec2(p0.x + p1.x, p1.y));
                    if (IsMouseHoveringRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, true))
                        DebugLocateItemOnHover(id);
                    p += 10;
                }
        }
    if (GetScrollY() >= GetScrollMaxY())
        SetScrollHereY(1.0f);
    EndChild();

    End();
}





static const ImU32 DEBUG_LOCATE_ITEM_COLOR = (((ImU32)(255)<<24) | ((ImU32)(0)<<16) | ((ImU32)(255)<<8) | ((ImU32)(0)<<0));

void ImGui::DebugLocateItem(ImGuiID target_id)
{
    ImGuiContext& g = *GImGui;
    g.DebugLocateId = target_id;
    g.DebugLocateFrames = 2;
}

void ImGui::DebugLocateItemOnHover(ImGuiID target_id)
{
    if (target_id == 0 || !IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        return;
    ImGuiContext& g = *GImGui;
    DebugLocateItem(target_id);
    GetForegroundDrawList(g.CurrentWindow)->AddRect(g.LastItemData.Rect.Min - ImVec2(3.0f, 3.0f), g.LastItemData.Rect.Max + ImVec2(3.0f, 3.0f), DEBUG_LOCATE_ITEM_COLOR);
}

void ImGui::DebugLocateItemResolveWithLastItem()
{
    ImGuiContext& g = *GImGui;
    ImGuiLastItemData item_data = g.LastItemData;
    g.DebugLocateId = 0;
    ImDrawList* draw_list = GetForegroundDrawList(g.CurrentWindow);
    ImRect r = item_data.Rect;
    r.Expand(3.0f);
    ImVec2 p1 = g.IO.MousePos;
    ImVec2 p2 = ImVec2((p1.x < r.Min.x) ? r.Min.x : (p1.x > r.Max.x) ? r.Max.x : p1.x, (p1.y < r.Min.y) ? r.Min.y : (p1.y > r.Max.y) ? r.Max.y : p1.y);
    draw_list->AddRect(r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR);
    draw_list->AddLine(p1, p2, DEBUG_LOCATE_ITEM_COLOR);
}


void ImGui::UpdateDebugToolItemPicker()
{
    ImGuiContext& g = *GImGui;
    g.DebugItemPickerBreakId = 0;
    if (!g.DebugItemPickerActive)
        return;

    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
    SetMouseCursor(ImGuiMouseCursor_Hand);
    if (IsKeyPressed(ImGuiKey_Escape))
        g.DebugItemPickerActive = false;
    const bool change_mapping = g.IO.KeyMods == (ImGuiMod_Ctrl | ImGuiMod_Shift);
    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
    {
        g.DebugItemPickerBreakId = hovered_id;
        g.DebugItemPickerActive = false;
    }
    for (int mouse_button = 0; mouse_button < 3; mouse_button++)
        if (change_mapping && IsMouseClicked(mouse_button))
            g.DebugItemPickerMouseButton = (ImU8)mouse_button;
    SetNextWindowBgAlpha(0.70f);
    BeginTooltip();
    Text("HoveredId: 0x%08X", hovered_id);
    Text("Press ESC to abort picking.");
    const char* mouse_button_names[] = { "Left", "Right", "Middle" };
    if (change_mapping)
        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
    else
        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_Text : ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
    EndTooltip();
}


void ImGui::UpdateDebugToolStackQueries()
{
    ImGuiContext& g = *GImGui;
    ImGuiStackTool* tool = &g.DebugStackTool;


    g.DebugHookIdInfo = 0;
    if (g.FrameCount != tool->LastActiveFrame + 1)
        return;



    const ImGuiID query_id = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
    if (tool->QueryId != query_id)
    {
        tool->QueryId = query_id;
        tool->StackLevel = -1;
        tool->Results.resize(0);
    }
    if (query_id == 0)
        return;


    int stack_level = tool->StackLevel;
    if (stack_level >= 0 && stack_level < tool->Results.Size)
        if (tool->Results[stack_level].QuerySuccess || tool->Results[stack_level].QueryFrameCount > 2)
            tool->StackLevel++;


    stack_level = tool->StackLevel;
    if (stack_level == -1)
        g.DebugHookIdInfo = query_id;
    if (stack_level >= 0 && stack_level < tool->Results.Size)
    {
        g.DebugHookIdInfo = tool->Results[stack_level].ID;
        tool->Results[stack_level].QueryFrameCount++;
    }
}


void ImGui::DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void* data_id, const void* data_id_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStackTool* tool = &g.DebugStackTool;



    if (tool->StackLevel == -1)
    {
        tool->StackLevel++;
        tool->Results.resize(window->IDStack.Size + 1, ImGuiStackLevelInfo());
        for (int n = 0; n < window->IDStack.Size + 1; n++)
            tool->Results[n].ID = (n < window->IDStack.Size) ? window->IDStack[n] : id;
        return;
    }


    
# 14076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 14076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   tool->StackLevel >= 0
# 14076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 14076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "tool->StackLevel >= 0"
# 14076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 14076, __extension__ __PRETTY_FUNCTION__))
# 14076 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                   ;
    if (tool->StackLevel != window->IDStack.Size)
        return;
    ImGuiStackLevelInfo* info = &tool->Results[tool->StackLevel];
    
# 14080 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   (static_cast <bool> (
# 14080 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   info->ID == id && info->QueryFrameCount > 0
# 14080 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   ) ? void (0) : __assert_fail (
# 14080 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
   "info->ID == id && info->QueryFrameCount > 0"
# 14080 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
   , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 14080, __extension__ __PRETTY_FUNCTION__))
# 14080 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                         ;

    switch (data_type)
    {
    case ImGuiDataType_S32:
        ImFormatString(info->Desc, ((int)(sizeof(info->Desc) / sizeof(*(info->Desc)))), "%d", (int)(intptr_t)data_id);
        break;
    case ImGuiDataType_String:
        ImFormatString(info->Desc, ((int)(sizeof(info->Desc) / sizeof(*(info->Desc)))), "%.*s", data_id_end ? (int)((const char*)data_id_end - (const char*)data_id) : (int)strlen((const char*)data_id), (const char*)data_id);
        break;
    case ImGuiDataType_Pointer:
        ImFormatString(info->Desc, ((int)(sizeof(info->Desc) / sizeof(*(info->Desc)))), "(void*)0x%p", data_id);
        break;
    case ImGuiDataType_ID:
        if (info->Desc[0] != 0)
            return;
        ImFormatString(info->Desc, ((int)(sizeof(info->Desc) / sizeof(*(info->Desc)))), "0x%08X [override]", id);
        break;
    default:
        
# 14099 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       (static_cast <bool> (
# 14099 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       0
# 14099 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       ) ? void (0) : __assert_fail (
# 14099 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
       "0"
# 14099 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
       , "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp", 14099, __extension__ __PRETTY_FUNCTION__))
# 14099 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                   ;
    }
    info->QuerySuccess = true;
    info->DataType = data_type;
}

static int StackToolFormatLevelInfo(ImGuiStackTool* tool, int n, bool format_for_ui, char* buf, size_t buf_size)
{
    ImGuiStackLevelInfo* info = &tool->Results[n];
    ImGuiWindow* window = (info->Desc[0] == 0 && n == 0) ? ImGui::FindWindowByID(info->ID) : 
# 14108 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp" 3 4
                                                                                            __null
# 14108 "/media/psf/Home/Desktop/git/C-/mac/myproject/external/imgui/src/imgui.cpp"
                                                                                                ;
    if (window)
        return ImFormatString(buf, buf_size, format_for_ui ? "\"%s\" [window]" : "%s", window->Name);
    if (info->QuerySuccess)
        return ImFormatString(buf, buf_size, (format_for_ui && info->DataType == ImGuiDataType_String) ? "\"%s\"" : "%s", info->Desc);
    if (tool->StackLevel < tool->Results.Size)
        return (*buf = 0);




    return ImFormatString(buf, buf_size, "???");
}


void ImGui::ShowStackToolWindow(bool* p_open)
{
    ImGuiContext& g = *GImGui;
    if (!(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSize))
        SetNextWindowSize(ImVec2(0.0f, GetFontSize() * 8.0f), ImGuiCond_FirstUseEver);
    if (!Begin("Dear ImGui Stack Tool", p_open) || GetCurrentWindow()->BeginCount > 1)
    {
        End();
        return;
    }


    ImGuiStackTool* tool = &g.DebugStackTool;
    const ImGuiID hovered_id = g.HoveredIdPreviousFrame;
    const ImGuiID active_id = g.ActiveId;



    Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id);

    SameLine();
    MetricsHelpMarker("Hover an item with the mouse to display elements of the ID Stack leading to the item's final ID.\nEach level of the stack correspond to a PushID() call.\nAll levels of the stack are hashed together to make the final ID of a widget (ID displayed at the bottom level of the stack).\nRead FAQ entry about the ID stack for details.");


    const float time_since_copy = (float)g.Time - tool->CopyToClipboardLastTime;
    Checkbox("Ctrl+C: copy path to clipboard", &tool->CopyToClipboardOnCtrlC);
    SameLine();
    TextColored((time_since_copy >= 0.0f && time_since_copy < 0.75f && fmodf((time_since_copy), (0.25f)) < 0.25f * 0.5f) ? ImVec4(1.f, 1.f, 0.3f, 1.f) : ImVec4(), "*COPIED*");
    if (tool->CopyToClipboardOnCtrlC && IsKeyDown(ImGuiMod_Ctrl) && IsKeyPressed(ImGuiKey_C))
    {
        tool->CopyToClipboardLastTime = (float)g.Time;
        char* p = g.TempBuffer.Data;
        char* p_end = p + g.TempBuffer.Size;
        for (int stack_n = 0; stack_n < tool->Results.Size && p + 3 < p_end; stack_n++)
        {
            *p++ = '/';
            char level_desc[256];
            StackToolFormatLevelInfo(tool, stack_n, false, level_desc, ((int)(sizeof(level_desc) / sizeof(*(level_desc)))));
            for (int n = 0; level_desc[n] && p + 2 < p_end; n++)
            {
                if (level_desc[n] == '/')
                    *p++ = '\\';
                *p++ = level_desc[n];
            }
        }
        *p = '\0';
        SetClipboardText(g.TempBuffer.Data);
    }


    tool->LastActiveFrame = g.FrameCount;
    if (tool->Results.Size > 0 && BeginTable("##table", 3, ImGuiTableFlags_Borders))
    {
        const float id_width = CalcTextSize("0xDDDDDDDD").x;
        TableSetupColumn("Seed", ImGuiTableColumnFlags_WidthFixed, id_width);
        TableSetupColumn("PushID", ImGuiTableColumnFlags_WidthStretch);
        TableSetupColumn("Result", ImGuiTableColumnFlags_WidthFixed, id_width);
        TableHeadersRow();
        for (int n = 0; n < tool->Results.Size; n++)
        {
            ImGuiStackLevelInfo* info = &tool->Results[n];
            TableNextColumn();
            Text("0x%08X", (n > 0) ? tool->Results[n - 1].ID : 0);
            TableNextColumn();
            StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data, g.TempBuffer.Size);
            TextUnformatted(g.TempBuffer.Data);
            TableNextColumn();
            Text("0x%08X", info->ID);
            if (n == tool->Results.Size - 1)
                TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_Header));
        }
        EndTable();
    }
    End();
}
