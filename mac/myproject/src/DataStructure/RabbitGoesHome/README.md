# Rabbit goes home

## 1. QuestionA

​ 该问题为有一只兔子要回家，但是路上有蛇，要求：

​ 1.只能向下或向右移动

​ 2.不碰到蛇的情况下回到家，最后返回可以回家的路径数量。

​ 定义函数如下：

​ 输入: int m 数字化描述地图的列数。

​ 输入:int n 数字化描述地图的行数。

返回值：不碰到蛇的情况下，有几种回家路径。

​    `int rabbitGoesHome(int m, int n, const std::vector<std::vector<int>> &grid);`

由于不需要具体返回路径，只要求返回数量，因次只需记录可不可达即可。

网格描述如下：

| 1    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    |
| 1    | 1    | 1    | 1    |

0代表有蛇，不可通过，1代表没有蛇，可以通过。左下角坐标为(0,0);

采用动态规划减少计算量：

​ 若当前路径点为蛇则不可到达。若不是蛇则 ：

​ 可以到达当前位置的路经为：可到达其上方路径的数量(如果存在上方路径) 加上 可到达其左边路径(如果存在左边路径) 的数量和。

​            `即 dp[i][j]=dp[i][j-1] + dp[i+1][j]`

## 2. QuestionB

​ 采用滚动数组进行优化

## 3.QuestionC

​ 测试代码请看main.cpp

​ 比较好的方式是随机产生大量数据样本，并制作相应结果集。在与其比较。

​ 由于春节将近，此部分尚未完善。采用固定数据集测试。

## 4.QuestionD

​ 由于要记录详细路径，故采用dfs进行搜索，递归返回时，进行回溯。

## 5.QuestionE

​ 类似于QuestionD，只不过多了两个方向。
